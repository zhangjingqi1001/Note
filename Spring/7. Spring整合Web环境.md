# 一、Spring整合Web环境



## 1.1 JavaWeb三大组件及环境特点

**在Java语言范畴内，web层框架都是基于Javaweb基础组件完成的**

*  **Servlet**

   **作用**

   服务端小程序，负责接收客户端请求并作出响应的

   

   **特点**

   单例对象，默认第一次访问创建，可以通过配置指定服务器启动就创建，Servlet创建完毕会执行初始化init方法。每个Servlet有一个service方法，每次访问都会执行service方法，但是缺点是一个业务功能就需要配置一个Servlet

   >  比如说Tomcat服务器启动，就想做某些事，就可以把这段代码写到Servlet的init方法中

>  [ Servlet--HttpServletRequest类、请求转发对象、常用方法、base标签_获取请求转发对象_](https://blog.csdn.net/weixin_51351637/article/details/126237885)
>
>  [Servlet---ServletConfig类使用介绍_servlet config、ServletContext_](https://blog.csdn.net/weixin_51351637/article/details/126211731)

*  **Filter**

   **作用**

   过滤器，负责对客户端请求进行过滤操作的

   

   **特点**

   单例对象，服务器启动时就创建，对象创建完毕执行init方法，对客户端的请求进行过滤，符合要求的放行，不符合要求的直接响应客户端，执行过滤的核心方法doFilter

>  [过滤器与拦截器 - 登录校验与登录认证（JWT令牌技术）](https://blog.csdn.net/weixin_51351637/article/details/130720932)

*  **Listener**

   **作用**

   监听器，负责对域对象的创建和属性变化进行监听的

   

   **特点**

   根据类型和作用不同，又可分为监听域对象创建销毁和域对象属性内容变化的，根据监听的域不同，又可以分为监听Request域的，监听Session域的，监听ServletContext域的

   

## 1.2 Web层MVC框架思想与设计思路



### 1.2.1 设计思路

web层使用Servlet技术充当的话，需要在Servlet中获得Spring容器

**但是我们的Web层不可能只有一个Servlet类**

web层代码如果都去编写创建扫描配置类的代码，那配置类就相当于被重复加载了，有一百个Servlet就有一百个扫描配置类的代码，那Spring容器也被重复创建了

**不能每次想从容器中获得一个Bean都得先创建一次容器，这样肯定是不允许**

```java
@WebServlet(name = "Account", urlPatterns = "/accountServlet")
public class AccountServlet extends HttpServlet {

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
//      web层调用service层，获得AccountService，accountService又存在于Spring容器之中‘
       ApplicationContext applicationContext = new ClassPathXmlApplicationContext("application.xml");
        AccountService accountService = (AccountService) applicationContext.getBean("accountService");
        accountService.transferMoney("tom", "lucy", 100);
    }
}

```



**所以应该做到如下要求**

*  **ApplicationContext只创建一次，配置类只加载一次**



*  **最好web服务器启动时，就执行第1步操作，后续直接从容器中获取Bean使用即可**

   这一步Web三大组件都可以做到，但是Listener比较好一点

   **那监听谁呢？**

   监听SevletContext，因为他代表整个Web应用

   我们可以把下面这一段代码写到Listener监听器内部，服务器启动，监听器执行，便可以加载配置文件，创建Spring容器

   ```java
   ApplicationContext applicationContext = new ClassPathXmlApplicationContext("application.xml");
   ```



*  **ApplicationContext的引用需要在web层任何位置都可以获取到**

   ​    **创建好的容器放在哪呢？才能让web层任何位置都可以获取到？**

   我们可以放到域当中

>     **request域不行**：  这次请求结束之后下次再访问，就是一个新的request域
>
>     **Session域不行**： 不同的客户或者说当前Session过期，那在访问也没有了
>
>     **ServletContext域可以**：只要服务器不挂，这个域就一直在





**解决思路**

*  在ServletContextListener的contextInitialized方法中执行ApplicationContext的创建。
*  或在Servlet的init方法中执行ApplicationContext的创建，并给Servlet的load-on-startup属性一个数字值，确保服务器启动Servlet就创建;
*  将创建好的ApplicationContext存储到ServletContext域中，这样整个web层任何位置就都可以获取到了



### 1.2.2 模拟ContextLoaderListener

**AccountServlet  web层**

```java
@WebServlet(name = "Account", urlPatterns = "/accountServlet")
public class AccountServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
//      或者携程request.getServletContext()
        ServletContext context = getServletContext();
        ClassPathXmlApplicationContext applicationContext = (ClassPathXmlApplicationContext)context.getAttribute("applicationContext");

//      web层调用service层，获得AccountService，accountService又存在于Spring容器之中‘
        AccountService accountService = (AccountService) applicationContext.getBean("accountService");
        accountService.transferMoney("1", "2", 100);

    }
    

}
```

**Listener**

```java
public class ContextLoaderListener implements ServletContextListener {
    //  web容器启动，ServletContext创建
    //contextInitialized只执行一次，服务器启动，ServletContext创建，此方法执行
    @Override
    public void contextInitialized(ServletContextEvent sce) {
        //TODO 1. 创建Spring容器
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");
        //TODO 2. 将Spring容器存储到ServletContext域当中
        sce.getServletContext().setAttribute("applicationContext",applicationContext);

    }
}
```

**web.xml中配置Listener**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
         version="3.1">

    <!--配置Listener-->
    <listener>
        <listener-class>com.zhangjingqi.listener.ContextLoaderListener</listener-class>
    </listener>
</web-app>
```

**如果页面是这种大白板，就没有什么错误**

![image-20230610190800150](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230610190800150.png)

**改善上面的程序，在Listener类中不把我们扫描的配置文件以及配置的变量名称写死**

*  **改善之后的xml文件**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
         version="3.1">

    <!--配置Listener-->
    <listener>
        <listener-class>com.zhangjingqi.listener.ContextLoaderListener</listener-class>
    </listener>
    <!--定义全局参数-->
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <!--classpath 代表类加载路径，也就是resource目录下的东西-->
        <param-value>classpath:applicationContext.xml</param-value>
    </context-param>

</web-app>
```



*  **Listener类**

   这样配置完成之后，原来的applicationContext.xml文件叫啥都行

```java
public class ContextLoaderListener implements ServletContextListener {
    private String CONTEXT_CONFIG_LOCATION = "contextConfigLocation";


    //  web容器启动，ServletContext创建
    //contextInitialized只执行一次，服务器启动，ServletContext创建，此方法执行
    @Override
    public void contextInitialized(ServletContextEvent sce) {
        System.out.println("AccountServlet*******************");
        ServletContext servletContext = sce.getServletContext();
        //TODO 获取contextConfigLocation配置文件的名称
        String contextConfigLocation = servletContext.getInitParameter(CONTEXT_CONFIG_LOCATION);
        // 解析出配置文件的名称
        contextConfigLocation = contextConfigLocation.substring("classpath:".length());
        //TODO 1. 创建Spring容器
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(contextConfigLocation);
        //TODO 2. 将Spring容器存储到ServletContext域当中
        servletContext.setAttribute("applicationContext",applicationContext);

    }
}
```





## 1.3 Spring的Web开发组件Spring-Web

**Spring其实已经为我们定义好了一个ContextLoaderListener**，使用方式跟我们上面自己定义的大体一样，但是功能要比我们强百倍。



**导入Spring-Web坐标**

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-web</artifactId>
    <version>5.3.7</version>
</dependency>
```



**web.xml中配置Listener**，我们只需要引入Spring提供类的即可

```xml
<!--配置Listener-->
<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>
```



**Servlet类**

```java
@WebServlet(name = "Account", urlPatterns = "/accountServlet")
public class AccountServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

//      或者携程request.getServletContext()
        ServletContext context = getServletContext();
        ApplicationContext applicationContext = WebApplicationContextUtils.getWebApplicationContext(context);
//      web层调用service层，获得AccountService，accountService又存在于Spring容器之中‘
        AccountService accountService = (AccountService) applicationContext.getBean("accountService");
        accountService.transferMoney("1", "2", 100);

    }

}
```



# 二、SpringMVC

## 2.0 重新搭建项目

*  **项目结构**

![image-20230610210525520](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230610210525520.png)



*  **Mapper**

   ```java
   public interface AccountMapper {
   //   加钱
       @Update("update account set money=money+#{money} where id=#{id}")
       public void incrMoney(@Param("id") String account, @Param("money") Integer money);
   //   减钱
       @Update("update account set money=money-#{money} where id=#{id}")
       public void decrMoney(@Param("id") String account, @Param("money") Integer money);
   }
   ```

*  **Service**

```java
@Service("accountService")
public class AccountServiceImpl implements AccountService {

    @Autowired
    private AccountMapper accountMapper;


    @Transactional
    public void transferMoney(String outAccount, String inAccount, Integer money) {
        accountMapper.decrMoney(outAccount,money);
//        int c = 3/0;
        accountMapper.incrMoney(inAccount,money);
    }
}
```

*  **Web**

```java
@WebServlet(name = "Account", urlPatterns = "/accountServlet")
public class AccountServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

//      或者携程request.getServletContext()
        ServletContext context = getServletContext();
        ApplicationContext applicationContext = WebApplicationContextUtils.getWebApplicationContext(context);
//      web层调用service层，获得AccountService，accountService又存在于Spring容器之中‘
        AccountService accountService = (AccountService) applicationContext.getBean("accountService");
        accountService.transferMoney("1", "2", 100);

    }

}
```

*  **applicationContext.xml**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/tx
       http://www.springframework.org/schema/tx/spring-tx.xsd">

    <!--组件扫描-->
    <context:component-scan base-package="com.zhangjingqi"></context:component-scan>
    <!--加载JDBC properties-->
    <context:property-placeholder location="classpath:jdbc.properties"></context:property-placeholder>

    <!--配置数据源信息-->
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
        <!--配置必要属性-->
        <property name="driverClassName" value="${jdbc.driver}"/>
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>

    <!--配置SqlSessionFactoryBean ，将SqlSessionFactory存储到Spring容器-->
    <bean class="org.mybatis.spring.SqlSessionFactoryBean">
        <property name="dataSource" ref="dataSource"></property>
    </bean>
    <!--MapperScannerConfigurer，作用赛秒指定的包，产生Mapper对象存储到Spring容器-->
    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
        <property name="basePackage" value="com.zhangjingqi.mapper"></property>
    </bean>
<!--**********************************************************-->
    <!--配置一个平台实物管理器-->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <!--内部需要注入一个DataSource-->
        <property name="dataSource" ref="dataSource"></property>
    </bean>
    <!--配置Spring提供好的Advice,需要配置一个平台事务管理器transaction-manager-->
    <tx:advice id="txAdvice" transaction-manager="transactionManager">
        <tx:attributes>
            <!--代表任意的方法都使用默认情况下的那些事务的属性-->
            <tx:method name="*"/>
        </tx:attributes>
    </tx:advice>

    <!--事务增强的AOP-->
    <aop:config>
        <!--配置切点表达式-->
        <aop:pointcut id="txPointcut" expression="execution(* com.zhangjingqi.service.impl.*.*(..))"/>
        <!-- 配置织入     advice-ref说明：通知/增强引用Spring提供好的-->
        <aop:advisor advice-ref="txAdvice" pointcut-ref="txPointcut"></aop:advisor>
    </aop:config>
<!--    <bean id="accountService" class="com.zhangjingqi.service.impl.AccountServiceImpl"></bean>-->
</beans>
```

*  **web.xml**

```xml 
<!--配置Listener-->
<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>

<!--定义全局参数-->
<context-param>
    <param-name>contextConfigLocation</param-name>
    <!--classpath 代表类加载路径，也就是resource目录下的东西-->
    <param-value>classpath:applicationContext.xml</param-value>
</context-param>
```



## 2.1 Web层MVC框架思想

*  **传统的Javaweb技术栈实现的MVC如下**

   Java程序员在开发一般都是MVC+三层架构，MVC是web开发模式

   Servlet充当Controller的角色，Jsp充当View角色，JavaBean充当模型角色

![image-20230610202032886](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230610202032886.png)

后期Ajax异步流行后，在加上现在前后端分离开发模式成熟后，View就被原始Html+Vue替代

**原始Javaweb开发中，Service充当Controller有很多弊端**

| Servlet作为Controller的问题                                  | 解决思路和方案                                               |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 每个业务功能请求都对应一个Servlet                            | 根据业务模块去划分Controller                                 |
| 每个Servlet的业务操作太繁琐                                  | 将通用的行为，功能进行抽取封装                               |
| Servlet获得Spring容器的组件只能通过客户端代码去获取，不能优雅的整合 | 通过Spring的扩展点，去封装一个框架，从原有的Servlet完全接手过来web层的业务 |





*  **MVC框架思想及其设计思路**

>  共有行为： 比如封装数据、将数据放到域里面、指派视图

**负责共有行为的Servlet称之为前端控制器**

>  前端控制器基本功能
>
>  *  具备可以映射到业务Bean的能力
>  *  具备可以解析请求参数、封装实体等共有功能
>  *  具备响应视图及响应其他数据的功能

**负责业务行为的JavaBean称之为控制器Controller**

![image-20230610212404128](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230610212404128.png)





## 2.2 SpringMVC简介

SpringMVC是一个基于Spring开发的MVC轻量级框架，Spring3.0后发布的组件，SpringMVC和Spring可以无缝整合，使用DispatcherServlet作为前端控制器，且内部提供了处理器映射器、处理器适配器、视图解析器等组件，可以简化JavaBean封装，Json转化、文件上传等操作。

![image-20230610213813672](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230610213813672.png)

















