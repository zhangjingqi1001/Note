[TOC]



# 一、Spring整合Web环境



## 1.1 JavaWeb三大组件及环境特点

**在Java语言范畴内，web层框架都是基于Javaweb基础组件完成的**

*  **Servlet**

   **作用**

   服务端小程序，负责接收客户端请求并作出响应的

   

   **特点**

   单例对象，默认第一次访问创建，可以通过配置指定服务器启动就创建，Servlet创建完毕会执行初始化init方法。每个Servlet有一个service方法，每次访问都会执行service方法，但是缺点是一个业务功能就需要配置一个Servlet

   >  比如说Tomcat服务器启动，就想做某些事，就可以把这段代码写到Servlet的init方法中

>  [ Servlet--HttpServletRequest类、请求转发对象、常用方法、base标签_获取请求转发对象_](https://blog.csdn.net/weixin_51351637/article/details/126237885)
>
>  [Servlet---ServletConfig类使用介绍_servlet config、ServletContext_](https://blog.csdn.net/weixin_51351637/article/details/126211731)

*  **Filter**

   **作用**

   过滤器，负责对客户端请求进行过滤操作的

   

   **特点**

   单例对象，服务器启动时就创建，对象创建完毕执行init方法，对客户端的请求进行过滤，符合要求的放行，不符合要求的直接响应客户端，执行过滤的核心方法doFilter

>  [过滤器与拦截器 - 登录校验与登录认证（JWT令牌技术）](https://blog.csdn.net/weixin_51351637/article/details/130720932)

*  **Listener**

   **作用**

   监听器，负责对域对象的创建和属性变化进行监听的

   

   **特点**

   根据类型和作用不同，又可分为监听域对象创建销毁和域对象属性内容变化的，根据监听的域不同，又可以分为监听Request域的，监听Session域的，监听ServletContext域的

   

## 1.2 Web层MVC框架思想与设计思路



### 1.2.1 设计思路

web层使用Servlet技术充当的话，需要在Servlet中获得Spring容器

**但是我们的Web层不可能只有一个Servlet类**

web层代码如果都去编写创建扫描配置类的代码，那配置类就相当于被重复加载了，有一百个Servlet就有一百个扫描配置类的代码，那Spring容器也被重复创建了

**不能每次想从容器中获得一个Bean都得先创建一次容器，这样肯定是不允许**

```java
@WebServlet(name = "Account", urlPatterns = "/accountServlet")
public class AccountServlet extends HttpServlet {

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
//      web层调用service层，获得AccountService，accountService又存在于Spring容器之中‘
       ApplicationContext applicationContext = new ClassPathXmlApplicationContext("application.xml");
        AccountService accountService = (AccountService) applicationContext.getBean("accountService");
        accountService.transferMoney("tom", "lucy", 100);
    }
}

```



**所以应该做到如下要求**

*  **ApplicationContext只创建一次，配置类只加载一次**



*  **最好web服务器启动时，就执行第1步操作，后续直接从容器中获取Bean使用即可**

   这一步Web三大组件都可以做到，但是Listener比较好一点

   **那监听谁呢？**

   监听SevletContext，因为他代表整个Web应用

   我们可以把下面这一段代码写到Listener监听器内部，服务器启动，监听器执行，便可以加载配置文件，创建Spring容器

   ```java
   ApplicationContext applicationContext = new ClassPathXmlApplicationContext("application.xml");
   ```



*  **ApplicationContext的引用需要在web层任何位置都可以获取到**

   ​    **创建好的容器放在哪呢？才能让web层任何位置都可以获取到？**

   我们可以放到域当中

>     **request域不行**：  这次请求结束之后下次再访问，就是一个新的request域
>
>     **Session域不行**： 不同的客户或者说当前Session过期，那在访问也没有了
>
>     **ServletContext域可以**：只要服务器不挂，这个域就一直在





**解决思路**

*  在ServletContextListener的contextInitialized方法中执行ApplicationContext的创建。
*  或在Servlet的init方法中执行ApplicationContext的创建，并给Servlet的load-on-startup属性一个数字值，确保服务器启动Servlet就创建;
*  将创建好的ApplicationContext存储到ServletContext域中，这样整个web层任何位置就都可以获取到了



### 1.2.2 模拟ContextLoaderListener

**AccountServlet  web层**

```java
@WebServlet(name = "Account", urlPatterns = "/accountServlet")
public class AccountServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
//      或者携程request.getServletContext()
        ServletContext context = getServletContext();
        ClassPathXmlApplicationContext applicationContext = (ClassPathXmlApplicationContext)context.getAttribute("applicationContext");

//      web层调用service层，获得AccountService，accountService又存在于Spring容器之中‘
        AccountService accountService = (AccountService) applicationContext.getBean("accountService");
        accountService.transferMoney("1", "2", 100);

    }
    

}
```

**Listener**

```java
public class ContextLoaderListener implements ServletContextListener {
    //  web容器启动，ServletContext创建
    //contextInitialized只执行一次，服务器启动，ServletContext创建，此方法执行
    @Override
    public void contextInitialized(ServletContextEvent sce) {
        //TODO 1. 创建Spring容器
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");
        //TODO 2. 将Spring容器存储到ServletContext域当中
        sce.getServletContext().setAttribute("applicationContext",applicationContext);

    }
}
```

**web.xml中配置Listener**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
         version="3.1">

    <!--配置Listener-->
    <listener>
        <listener-class>com.zhangjingqi.listener.ContextLoaderListener</listener-class>
    </listener>
</web-app>
```

**如果页面是这种大白板，就没有什么错误**

![image-20230610190800150](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230610190800150.png)

**改善上面的程序，在Listener类中不把我们扫描的配置文件以及配置的变量名称写死**

*  **改善之后的xml文件**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
         version="3.1">

    <!--配置Listener-->
    <listener>
        <listener-class>com.zhangjingqi.listener.ContextLoaderListener</listener-class>
    </listener>
    <!--定义全局参数-->
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <!--classpath 代表类加载路径，也就是resource目录下的东西-->
        <param-value>classpath:applicationContext.xml</param-value>
    </context-param>

</web-app>
```



*  **Listener类**

   这样配置完成之后，原来的applicationContext.xml文件叫啥都行

```java
public class ContextLoaderListener implements ServletContextListener {
    private String CONTEXT_CONFIG_LOCATION = "contextConfigLocation";


    //  web容器启动，ServletContext创建
    //contextInitialized只执行一次，服务器启动，ServletContext创建，此方法执行
    @Override
    public void contextInitialized(ServletContextEvent sce) {
        System.out.println("AccountServlet*******************");
        ServletContext servletContext = sce.getServletContext();
        //TODO 获取contextConfigLocation配置文件的名称
        String contextConfigLocation = servletContext.getInitParameter(CONTEXT_CONFIG_LOCATION);
        // 解析出配置文件的名称
        contextConfigLocation = contextConfigLocation.substring("classpath:".length());
        //TODO 1. 创建Spring容器
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(contextConfigLocation);
        //TODO 2. 将Spring容器存储到ServletContext域当中
        servletContext.setAttribute("applicationContext",applicationContext);

    }
}
```





## 1.3 Spring的Web开发组件Spring-Web

**Spring其实已经为我们定义好了一个ContextLoaderListener**，使用方式跟我们上面自己定义的大体一样，但是功能要比我们强百倍。



**导入Spring-Web坐标**

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-web</artifactId>
    <version>5.3.7</version>
</dependency>
```



**web.xml中配置Listener**，我们只需要引入Spring提供类的即可

```xml
<!--配置Listener-->
<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>
```



**Servlet类**

```java
@WebServlet(name = "Account", urlPatterns = "/accountServlet")
public class AccountServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

//      或者携程request.getServletContext()
        ServletContext context = getServletContext();
        ApplicationContext applicationContext = WebApplicationContextUtils.getWebApplicationContext(context);
//      web层调用service层，获得AccountService，accountService又存在于Spring容器之中‘
        AccountService accountService = (AccountService) applicationContext.getBean("accountService");
        accountService.transferMoney("1", "2", 100);

    }

}
```



# 二、SpringMVC 简介

## 2.0 重新搭建项目

*  **项目结构**

![image-20230610210525520](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230610210525520.png)



*  **Mapper**

   ```java
   public interface AccountMapper {
   //   加钱
       @Update("update account set money=money+#{money} where id=#{id}")
       public void incrMoney(@Param("id") String account, @Param("money") Integer money);
   //   减钱
       @Update("update account set money=money-#{money} where id=#{id}")
       public void decrMoney(@Param("id") String account, @Param("money") Integer money);
   }
   ```

*  **Service**

```java
@Service("accountService")
public class AccountServiceImpl implements AccountService {

    @Autowired
    private AccountMapper accountMapper;


    @Transactional
    public void transferMoney(String outAccount, String inAccount, Integer money) {
        accountMapper.decrMoney(outAccount,money);
//        int c = 3/0;
        accountMapper.incrMoney(inAccount,money);
    }
}
```

*  **Web**

```java
@WebServlet(name = "Account", urlPatterns = "/accountServlet")
public class AccountServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

//      或者携程request.getServletContext()
        ServletContext context = getServletContext();
        ApplicationContext applicationContext = WebApplicationContextUtils.getWebApplicationContext(context);
//      web层调用service层，获得AccountService，accountService又存在于Spring容器之中‘
        AccountService accountService = (AccountService) applicationContext.getBean("accountService");
        accountService.transferMoney("1", "2", 100);

    }

}
```

*  **applicationContext.xml**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/tx
       http://www.springframework.org/schema/tx/spring-tx.xsd">

    <!--组件扫描-->
    <context:component-scan base-package="com.zhangjingqi"></context:component-scan>
    <!--加载JDBC properties-->
    <context:property-placeholder location="classpath:jdbc.properties"></context:property-placeholder>

    <!--配置数据源信息-->
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
        <!--配置必要属性-->
        <property name="driverClassName" value="${jdbc.driver}"/>
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>

    <!--配置SqlSessionFactoryBean ，将SqlSessionFactory存储到Spring容器-->
    <bean class="org.mybatis.spring.SqlSessionFactoryBean">
        <property name="dataSource" ref="dataSource"></property>
    </bean>
    <!--MapperScannerConfigurer，作用赛秒指定的包，产生Mapper对象存储到Spring容器-->
    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
        <property name="basePackage" value="com.zhangjingqi.mapper"></property>
    </bean>
<!--**********************************************************-->
    <!--配置一个平台实物管理器-->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <!--内部需要注入一个DataSource-->
        <property name="dataSource" ref="dataSource"></property>
    </bean>
    <!--配置Spring提供好的Advice,需要配置一个平台事务管理器transaction-manager-->
    <tx:advice id="txAdvice" transaction-manager="transactionManager">
        <tx:attributes>
            <!--代表任意的方法都使用默认情况下的那些事务的属性-->
            <tx:method name="*"/>
        </tx:attributes>
    </tx:advice>

    <!--事务增强的AOP-->
    <aop:config>
        <!--配置切点表达式-->
        <aop:pointcut id="txPointcut" expression="execution(* com.zhangjingqi.service.impl.*.*(..))"/>
        <!-- 配置织入     advice-ref说明：通知/增强引用Spring提供好的-->
        <aop:advisor advice-ref="txAdvice" pointcut-ref="txPointcut"></aop:advisor>
    </aop:config>
<!--    <bean id="accountService" class="com.zhangjingqi.service.impl.AccountServiceImpl"></bean>-->
</beans>
```

*  **web.xml**

```xml 
<!--配置Listener-->
<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>

<!--定义全局参数-->
<context-param>
    <param-name>contextConfigLocation</param-name>
    <!--classpath 代表类加载路径，也就是resource目录下的东西-->
    <param-value>classpath:applicationContext.xml</param-value>
</context-param>
```



## 2.1 Web层MVC框架思想

*  **传统的Javaweb技术栈实现的MVC如下**

   Java程序员在开发一般都是MVC+三层架构，MVC是web开发模式

   Servlet充当Controller的角色，Jsp充当View角色，JavaBean充当模型角色

![image-20230610202032886](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230610202032886.png)

后期Ajax异步流行后，在加上现在前后端分离开发模式成熟后，View就被原始Html+Vue替代

**原始Javaweb开发中，Service充当Controller有很多弊端**

| Servlet作为Controller的问题                                  | 解决思路和方案                                               |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 每个业务功能请求都对应一个Servlet                            | 根据业务模块去划分Controller                                 |
| 每个Servlet的业务操作太繁琐                                  | 将通用的行为，功能进行抽取封装                               |
| Servlet获得Spring容器的组件只能通过客户端代码去获取，不能优雅的整合 | 通过Spring的扩展点，去封装一个框架，从原有的Servlet完全接手过来web层的业务 |





*  **MVC框架思想及其设计思路**

>  共有行为： 比如封装数据、将数据放到域里面、指派视图

**负责共有行为的Servlet称之为前端控制器**

>  前端控制器基本功能
>
>  *  具备可以映射到业务Bean的能力
>  *  具备可以解析请求参数、封装实体等共有功能
>  *  具备响应视图及响应其他数据的功能

**负责业务行为的JavaBean称之为控制器Controller**

![image-20230610212404128](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230610212404128.png)





## 2.2 SpringMVC简介

SpringMVC是一个基于Spring开发的MVC轻量级框架，Spring3.0后发布的组件，SpringMVC和Spring可以无缝整合，使用DispatcherServlet作为前端控制器，且内部提供了处理器映射器、处理器适配器、视图解析器等组件，可以简化JavaBean封装，Json转化、文件上传等操作。

![image-20230610213813672](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230610213813672.png)



## 2.3 快速入门

>    记得创建一个空的工程，什么也没有

![image-20230611115626778](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230611115626778.png)

**导入Maven坐标**

```xml
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
            <version>5.3.10</version>
        </dependency>
```



**配置前端控制器DispatcherServlet**

>  Spring已经封装好了，我们只需要配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    <!--配置DispatcherServlet-->
    <servlet>
        <servlet-name>DispatcherServlet</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    </servlet>
    <!--配置对应映射地址-->
    <servlet-mapping>
        <servlet-name>DispatcherServlet</servlet-name>
        <!--配置路径-->
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>
```



**编写Controller，配置映射路径，并交给SpringMVC容器管理**

```java
@Controller
public class QuickController {
    @RequestMapping("/show")
    public void show(){
        System.out.println("show running");
    }
}
```



**在spring-mvc.xml文件中配置组件扫描**

```xml
<context:component-scan base-package="com.zhangjingqi"></context:component-scan>
```



**怎么加载配置文件呢？**

在创建DispatcherServlet的时候就会加载配置文件，如下配置

>  load-on-startup标签可以设置servlet的加载优先级别和容器是否在启动时加载该servlet，如下设置：
>
>  当为正整数是，表示加载，且数字越小代表优先级越高；若为负数，则容器启动时不加载，只有该servlet被选中才加载

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
         version="3.1">
    <!--配置DispatcherServlet-->
    <servlet>
        <servlet-name>DispatcherServlet</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:spring-mvc.xml</param-value>
        </init-param>
        <load-on-startup>2</load-on-startup>
    </servlet>
    <!--配置对应映射地址-->
    <servlet-mapping>
        <servlet-name>DispatcherServlet</servlet-name>
        <!--配置路径-->
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>
```





## 2.4 Controller访问容器中的Bean

>  在Web层访问Spring容器当中的Service



**首先确定applicationContext.xml中确认开启了组件扫描**

```xml
<!--组件扫描-->
<context:component-scan base-package="com.zhangjingqi"></context:component-scan>
```



**在web.xml文件中配置Listener，加载applicationContext.xml文件**

这一步相当于完成了Spring与SpringMVC的整合

```xml
<!--配置ContextLoaderListener-->
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:applicaitionContext.xml</param-value>
</context-param>
<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>
```



**Controller层注入Service**

```java
@Controller
public class QuickController {
    @Autowired
    private QuickService quickService;

    @RequestMapping("/show")
    public String show(){
        System.out.println("show running"+quickService);
        return "hello word";
    }
}
```



**访问页面后控制台输出**

![image-20230611131456658](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230611131456658.png)





## 2.5 SpringMVC关键组件浅析

很多核心功能类参与到其中，这些**核心功能类**，一般称为**组件**

当请求到达服务器时，是哪个组件接收的请求，是哪个组件帮我们找到的Controller，是哪个组件帮我们调用的方法，又是哪个组件最终解析的视图？

>  ​     请求过来之后找DispatcherServlet前端控制器，但是这些工作不全是前端控制器帮我们做的，只是作为一个总控者（支配其他人干活）
>
>  ​     **前端控制器接收到请求它会去指派不同的组件完成相应的功能**

*  **处理器映射器：HandlerMapping **

>  常用组件 RequestMappingHandlerMapping

匹配映射路径对应的Handler，返回可执行的处理器链对象HandlerExecutionChain对象



*  **处理器适配器：HandlerAdapter **

匹配HandlerExecutionChain对应的适配器进行处理器调用，返回视图模型对象

>  常用组件RequestMappingHandlerAdapter



*  **视图解析器：ViewResolver **

对视图模型对象进行解析InternalResourceViewResolver

>  常用组件



**三个组件之间的关系**

![image-20230611134145623](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230611134145623.png)



## 2.6 SpringMVC加载组件策略（重点）

我们刚刚在快速入门以及Controller层访问Bean的时候，并没有指定什么映射器、处理器之类的，我们下面就来看一下到底是什么

**默认情况下前端控制器在初始化的时候，就会加载（从DispatcherServlet.properties）下图所示的文件，从而会把当前接口对应的组件的实现存储到DispatcherServlet类中的List集合中**

>  没有把初始化好的组件存储到Spring容器当中

![image-20230611135745428](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230611135745428.png)

**组件具体存储到哪我们需要看一下源码，如下图所示DispatcherServlet类中有一个initStrategies方法，初始化各种组件**

![image-20230611140256943](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230611140256943.png)

**我们可以点一个进去，比如点进去initHandlerMappings方法并且debug一下，发现this.handlerMappings中有三个值**

![image-20230611141016074](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230611141016074.png)

**这三个值刚好对应DispatcherServlet.properties中三个组件**

![image-20230611141138399](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230611141138399.png)



**所以把加载好的组件都放在哪里了呢？**

**就是放到了最先定义好的List集合当中**

![image-20230611141405933](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230611141405933.png)





**说明**

**没有把初始化好的组件存储到Spring容器当中**

在208行就是在Spring容器中找是否有HandlerMapping，这个时候是没有的，为null

只有这个时候为null了，在221行才能进入到if语句里面，在222行才能加载默认的DispatcherServlet.properties文件

![image-20230611141950394](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230611141950394.png)

**我们下载试一下，在spring-mvc.xml文件中配置HandlerMapping，仅仅一个（DispatcherServlet.properties文件中默认是三个）**

```xml
<!--配置HandlerMapping-->
<bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"> </bean>
```

**那在208行时就能找到对应的HandlerMapping.class,就不会加载默认的了**

![image-20230611142851064](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230611142851064.png)

**此时就这有一个处理器了，就是我们在配置文件中配置的那个**

![image-20230611142945553](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230611142945553.png)



>  **结论**
>
>  ​    如果人为的在Spring容器中去定义自己组件的话，SpringMVC就不会帮我们加载DispatcherServlet.properties文件中对应的组件了
>
>  ​    如果我们没有人为的在Spring容器中定义自己的组件的话，SpringMVC就会帮我们加载DispatcherServlet.properties文件中对应的组件



# 三、SpringMVC 请求处理

>  这篇文章就很带劲[ Springboot——Controller层开发、请求与响应、RESTful开发规范_springboot控制层代码规范_](https://blog.csdn.net/weixin_51351637/article/details/128042715)



## 3.1 请求映射路径的配置

**配置映射路径，映射器处理器才能找到Controller的方法资源，目前主流映射路径配置方式就是@RequestMapping**

| 相关注解        | 作用                                           | 使用位置   |
| --------------- | ---------------------------------------------- | ---------- |
| @RequestMapping | 设置控制器方法的访问资源路径，可以接收任何请求 | 方法和类上 |
| @GetMapping     | 设置控制器方法的访问资源路径，可以接收GET请求  | 方法和类上 |
| @PostMapping    | 设置控制器方法的访问资源路径，可以接收POST请求 | 方法和类上 |



### 3.1.1 @RequestMapping

主要使用在控制器的方法上，用于标识客户端访问资源路径，常用的属性有value、path、method、headers、params等。

**当@RequestMapping只有一个访问路径需要指定时，使用value属性、path属性或省略value和path**

**当有多个属性时，value和path不能省略**

```java
@RequestMapping(value = "/show")//使用value属性指定一个访问路径
public String show(){}

@RequestMapping(value = {"/show","/haohao","/abc"})//使用value属性指定多个访问路径
public String show(){}

@RequestMapping(path = "/show")//使用path属性指定一个访问路径
public String show(){}

@RequestMapping(path = {"/show","/haohao","/abc"})//使用path属性指定多个访问路径
public String show(){}

@RequestMapping("/show")//如果只设置访问路径时，value和path可以省略
public String show(){}

@RequestMapping({"/show","/haohao","/abc"})
public String show(){}
```



**当@RequestMapping 需要限定访问方式时，可以通过method属性设置**

```java
//请求地址是/show,且请求方式必须是POST才能匹配成功
@RequestMapping(value = "/show",method = RequestMethod.POST)
public String show(){}
```

**method的属性值是一个枚举类型**

```java
public enum RequestMethod {
  GET,
  HEAD,
  POST,
  PUT,
  PATCH,
  DELETE,
  OPTIONS,
  TRACE;
    
  private RequestMethod() {}
    
}
```



### 3.1.2 @GetMapping

当请求方式是GET时，我们可以使用@GetMapping替代@RequestMapping

```java
@GetMapping("/show")
public String show(){}
```



### 3.1.3 @PostMapping

当请求方式是POST时，我们可以使用@PostMapping替代@RequestMapping

```java
@PostMapping("/show")
public String show(){}
```





## 3.2 请求数据的接收

>   这篇文章就很带劲[Springboot——Controller层开发、请求与响应、RESTful开发规范_springboot控制层代码规范](https://blog.csdn.net/weixin_51351637/article/details/128042715)



### 3.2.0 补充： @@RequestParam注解

上面那个链接中也有，也能看看

**参数**

*   **Value：对应的字段**

-   **required：是否为必传参数**
-   **defaultValue：参数默认值**

使用方式的话可以参照 3.2.1 以及上面那篇文章中的内容即可



### 3.2.1 键值对形式参数

*  **接收普通参数**

**接收普通请求数据，当客户端提交的数据是普通键值对形式时，直接使用同名形参接收即可**

```java
username=haohao&age=35
```

接收上面的参数

```java
@GetMapping("/show")
public String show(String username, int age){
   System.out.println(username+"=="+age);
   return "/index.jsp";
}
```

**当请求参数的名称与方法参数名不一致时，可以使用@RequestParam注解进行标注**

```java
username=haohao&age=35
```

**接收上面的参数**

```java
@GetMapping("/show")
public String show(@RequestParam(name = "username",required = true) String name, int age){
   System.out.println(name+"=="+age);
   return "/index.jsp";
}
```



*  **接收数组或集合数据**

**客户端传递多个同名参数时，可以使用数组接收**

```java
hobbies=eat&hobbies=sleep
```

接收上面参数

```java
@GetMapping("/show")
public String show(String[] hobbies){
   for (String hobby : hobbies) {
     System.out.println(hobby);
   }
   return "/index.jsp";
}
```



**客户端传递多个同名参数时，也可以使用单列集合接收，但是需要使用@RequestParam告知框架传递的参数是要同名设置的，不是对象属性设置的**

>   这种情况不加@RequestParam的话会异常
>
>  加上@RequestParam就是告诉SpringMVC，不需要创建什么对象之类的，只需要把参数解析完之后封闭到这个List集合之中就行

```java
@GetMapping("/show")
public String show(@RequestParam List<String> hobbies){
    for (String hobby : hobbies) {
       System.out.println(hobby);
    }
     return "/index.jsp";
}
```



**接收数组或集合数据，客户端传递多个不同命参数时，也可以使用Map<String,Object> 进行接收，同样需要用@RequestParam 进行修饰**

>   这种情况不加@RequestParam的话会异常
>
>  加上@RequestParam就是告诉SpringMVC，不需要创建什么对象之类的，只需要把参数解析完之后封闭到这个Map集合之中就行

```java
username=haohao&age=18
```

接收上面参数

```java
@PostMapping("/show")
public String show(@RequestParam Map<String,Object> params){
   params.forEach((key,value)->{
      System.out.println(key+"=="+value);
   });
      return "/index.jsp";
}
```





### 3.2.2 接收实体类参数

**接收实体JavaBean属性数据，单个JavaBean数据：提交的参数名称只要与Java的属性名一致，就可以进行自动封装**



比如传过来的参数如下图所示

```java
username=haohao&age=35&hobbies=eat&hobbies=sleep
```

封装的实体类如下所示

User类

```java
public class User {
    private String username;
    private Integer age;
    private String[] hobbies;
    private Date birthday;
    private Address address;
}
```

Address地址类

```java
public class Address {
    private String city;
    private String area;
}
```

Controller层

```java
@GetMapping("/show")
public String show(User user){
   System.out.println(user);
   return "/index.jsp";
}
```





**接收实体JavaBean属性数据，嵌套JavaBean数据：提交的参数名称用 . 去描述嵌套对象的属性关系即可**

```java
username=haohao&address.city=tianjin&address.area=jinghai
```



### 3.2.3 @RequestBody

接收Json数据格式数据，Json数据都是以请求体的方式提交的，且不是原始的键值对格式的，所以我们要使用@RequestBody注解整体接收该数据

```json
{
  "username":"haohao",
  "age":18,
  "hobbies":["eat","sleep"],
  "birthday":"1986-01-01",
  "address":{
    "city":"tj",
    "area":"binhai"
   }
}
```

**Controller层进行接收**

```java
@PostMapping("/show6")
public String show6(@RequestBody String body){
   System.out.println(body);
   return "/index.jsp";
}
```

**控制台中就会输出字符串数据**

![image-20230611162155913](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230611162155913.png)



**我们需要的不是普通的字符串，而是实实在在的对象，所以我们需要将字符串转换成对象**

>  其实我自己的话使用FastJSON比较多[ FastJson——JSO字符串与对象的相互转化_fastjson 字符串转对象](https://blog.csdn.net/weixin_51351637/article/details/129938874)
>
>  但是这个地方并没有使用FastJSON，不过也没关系，都一个样

**导入Jackson坐标**

```xml
<dependency>
   <groupId>com.fasterxml.jackson.core</groupId>
   <artifactId>jackson-databind</artifactId>
   <version>2.9.0</version>
</dependency>
```

**Controller层代码**

```java
    @PostMapping("/param7")
    public String show6(@RequestBody String body) throws IOException {
        //获得ObjectMapper
        ObjectMapper objectMapper = new ObjectMapper();
       //将json格式字符串转化成指定的User
        User user = objectMapper.readValue(body, User.class);
        System.out.println(user);

        return "/index.jsp";
    }
```

**输出结果**

![image-20230611164509402](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230611164509402.png)



**当然我们肯定不会手动将JSON数据转成对象，我们可以配置消息转换器**

>  配置RequestMappingHandlerAdapter，指定消息转换器，就不用手动转换json格式字符串了
>
>  将我们自己选中的组件放入Spring容器之中就可以了，那这样就不加载DispatcherServlet.properties文件中对应的默认选项了

**在spring-mvc.xml文件中**

```xml
<!--配置消息转换器-->
<bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter">
    <property name="messageConverters">
        <list>
            <bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"/>
        </list>
    </property>
</bean>
```



**修改一下Controller，如下所示**

```Java
@PostMapping("/param8")
public String param8(@RequestBody User user) throws IOException {
    System.out.println(user);

    return "/index.jsp";
}
```

![image-20230611170152684](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230611170152684.png)



### 3.2.4 Restful风格数据

>   依然是这篇文章[Springboot——Controller层开发、请求与响应、RESTful开发规范_springboot控制层代码规范](https://blog.csdn.net/weixin_51351637/article/details/128042715)



**Rest风格**

Rest（Representational State Transfer）表象化状态转变（表述性状态转变）

**Restful风格的请求，常见的规则**

*  **用URI表示某个模块资源，资源名称为名词**

![image-20230611170759026](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230611170759026.png)



*  **用请求方式表示模块具体业务动作，例如：GET表示查询、POST表示插入、PUT表示更新、DELETE表示删除**

![image-20230611170821750](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230611170821750.png)



*  **用HTTP响应状态码表示结果，国内常用的响应包括三部分：状态码、状态信息、响应数据**

![image-20230611170856375](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230611170856375.png)



**下面我们来接触一下**

*  **url中包含一个参数**

```java
http://localhost/user/100
```

接收上面的数据

```java
@PostMapping("/user/{id}")
public String findUserById(@PathVariable("id") Integer id){
    System.out.println(id);
    return "/index.jsp";
}
```



*  **url中包含多个参数**

```java
http://localhost/user/haohao/18
```

 接收上面的参数

```java
@PostMapping("/user/{username}/{age}")
public String findUserByUsernameAndAge(@PathVariable("username") String username,@PathVariable("age") Integer age){
    System.out.println(username+"=="+age);
    return "/index.jsp";
}
```



### 3.2.5 接收上传的文件

>  可以了解一下这篇文章[Springboot——文件的上传与下载(reggie)_springboot文件下载_](https://blog.csdn.net/weixin_51351637/article/details/130119958?ydreferer=aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTM1MTYzNy9jYXRlZ29yeV8xMTg5Mjk4OS5odG1sP3NwbT0xMDAxLjIwMTQuMzAwMS41NDgyJnlkcmVmZXJlcj1hSFIwY0hNNkx5OWliRzluTG1OelpHNHVibVYwTDNkbGFYaHBibDgxTVRNMU1UWXpOejkwZVhCbFBXSnNiMmMlM0Q%3D)

**接收文件上传的数据，文件上传的表单需要一定的要求**

*  **表单的提交方式必须是POST**
*  **表单的enctype属性必须是multipart/form-data**
*  **文件上传项需要有name属性**

```html
<form action="" enctype="multipart/form-data" method="post" >
     <input type="file" name="myFile">
</form>
```



**默认情况下Spring没有开启MultipartFile接口文件的功能**，也就是说文件接收这个解析器默认是没有的，需要我们认为手工配置



**导入maven坐标**

阿帕奇提供的文件导入的工具

```xml
        <dependency>
            <groupId>commons-fileupload</groupId>
            <artifactId>commons-fileupload</artifactId>
            <version>1.5</version>
        </dependency>
```

**Spring-mvc.xml 配置文件解析器**

>   配置时一定要注意！ id的名字必须叫multipartResolver，因为底层获取文件解析器的时候，就是根据id=multipartResolver获取的
>
>     然后下面各种参数配置大小时，单位是字节

```xml
    <!--配置文件上传解析器，注意：id的名字是固定写法-->
    <bean id="multipartResolver"
          class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
        <property name="defaultEncoding" value="UTF-8"/><!--文件的编码格式 默认是ISO8859-1-->
        <property name="maxUploadSizePerFile" value="1048576"/><!--上传的每个文件限制的大小 单位字节-->
        <property name="maxUploadSize" value="3145728"/><!--上传文件的总大小-->
        <property name="maxInMemorySize" value="1048576"/><!--上传文件的缓存大小-->
    </bean>
```



**Controller层接收文件**

如果上传多个文件使用MultipartFile[]数组接收即可

```java
@PostMapping("/param10")
public String param10(@RequestBody MultipartFile myFile) throws IOException {
    System.out.println(myFile);
    // 将上传的文件进行保存
    //TODO 获得当前上传的文件的输入流
    InputStream inputStream = myFile.getInputStream();

    //TODO 获得上传文件位置的输出流
    OutputStream outputStream = new FileOutputStream("D:/CourseData/"+myFile.getOriginalFilename());

    //TODO 执行文件拷贝
    IOUtils.copy(inputStream,outputStream);

    outputStream.flush();
    //TODO 关闭流资源
    inputStream.close();
    outputStream.close();

    return "hello";
}
```





### 3.2.6 获得Header头信息

*  **接收HTTP请求头数据，接收指定名称的请求头**

```java
@GetMapping("/headers")
public String headers(@RequestHeader("Accept-Encoding") String acceptEncoding){
    System.out.println("Accept-Encoding:"+acceptEncoding);
    return "/index.jsp";
}
```

![image-20230611203928563](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230611203928563.png)

*  **接收所有请求头信息**

```java
@GetMapping("/headersMap")
public String headersMap(@RequestHeader Map<String,String> map){
    map.forEach((k,v)->{
       System.out.println(k+":"+v);
    });
    return "/index.jsp";
}
```

![image-20230611204103753](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230611204103753.png)



### 3.2.7 获取cookie信息

>   cookie也是一个键值对

cookie本身也是一个头，但是比较特殊，与客户端、服务端也能进行一个数据交换，非业务数据，都使用cookie进行传输

>  JSESSIONID  是一个会话的Key

```java
@GetMapping("/cookies")
public String cookies(@CookieValue(value = "JSESSIONID",defaultValue = "") String jsessionid){
    System.out.println(jsessionid);
    return "/index.jsp";
}
```



### 3.2.8 获取Request域哈Session域中的数据

>   后期开发中不怎么会通过域的方式进行数据传输

**获得转发Request域中数据，在进行资源之间转发时，有时需要将一些参数存储到request域中携带给下一个资源**

@RequestAttribute注解的主要作用就是获取域当中的数据，域当中的数据本身就是键值对，所以我们要根据key获取Value

```xml
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>javax.servlet-api</artifactId>
            <version>4.0.1</version>
        </dependency>
```



```java
    @GetMapping("/request1")
    public String request1(HttpServletRequest request) {
//       存储数据
        request.setAttribute("username", "haohao");
        return "/request2";
    }

    @GetMapping("/request2")
    public String request2(@RequestAttribute("username") String username) {
        System.out.println(username);
        return "/index.jsp";
    }
```





### 3.2.9 JavaWeb常用对象获取

获得Javaweb常见原生对象，有时在我们的Controller方法中需要用到Javaweb的原生对象，例如：Request、Response等，我们**只需要将需要的对象以形参的形式写在方法上**，SpringMVC框架在调用Controller方法时，会自动传递实参：

```java
@GetMapping("/javawebObject")
public String javawebObject(HttpServletRequest request, HttpServletResponse response, 
HttpSession session){
    System.out.println(request);
    System.out.println(response);
    System.out.println(session);
    return "/index.jsp";
}
```



## 3.3 静态资源的访问

>    其实就是这篇文章 [解决Whitelabel Error Page最简单的方式](https://blog.csdn.net/weixin_51351637/article/details/126337366)



如今在页面上怎么输入都访问不到静态资源的原因就是我们配置的DispatcherServlet把默认的DispatcherServlet给覆盖掉了，但是默认的DispatcherServlet具有搜索静态资源的能力，但是我们自己创建的这个并没有这个能力

![image-20230611213223669](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230611213223669.png)



*  **解决方案一 再次激活Tomcat的DefaultServlet**

Servlet的url-pattern的匹配优先级是：精确匹配>目录匹配>扩展名匹配>缺省匹配
所以可以指定某个目录下或某个扩展名的资源使用DefaultServlet进行解析

```xml
<servlet-mapping>
   <servlet-name>default</servlet-name>
   <url-pattern>/img/*</url-pattern>
</servlet-mapping>

<servlet-mapping>
   <servlet-name>default</servlet-name>
   <url-pattern>*.html</url-pattern>
</servlet-mapping>
```



*  **解决方案二 在spring-mvc.xml中去配置静态资源映射，匹配映射路径的请求到指定的位置去匹配资源**

   如果请求路径是 /img/* 这种形式的，就映射到/img/文件下找资源

```xml
<!-- mapping是映射资源路径，location是对应资源所在的位置 -->
<mvc:resources mapping="/img/*" location="/img/"/>
<mvc:resources mapping="/css/*" location="/css/"/>
<mvc:resources mapping="/css/*" location="/js/"/>
<mvc:resources mapping="/html/*" location="/html/"/>
```



*  **解决方案三 在spring-mvc.xml中去配置\< mvc:default-servlet-handler \>，**

   该方式是注册了一个DefaultServletHttpRequestHandler 处理器，静态资源的访问都由该处理器去处理，这也是开发中使用最多的

```xml
<mvc:default-servlet-handler/>
```

