



# Bean管理



# 一、SpringBoot Bean 初了解

   先看一下SpringbootBean是怎么个情况，再看一下SpringBean的配置

## 1.1 了解

​       **默认情况下，Spring项目启动时，会把Bean都创建好放在IOC容器中，如果主要获取这些Bean，可以通过如下方式：**

*  **根据name获取bean**： Object getBean（String name）
*  **根据类型获取bean**： \<T\> T getBean(Class \<T\> requiredType) 
*   **根据name获取bean（带类型转换）**： \<T\> T getBean(String name，Class \<T\> requiredType) 



```java
//  IOC容器对象
    @Autowired
    private ApplicationContext applicationContext;

    @Test
    public void testBean(){
//      TODO  根据bean名称获取   若没指定bean名称，默认类名首字母小写
        DeptController deptControllerBean1 =(DeptController) applicationContext.getBean("deptController");
        System.out.println(deptControllerBean1); //com.zhangjingqi.controller.DeptController@249b54af

//      TODO 根据bean的类型获取
        DeptController deptControllerBean2 = applicationContext.getBean(DeptController.class);
        System.out.println(deptControllerBean2);//com.zhangjingqi.controller.DeptController@249b54af

//      TODO 根据bean的名称 及 类型获取
        DeptController deptControllerBean3 = applicationContext.getBean("deptController",DeptController.class);
        System.out.println(deptControllerBean3);//com.zhangjingqi.controller.DeptController@249b54af

    }
```



​       **上述所说的【Spring项目启动时，会把其中的bean创建好】还会受到作用域及延迟初始化影响，这里主要针对于默认的单例非延迟加载的bean而言。**



## 1.2  Bean的作用域

**Spring支持五中作用域，后三种在Web环境下才生效**：

|    作用域     |                      说明                       |
| :-----------: | :---------------------------------------------: |
| **singleton** | 容器内同名称的bean只有一个实例（单例）（默认）  |
| **prototype** |    每次使用该bean时会创建新的实例（非单例）     |
|    request    | 每个请求范围内会创建新的实例（Web环境中，了解） |
|    session    | 每个会话范围内会创建新的实例（Web环境中，了解） |
|  application  | 每个应用范围内会创建新的实例（Web环境中，了解） |



**singleton模式下bean对象情况，并且在容器启动的时候创建好的**

```java
@Test
public void testScope(){
    for (int i=0;i<10;i++){
        DeptController deptControllerBean2 = applicationContext.getBean(DeptController.class);
        System.out.println(deptControllerBean2);
    }
}
```

>  com.zhangjingqi.controller.DeptController@586728e8
>  com.zhangjingqi.controller.DeptController@586728e8
>  com.zhangjingqi.controller.DeptController@586728e8
>  com.zhangjingqi.controller.DeptController@586728e8
>  com.zhangjingqi.controller.DeptController@586728e8
>  com.zhangjingqi.controller.DeptController@586728e8
>  com.zhangjingqi.controller.DeptController@586728e8
>  com.zhangjingqi.controller.DeptController@586728e8
>  com.zhangjingqi.controller.DeptController@586728e8
>  com.zhangjingqi.controller.DeptController@586728e8



**我们也可以在第一次使用的时候实例化 @Lazy**

​    代表延迟初始化，直到第一次使用的时候

```java
@Lazy //
@RestController
@Slf4j
public class DeptController {...}
```



**通过@Scope注解来进行配置作用域**

```java
@Scope("prototype")
@RestController
@Slf4j
public class DeptController {}
```

>  com.zhangjingqi.controller.DeptController@7f6b57f2
>  com.zhangjingqi.controller.DeptController@144ee8a7
>  com.zhangjingqi.controller.DeptController@52b32b70
>  com.zhangjingqi.controller.DeptController@18c820d2
>  com.zhangjingqi.controller.DeptController@3d3930fe
>  com.zhangjingqi.controller.DeptController@5e51ec2e
>  com.zhangjingqi.controller.DeptController@15f2a43f
>  com.zhangjingqi.controller.DeptController@4c65d8e3
>  com.zhangjingqi.controller.DeptController@382faf51
>  com.zhangjingqi.controller.DeptController@69ce14e6



### 1.2.1 注意事项

*   默认singleton的bean，在容器启动时被创建，可以使用@Lazy注解来延迟初始化（延迟到第一次使用时）
*  prototype，每一次使用该bean的时候都会创建一个新的实例
*  实际开发当中，绝大部分的bean是单例的，也就是说绝大部分的bean不需要scope属性的

## 1.3 第三方Bean

​     项目开发中，自己开发的类使用@Component以及其三个衍生注解@Controller、@Service、@Repository注入即可

 

​       **但是还有一种情况是第三方提供的，比如依赖**

比如：dom4j就是第三方组织提供的。 dom4j中的SAXReader类就是第三方编写的。

​     如果我想将SAXReader对象存入到容器，需要在SAXReader类添加@Component注解，但是这是第三方bean，我们是无法修改的是不能添加注解的。

``` xml
        <dependency>
            <groupId>org.dom4j</groupId>
            <artifactId>dom4j</artifactId>
            <version>2.1.3</version>
        </dependency>
```



​       **如果要管理的bean对象来自于第三方（不是自定义的），是无法用@Component及衍生注解生命bean的，此时需要用到@Bean注解**

​        启动类也是配置类，我们完全可以在这里进行注入

```java
//Filter是javaweb三大组件之一，不是Spring提供的，如果想要使用三大组件，需要添加这个注解
@ServletComponentScan
@SpringBootApplication
public class SpringbootWebApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringbootWebApplication.class, args);
    }
    //声明第三方bean
    @Bean //将当前方法的返回值对象交给IOC容器管理, 成为IOC容器bean
    public SAXReader saxReader(){
        return new SAXReader();
    }
}
```



**测试是否可以**

​    创建xml文件，解析下面内容

``` xml
<?xml version="1.0" encoding="UTF-8"?>
<emp>
    <name>Tom</name>
    <age>18</age>
</emp>
```

  挺完美的

```java
@Autowired
private SAXReader saxReader;
@Test
public void testBean2() throws DocumentException {
    Document document = saxReader.read(this.getClass().getClassLoader().getResource("1.xml")
            );

    Element rootElement = document.getRootElement();
    String name = rootElement.element("name").getText();
    String age = rootElement.element("age").getText();
    System.out.println(name + " : " + age); // Tom : 18
}
```



​    但是在Spring项目中，我们一般会**保证启动类的纯粹性**，让启动类仅仅是启动类，我们把其他的配置单独列出来

```java
@Configuration //配置类 (在配置类当中对第三方bean进行集中的配置管理)
public class CommonConfig {
    //声明第三方bean
    @Bean //将当前方法的返回值对象交给IOC容器管理, 成为IOC容器bean
//通过@Bean注解的name/value属性指定bean名称, 如果未指定, 默认是方法名
    public SAXReader reader(DeptService deptService) {
        System.out.println(deptService);
        return new SAXReader();
    }
}
```



****

****

****

****





# 二、 基于XML方式Bean的配置

## 2.1 SpringBean配置概览

| XML配置方式                                 | 功能描述                                                     |
| ------------------------------------------- | ------------------------------------------------------------ |
| \<bean id="" class=""\>                     | Bean的id和全限定名配置                                       |
| \<bean name=""\>                            | 通过name设置Bean的别名，通过别名也能直接获取到Bean实例       |
| \<bean scope=""\>                           | Bean的作用范围，BeanFactory作为容器时取值singleton和prototype |
| \<bean lazy-init=""\>                       | Bean的实例化时机，是否延迟加载。BeanFactory作为容器时无效    |
| \<bean init-method=""\>                     | Bean实例化后自动执行的初始化方法，method指定方法名           |
| \<bean destroy-method=""\>                  | Bean实例销毁前的方法，method指定方法名                       |
| \<bean autowire="byType"\>                  | 设置自动注入模式，常用的有按照类型byType，按照名字byName     |
| \<bean factory-bean="" factory-method=""/\> | 指定哪个工厂Bean的哪个方法完成Bean的创建                     |



## 2.2 bean  id class 配置

**配置UserServiceImpl由Spring容器负责管理**

```java
    <!--class 可以明确Bean在哪-->
    <!--id 为Bean做一个唯一标识-->
    <bean id="userService" class="com.zhangjingqi.service.impl.UserServiceImpl">
    </bean>
```

*  **id**

   **唯一标识，不能与其他bean重复**

   我们最终要getBean，getBean的参数其实是beanName，并不是id，但是**当bean对象进入到容器后，会将id转化成beanName进行存储**

```java
applicationContext.getBean("userService");
```

>    **假如说我们不配置id，会出现什么情况？**
>
>  ​    **这个Bean依然有BeanName**，如下所示
>
>  ```java
>    <bean class="com.zhangjingqi.service.impl.UserServiceImpl">
>      </bean>
>  ```
>
>  **如果不配置id，则Spring会把当前Bean实例的全限定名作为beanName**
>
>  ```java
>  applicationContext.getBean("com.zhangjingqi.service.impl.UserServiceImpl");
>  ```



## 2.3 bean name 别名配置

>  我们一般都是配置id，别名几乎不适用



**可以为当前Bean指定多个别名，根据别名也可以获得Bean对象**

```java
<bean id="userService" name="aaa,bbb" class="com.zhangjingqi.service.impl.UserServiceImpl"/>
```

通过下面的方式都可以获取上面的Bean

```java
applicationContext.getBean("userService");
applicationContext.getBean("aaa");
applicationContext.getBean("bbb");
```



**说明：BeanName就是BeanName，别名就是别名，不在一块进行存储**

下面是BeanName，依然是userService，并没有出现aaa/bbb

![image-20230603162503340](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230603162503340.png)

**那为什么还能通过aaa,bbb获取到呢？**

 如下所示

![image-20230603162747223](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230603162747223.png)





**假如我们没有配置id，但是配置了别名，会出现什么情况？**

```xml
<bean  name="aaa,bbb" class="com.zhangjingqi.service.impl.UserServiceImpl">
</property>
</bean>
```

**如下所示，第一个别名充当BeanName**

![image-20230603163102292](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230603163102292.png)

![image-20230603163008789](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230603163008789.png)



**如果id,name都没有呢？**

   根据class全类名获取



## 2.4 bean scope 作用范围

**Spring支持五中作用域，后三种在Web环境下才生效**：

|    作用域     |                      说明                       |
| :-----------: | :---------------------------------------------: |
| **singleton** | 容器内同名称的bean只有一个实例（单例）（默认）  |
| **prototype** |    每次使用该bean时会创建新的实例（非单例）     |
|    request    | 每个请求范围内会创建新的实例（Web环境中，了解） |
|    session    | 每个会话范围内会创建新的实例（Web环境中，了解） |
|  application  | 每个应用范围内会创建新的实例（Web环境中，了解） |

-  **默认singleton的bean，在容器启动时被创建，可以使用@Lazy注解来延迟初始化（延迟到第一次使用时）**



-  **prototype，每一次使用该bean的时候都会创建一个新的实例**

​          用完之后就找不到这个引用了，最终就释放了，被垃圾回收器给回收了

-  **实际开发当中，绝大部分的bean是单例的，也就是说绝大部分的bean不需要scope属性的**



```java
<!--class 可以明确Bean在哪-->
<!--id 为Bean做一个唯一标识-->
<bean id="userService" scope="prototype" class="com.zhangjingqi.service.impl.UserServiceImpl">

</bean>
```



```java
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml");

        Object userService1 = applicationContext.getBean("userService");
        System.out.println(userService1);//com.zhangjingqi.service.impl.UserServiceImpl@43bc63a3
        Object userService2 = applicationContext.getBean("userService");
        System.out.println(userService2);//com.zhangjingqi.service.impl.UserServiceImpl@702657cc
        Object userService3 = applicationContext.getBean("userService");
        System.out.println(userService3);//com.zhangjingqi.service.impl.UserServiceImpl@6a6cb05c
```



## 2.5 bean 延迟加载

**当lazy-init设置为true时为延迟加载**，也就是当Spring容器创建的时候，不会立即创建Bean实例，等待用到时再创建Bean实例并存储到单例池中去，后续在使用该Bean直接从单例池获取即可，本质上该Bean还是单例的

```xml
    <bean id="userService"  class="com.zhangjingqi.service.impl.UserServiceImpl" lazy-init="true">
    </bean>
```



>  **lazy-init对BeanFactory是无效的**
>
>  ​    比如说lazy-init="false"，此时BeanFactory可以直接帮我们创建嘛？
>
>  ​    这是直接不可能的！
>
>  ​    对ApplicationContext有效





## 2.6 bean 初始化与销毁方法配置

Bean在被实例化后，可**以执行指定的初始化方法完成一些初始化的操作，Bean在销毁之前也可以执行指定的销毁方法完成一些操作**

>   也就是说能指定Bean操作的初始化方法和销毁方法的配置



```java
public class UserServiceImpl implements UserService {

    public void init() {
        System.out.println("Bean实例初始化方法执行");
    }
    public void destroy() {
        System.out.println("Bean实例销毁方法执行");
    }
}    
```

**init方法先执行还是构造方法先执行？**

  构造方法先执行，因为构造方法的执行代表对象的创建

```xml
<bean id="userService"  init-method="init" destroy-method="destroy"
      class="com.zhangjingqi.service.impl.UserServiceImpl" </property>
</bean>
```

**测试**

```java
ApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml");
Object userService1 = applicationContext.getBean("userService");
System.out.println(userService1);
```



控制台只输出了“Bean实例初始化方法执行”



**运行测试方法后，为什么只输出了“Bean实例初始化方法执行”，而没有输出“Bean实例销毁方法执行”？**

​    因为只有容器ApplicationContext显示关闭的时候才会销毁Bean并执行销毁方法

​    我们程序停掉后类似于停点，容器ApplicationContext并不知道要关闭，它根本就没有来得及去执行Bean的销毁方法

   要想执行销毁方法如下所示，执行applicationContext.close();语句

```java
ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml");

Object userService1 = applicationContext.getBean("userService");
System.out.println(userService1);
applicationContext.close();
```





>  **强调一点**
>
>  **Bean的销毁与Bean的销毁方法的调用不是一回事**
>
>  比如说容器ApplicationContext没有了，在内存中已经挂掉了，那Bean肯定也是没有了（因为没有办法维护Bean了，所以Bean也没有了）
>
>  **那Bean销毁后为什么销毁方法没被调用呢？**
>
>  因为Spring还没有执行到那一步，容器就已经挂掉了，已经没办法再调用销毁方法了，所以我们要显示的关闭容器，让Spring容器执行销毁方法
>
>  ```java
>  applicationContext.close();
>  ```





## 2.7 bean实现InitializingBean 接口

我们还可以通**过实现 InitializingBean 接口，完成一些Bean的初始化操作**

**InitializingBean 接口中有一个afterPropertiesSet方法**，当类实现了这个接口之后，Spring容器会自动帮你去调用此方法



>  afterPropertiesSet 字面意思就是在属性设置之后执行，我们测试一下试试

**UserServiceImpl中方法的执行顺序我已经按照顺序拍好了，下面有测试进行验证**

```java
public class UserServiceImpl implements UserService , InitializingBean {
    public UserServiceImpl(){
        System.out.println("实例对象创建了");
    }
    
    // BeanFactory去调用该方法，从容器中获得userDao设置到此处
    public void setUserDao(UserDao userDao) {
        System.out.println("userDao实例："+userDao);
    }
    
    public void afterPropertiesSet() throws Exception {
        System.out.println("InitializingBean...");
    }
    
    public void init() {
        System.out.println("Bean实例初始化方法执行");
    }
    
    public void destroy() {
        System.out.println("Bean实例销毁方法执行");
    }
    
}
```



**配置类**

```xml
<!--class 可以明确Bean在哪-->
<!--id 为Bean做一个唯一标识-->
<bean id="userService"  init-method="init" destroy-method="destroy"
      class="com.zhangjingqi.service.impl.UserServiceImpl" >
    <!--name属性就是set方法的名称，并且把set去掉，首字母小写-->
    <!--ref是引用，从容器中找具体需要哪个对象-->
    <property name="userDao" ref="userDao"></property>
</bean>
<!--配置UserDao-->
<bean id="userDao" class="com.zhangjingqi.dao.impl.UserDaoImpl">

</bean>
```



**测试类**

```java
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml");

        Object userService1 = applicationContext.getBean("userService");

        applicationContext.close();
```





**执行结果**

![image-20230603191447430](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230603191447430.png)





**所以我们初始化Bean的操作有两种了，一种是在bean配置是设置一个init-method属性，并指定对应的方法，另一种方式是类实现InitializingBean类，并重写afterPropertiesSet方法**

>    如果两种操作我都编写了，那谁会先执行？
>
>  ​          afterPropertiesSet执行后再init-method属性对应的方法执行，详细的讲解会在bean的生命周期中说明







# 三、Bean实例化配置

**Spring的实例化方式主要有下面两种**

*  **构造方式实例化**：底层通过构造方法对Bean进行实例化
*  **工厂方式实例化**：底层通过调用自定义的工厂方法对Bean进行实例化



>  **说明**
>
>  ​      我们现在使用Spring容器是通过ApplicationContext，它帮我们调用的BeanFactory底层的对应方法，BeanFactory本身就是工厂，但是**工厂内部帮我们造Bean的时候又分为两种方式，一是通过构造方式实例化，另一种是通过工厂方式实例化**
>
>  ​      说白了就是**工厂内部套工厂**，第一层工厂就是我们的BeanFactory，第二层工厂就是需要我们进行提供了（第二种方式工厂方式实例化），第二层工厂可以产生一个Bean，最终由Spring容器帮我们管理



## 3.1 构造方式实例化Bean

构造方式实例化Bean又**分为无参构造方法实例化和有参构造方法实例化，Spring中配置的\<bean\>几乎都是无参构造该方式**，此处不在赘述。**下面讲解有参构造方法实例化Bean**

>    至于是有参构造还是无参构造实例化，取决于在配置文件中是怎么配置的，默认是无参构造实例化
>
>     那这么说来，默认情况下，我们设置了一个有参构造函数，没有设置无参构造函数，那是会报错的，因为默认是无参构造实例化，有了有参构造函数后就会把无参覆盖掉，此时我们需要手动添加无参构造函数





**配置文件**

```xml
<!--class 可以明确Bean在哪-->
<!--id 为Bean做一个唯一标识-->
<bean id="userService" class="com.zhangjingqi.service.impl.UserServiceImpl">
    
    <!--name: 指定构造方法的参数名 value:指定参数值-->
    <constructor-arg name="name" value="我叫zhangjingqi"></constructor-arg>
    <!--name属性就是set方法的名称，并且把set去掉，首字母小写-->
    <!--ref是引用，从容器中找具体需要哪个对象-->
    <property name="userDao" ref="userDao"></property>

</bean>

<!--配置UserDao-->
<bean id="userDao" class="com.zhangjingqi.dao.impl.UserDaoImpl"></bean>
```



**UserServiceImpl类**

```java
public class UserServiceImpl implements UserService  {

    private UserDao userDao;
    // BeanFactory去调用该方法，从容器中获得userDao设置到此处
    public void setUserDao(UserDao userDao) {
        this.userDao =userDao;
    }

    public UserServiceImpl(){
        System.out.println("UserServiceImpl实例化 - 无参构造注入");
    }

    public UserServiceImpl(String name){
        System.out.println("UserServiceImpl实例化 - 有参构造注入，name="+name);
    }

}
```



**测试程序**

```java

        //参数是一个xml配置文件
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml");
        Object userService1 = applicationContext.getBean("userService");
//        System.out.println(userService1);
        applicationContext.close();
```

**测试结果**

![image-20230603194816081](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230603194816081.png)







**如果我们构造方法是两个参数呢？，会执行下面的哪个构造方法？**

```java
public UserServiceImpl(){
    System.out.println("UserServiceImpl实例化 - 无参构造注入");
}

public UserServiceImpl(String name){
    System.out.println("UserServiceImpl实例化 - 有参构造注入，name="+name);
}
public UserServiceImpl(String name,int age){
    System.out.println("UserServiceImpl实例化 - 有参构造注入，name="+name+",age="+age);
}
```



```xml
<bean id="userService" class="com.zhangjingqi.service.impl.UserServiceImpl">
    <!--name: 指定构造方法的参数名 value:指定参数值-->
    <constructor-arg name="name" value="我叫zhangjingqi"></constructor-arg>
    <constructor-arg name="age" value="22"></constructor-arg>

    <!--name属性就是set方法的名称，并且把set去掉，首字母小写-->
    <!--ref是引用，从容器中找具体需要哪个对象-->
    <property name="userDao" ref="userDao"></property>

</bean>
```

**答案**： 执行public UserServiceImpl(String name,int age）构造方法



>  **说明**：
>
>  ​     constructor-arg标签不仅仅可以用于构造函数的参数，只要是Bean创建时需要的参数，都可以用这个标签进行传输
>
>  ​    下面在Bean工厂时会出现另外一种使用方式





## 3.2 工厂方式实例化Bean

工厂方式实例化Bean，又分为**三种**

*  **静态工厂方法实例化Bean**
   自定义一个工厂，在工厂内部自定义一个静态方法，在静态方法的内部产生一个Bean，最终这个Bean会交给Spring容器管理

   

*  **实例工厂方法实例化Bean**

   自定义一个工厂，在工厂内部自定义一个非静态方法，在非静态方法的内部产生一个Bean，最终这个Bean会交给Spring容器管理

   

*  **实现FactoryBean规范延迟实例化Bean**

   老师说这个一句两句说不明白，不在这里说了。

 

>  ​    **静态工厂方法实例化与实例工厂方法实例化最重要的区别？  **
>
>  ​    静态工厂方法实例化与实例工厂方法实例化最重要的区别就是方法是静态还是非静态
>
>  ​    静态工厂方法实例化产生Bean的时候是不需要创建对象的，直接类名调用即可
>
>  ​      实例工厂方法实例化必须需要实例化对象去调用



### 3.2.1 静态工厂方法实例化Bean

*  **原先是怎么产生Bean的？**

   Spring容器通过全包名反射创建好对象放到容器当中

*  **现在是怎么创建Bean？**

   Spring容器帮我们去调用MyBeanFactory1的静态方法userDao，最终将返回的对象存入到Spring容器之中



**静态工厂**

>   这样使用静态工厂有什么好处呢？
>
>  *  比如我们想在创建UserDaoImpl对象之前执行一些其他的操作，我们就可以在return new UserDaoImpl();语句之前进行编写
>
>  *  由此方法将第三方的对象注入Spring容器

```java
public class MyBeanFactory1 {
    public static UserDao userDao(){
        return new UserDaoImpl();
    }
}
```



**配置文件进行配置**

>     **正常情况下**，在启动时Spring容器会按照全限定名com.zhangjingqi.factory.MyBeanFactory1从无参构造创建MyBeanFactory1对象，创建完对象放入到容器当中id为userDao1，BeanName也是id为userDao1
>
>     **但是此时有 factory-method指定方法为userDao**，此时Spring在解析时就明白了，我们不是把com.zhangjingqi.factory.MyBeanFactory1创建为对象，而是把MyBeanFactory1类中userDao的返回值作为对象，再以我们指定的id作为BeanName存储到容器当中
>
>    **也就是说userDao1指定是userDao方法返回值Bean的名字/id，而不是MyBeanFactory1对象的名字/id**

```xml
<!--创建与之前一个样子-->
<bean id="userDao1" factory-method="userDao"
      class="com.zhangjingqi.factory.MyBeanFactory1">
</bean>
```



**进行测试**

```java
//参数是一个xml配置文件
ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml");
Object userDao1 = applicationContext.getBean("userDao1");
System.out.println("userDao1 = "+userDao1);//userDao1 = com.zhangjingqi.dao.impl.UserDaoImpl@37883b97
```

经过我们的debug，发现userDao1确实是UserDaoImpl类的实例对象，并不是MyBeanFactory1类的

![image-20230603210709794](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230603210709794.png)







### 3.2.2 实例工厂方法实例化Bean

与静态工厂方法实例化Bean的区别就是不是静态的而已。

**工厂**

>  这样使用实例工厂有什么好处呢？
>
>  *  在创建实例化对象之前与之后可以进行一些其他的操作
>
>  *  由此方法将第三方的对象注入Spring容器

```java
public class MyBeanFactory2 {
    public UserDao userDao(){
        return new UserDaoImpl();
    }
}
```



**配置**

   我们应该先创建工厂MyBeanFactory2，让Spring容器帮我们创建工厂对象，再让工厂对象调用userDao方法产生UserDaoImpl对象

```xml
<!--MyBeanFactory2对象-->
<bean id="myBeanFactory2" class="com.zhangjingqi.factory.MyBeanFactory2">
</bean>

<bean id="userDao2" factory-bean="myBeanFactory2" factory-method="userDao" >
</bean>
```





**测试**

成功获取Bean

```java
//参数是一个xml配置文件
ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml");
Object userDao2 = applicationContext.getBean("userDao2");
System.out.println("userDao2 = "+userDao2); //userDao2 = com.zhangjingqi.dao.impl.UserDaoImpl@6913c1fb
```

相当的完美

![image-20230603212845790](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230603212845790.png)







### 3.2.3 有参数的静态工厂和实例工厂方法

*  **静态工厂**

**工厂类**

```java
public class MyBeanFactory1 {

    public static UserDao userDao(String name,int age){
        System.out.println("name:"+name+",age:"+age);
        return new UserDaoImpl();
    }

}
```



**配置文件**

```xml
<bean id="userDao1" factory-method="userDao"
      class="com.zhangjingqi.factory.MyBeanFactory1">
    <constructor-arg name="name" value="我叫zhangjingqi"></constructor-arg>
    <constructor-arg name="age" value="22"></constructor-arg>
</bean>
```



**测试**

```java
ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml");
Object userDao1 = applicationContext.getBean("userDao1");
System.out.println("userDao1 = "+userDao1);
```

![image-20230603213929635](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230603213929635.png)



*  **实例工厂**

**工厂类**

```java
public class MyBeanFactory2 {

    public UserDao userDao(String name,int age){
        System.out.println("name:"+name+",age:"+age);
        return new UserDaoImpl();
    }

}
```



**配置文件**

```xml
<bean id="myBeanFactory2" class="com.zhangjingqi.factory.MyBeanFactory2">
</bean>

<bean id="userDao2" factory-bean="myBeanFactory2" factory-method="userDao" >
    <constructor-arg name="name" value="我叫zhangjingqi"></constructor-arg>
    <constructor-arg name="age" value="22"></constructor-arg>
</bean>
```

**测试类**

```java
//参数是一个xml配置文件
ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml");
Object userDao2 = applicationContext.getBean("userDao2");
System.out.println("userDao2 = "+userDao2);//userDao2 = com.zhangjingqi.dao.impl.UserDaoImpl@609cd4d8
```





### 3.2.4 实现FactoryBean规范延迟实例化Bean

相对复杂一点，这种方式**并不是马上创建Bean，而是在用的时候才创建Bean**

