# Bean的实例化流程及生命周期



# 一、Bean实例化基本流程

## 1.1 Bean实例化基本流程

**从标签的配置到对象进入容器中，是怎么样的一个过程？**

*  **Spring容器在进行初始化时，会将xml配置的\<bean\>的信息封装成一个BeanDefinition对象**

   比如下面两段配置，会封装成两个BeanDefinition对象，因为这个信息在内存中也需要存储（并不是userService、userDao对象）

```xml
<bean id="userService"  class="com.zhangjingqi.service.impl.UserServiceImpl"/>

<bean id="userDao" class="com.zhangjingqi.dao.impl.UserDaoImpl"></bean>
```



*  **所有的BeanDefinition对象存储到一个名为beanDefinitionMap的集合中去，Spring框架再对该Map进行遍历，使用反射创建Bean实例对象**

   beanDefinitionMap集合就是在BeanFactory中进行维护，如下所示

   beanDefinitionMap的Value就是对当前配置的这个Bean的信息进行封装的

![image-20230605135938405](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230605135938405.png)

我们随意点开一个看一看，它的**Value并不是一个userDao对象**，而是一个，而是一个GenericBeanDefinition，说白了就**是一个Bean标签信息**

![image-20230605140333446](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230605140333446.png)



>  ​    **只要将BeanDefinition注册到beanDefinitionMap这个Map中，Spring就会进行对应的Bean的实例化操作**



*  **创建好的Bean对象存储在一个名为singletonObjects的Map集合中，当调用getBean方法时，则最终从该Map集合中取出Bean实例对象返回**。

   singletonObjects就是一个单例池 ，也是一个Map集合

   当我们调用getBean的时候，就是根据getBean方法参数去Map集合中取出对应的Value值

![image-20230605140037210](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230605140037210.png)







>  ​      当前的beanFactory是DefaultListableBeanFactory工厂对象，此对象中的各种属性，就是下图beanFactory下面的参数
>
>  ![image-20230605143319758](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230605143319758.png)
>
>  
>
>  ​       DefaultListableBeanFactory对象内部维护着一个Map用于存储封装好的BeanDefinitionMap（在上面已经说到过了）
>
>  ```java
>  public class DefaultListableBeanFactory extends ... implements ... {
>      //存储<bean>标签对应的BeanDefinition对象
>      //key:是Bean的beanName，value:是Bean定义对象BeanDefinition
>      private final Map<String, BeanDefinition> beanDefinitionMap;
>  }
>  ```
>
>  



## 1.2 总结

*  加载xml配置文件，解析获取配置中的每个\<bean\>的信息，封装成一个个的BeanDefinition对象



*  将BeanDefinition存储在一个名为beanDefinitionMap的Map<String,BeanDefinition>中



*  ApplicationContext底层遍历beanDefinitionMap，创建Bean实例对象



*  创建好的Bean实例对象，被存储到一个名为singletonObjects的Map<String,Object>中



*  当执行applicationContext.getBean(beanName)时，从singletonObjects去匹配Bean实例返回

![image-20230605145506928](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230605145506928.png)



# 二、 Bean 后处理器

## 2.1 介绍

​       Spring的后处理器是Spring**对外开发的重要扩展点**，允许我们**介入到Bean的整个实例化流程**中来，以**达到动态注册BeanDefinition，动态修改BeanDefinition，以及动态修改Bean的作用**。



>   框架本身把一些功能封装好了，也有一些约定俗成的东西（按照他们的配置进行配置，最终就能完成响应的一些功能），但是有的时候我们需要自己介入到他的整个过程



**Spring主要有两种后处理器**：

*  **BeanFactoryPostProcessor**：**Bean工厂后处理器**，在BeanDefinitionMap填充完毕，**Bean实例化之前执行**



*  **BeanPostProcessor**：**Bean后处理器，一般在Bean实例化之后，填充到单例池singletonObjects之前执行**





## 2.2 BeanFactoryPostProcessor Bean工厂后处理器

**BeanFactoryPostProcessor**：**Bean工厂后处理器**，在BeanDefinitionMap填充完毕，**Bean实例化之前执行**



BeanFactoryPostProcessor是一个**接口规范，实现了该接口的类只要交由Spring容器管理的话，那么Spring就会回调该接口的方法，用于对BeanDefinition注册和修改的功能**。

```java
@FunctionalInterface
public interface BeanFactoryPostProcessor {
    void postProcessBeanFactory(ConfigurableListableBeanFactory var1) throws BeansException;
}
```

### 2.2.1 入门

**定义类MyBeanFactoryPostProcessor并实现接口BeanFactoryPostProcessor**

```java
public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
    //方法对应的参数就是BeanFactory
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
        System.out.println("beanDefinitionMap填充完毕后回调该方法...");

    }
}
```



**配置信息**

```xml
<bean class="com.zhangjingqi.processor.MyBeanFactoryPostProcessor"></bean>
```



**测试类**

```java
ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml");
```

![image-20230605152809082](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230605152809082.png)



**那这个工厂后处理器有什么作用呢？看下面这个例子**

**配置文件**

注意看userService对应的全限定名

```xml
<bean class="com.zhangjingqi.processor.MyBeanFactoryPostProcessor"></bean>

<bean id="userService"  class="com.zhangjingqi.service.impl.UserServiceImpl"/>
```

**工厂后处理器**

```java
public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
    //方法对应的参数就是BeanFactory
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
        System.out.println("beanDefinitionMap填充完毕后回调该方法...");
        //修改某一个beanDefinition
        // 说明：为了安全起见，并没有给我们提供getBeanDefinitionMap方法
        //      但是允许我们根据名字取获取某一个beanDefinition
        BeanDefinition beanDefinition = beanFactory.getBeanDefinition("userService");
        //userService全限定名是com.zhangjingqi.service.impl.UserServiceImpl
        //我们现在要改成com.zhangjingqi.dao.impl.UserDaoImpl
        beanDefinition.setBeanClassName("com.zhangjingqi.dao.impl.UserDaoImpl");

    }
}
```



**测试**

发现已经不是UserServiceImpl，而是UserDaoImpl

```java
//参数是一个xml配置文件
ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml");
Object userService = applicationContext.getBean("userService");
System.out.println(userService);
```

![image-20230605154146828](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230605154146828.png)





### 2.2.2 Bean工厂后处理器注册BeanDefinition

之前我们创建Bean是在对应的xml文件中进行添加Bean标签

现在我们换一种方式，将Bean的注册放在工厂后处理器中

**Bean工厂后处理器注册BeanDefinition**

```java
    //方法对应的参数就是BeanFactory
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
        System.out.println("beanDefinitionMap填充完毕后回调该方法...");
//      注册BeanDefinition
        BeanDefinition beanDefinition = new RootBeanDefinition();
        beanDefinition.setBeanClassName("com.zhangjingqi.dao.impl.PersonDaoImpl");

//      ConfigurableListableBeanFactory内部没有注册BeanDefinition
//      beanFactory.registerSingleton();此方法是其放入到单例池当中
//      需要把ConfigurableListableBeanFactory类型强转为子类DefaultListableBeanFactory
        DefaultListableBeanFactory defaultListableBeanFactory = (DefaultListableBeanFactory)beanFactory;
        defaultListableBeanFactory.registerBeanDefinition("personDao",beanDefinition);
    }
```

**测试**

```java
ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml");
Object personDao = applicationContext.getBean("personDao");
System.out.println(personDao);
```

![image-20230605160422799](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230605160422799.png)



### 2.2.3 BeanDefinitionRegistryPostProcessor专门注册BeanDefinition操作

Spring 提供了一个BeanFactoryPostProcessor的子接口**BeanDefinitionRegistryPostProcessor专门用于注册BeanDefinition操作**，不再需要强转参数，比较方便

```java
public class MyBeanFactoryPostProcessor2 implements BeanDefinitionRegistryPostProcessor {

//  之前接口的方法
    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {
        System.out.println("MyBeanFactoryPostProcessor2的postProcessBeanFactory方法");
    }

//   BeanDefinitionRegistryPostProcessor接口的方法，专门用于注册BeanDefinition操作
    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry)
            throws BeansException {
        System.out.println("MyBeanFactoryPostProcessor2的postProcessBeanDefinitionRegistry");

        BeanDefinition beanDefinition = new RootBeanDefinition();

        beanDefinition.setBeanClassName("com.zhangjingqi.dao.impl.UserDaoImpl");

        beanDefinitionRegistry.registerBeanDefinition("userDao2", beanDefinition);
    }
}
```



**执行顺序**

![image-20230605162953015](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230605162953015.png)





### 2.2.4 完善实例化基本流程图

BeanDefinitionRegistryPostProcessor接口的实现类执行顺序要比其父类接口BeanFactoryPostProcessor的实现类的执行顺序靠前，如下图所示

![image-20230605163304002](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230605163304002.png)









## 2.3 BeanPostProcessor Bean后处理器

**BeanPostProcessor**：**Bean后处理器，一般在Bean实例化之后，填充到单例池singletonObjects之前执行**



>  Bean被实例化后，到最终缓存到名为singletonObjects单例池之前，**中间会经过Bean的初始化过程**
>
>  例如：属性的填充、初始方法init的执行等，其中有一个对外进行扩展的点BeanPostProcessor，我们称为Bean后处理。跟上面的Bean工厂后处理器相似，它也是一个接口，实现了该接口并被容器管理的BeanPostProcessor，会在流程节点上被Spring自动调用。



### 2.3.1 入门

**BeanPostProcessor接口实现类代码**

   Bean实例化之后才执行下面的两个方法

>  参数： bean是当前被实例化的Bean**，**beanName是当前Bean实例在容器中的名称
>
>  *返回值：当前**Bean**实例对象* 



```java
public class MyBeanPostProcessor implements BeanPostProcessor {
//  先执行
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println(bean+":postProcessBeforeInitialization:"+beanName);
        return bean;
    }

//  后执行
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println(bean+":postProcessAfterInitialization:"+beanName);
        return bean;
    }
}
```



**配置文件信息**

```xml
<bean class="com.zhangjingqi.factory.MyBeanPostProcessor"></bean>
```

 然后我们再随便配置一个bean，否则没有效果

```xml
<bean id="userService" class="com.zhangjingqi.service.impl.UserServiceImpl"/>
```



**测试信息**

```java
ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml");
```



![image-20230605202459396](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230605202459396.png)



### 2.3.2 before 与 after执行时机

由下图可得，执行顺序肯定是先before再after

![image-20230605202459396](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230605202459396.png)



**那在before与after方法中间有哪些操作呢？**

   对应Bean的一些初始化方法

 **顺序**： 

**①Bean先创建**



**②执行before方法**



**③执行Bean初始化操作**

>  需要再Bean创建时指定 init-method="init"参数与参数值 
>
>  或者是实现InitializingBean接口并重写afterPropertiesSet方法
>
>  如果都有的话，先执行afterPropertiesSet方法再执行init-method

```xml
<bean id="userDao"  init-method="init"
      class="com.zhangjingqi.dao.impl.UserDaoImpl"></bean>
```

```java
public class UserDaoImpl implements UserDao, InitializingBean {
    public UserDaoImpl() {
        System.out.println("userDao实例化");
    }

    public void init() {
        System.out.println("init 初始化方法开始执行");
    }

    public void afterPropertiesSet() throws Exception {
        System.out.println("afterPropertiesSet");
    }
}
```

![image-20230605204450140](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230605204450140.png)



**④执行after方法**





### 2.3.3 对Bean方法进行执行时间日志增强

**要求**

*  **Bean的方法执行之前控制台打印当前时间**
*  **Bean的方法执行之后控制台打印当前时间**

>  
>
>  *  对方法进行增强主要就是代理设计模式和包装设计模式；
>
>  *  由于Bean方法不确定，所以使用动态代理在运行期间执行增强操作；
>
>  *  在Bean实例创建完毕后，进入到单例池之前，使用Proxy代替真是的目标Bean



```java
public class TimeLogBeanPostProcessor implements BeanPostProcessor {
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        //     使用动态代理对目标Bean进行增强，返回proxy对象，进而存储到单例池当中
        Object proxyBean = Proxy.newProxyInstance(bean.getClass().getClassLoader(),
                bean.getClass().getInterfaces(),
                (Object proxy, Method method, Object[] args) -> {
                    long start = System.currentTimeMillis();
                    System.out.println("开始时间：" + new Date(start));
                    //执行目标方法
                    Object result = method.invoke(bean, args);
                    long end = System.currentTimeMillis();
                    System.out.println("结束时间：" + new Date(end));
                    return result;
                });
        //返回代理对象
        return proxyBean;

    }
}
```



其实我感觉这个地方是有点难度的，但是在SpringBoot当中时非常简单的，可以看一下下面这篇文章[SpringBoot——IOC与AOP_](https://blog.csdn.net/weixin_51351637/article/details/130779252)









### 2.3.4 完善实例化基本流程图

![image-20230605211520347](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230605211520347.png)



# 三、SpringBean 生命周期

**生命周期**：从 Bean 实例化之后，即通过反射创建出对象之后，到Bean成为一个完整对象，最终存储到单例池中

**Spring Bean的生命周期大体上分为三个阶段**

*  **Bean的实例化阶段**

Spring框架会取出BeanDefinition的信息进行判断当前Bean的范围是否是singleton的，是否不是延迟加载的，是否不是FactoryBean等，最终将一个普通的singleton的Bean通过反射进行实例化



*  **Bean的初始化阶段**

Bean创建之后还仅仅是个"半成品"，还需要对Bean实例的属性进行填充、执行一些Aware接口方法、执行BeanPostProcessor方法、执行InitializingBean接口的初始化方法、执行自定义初始化init方法等。该阶段是Spring最具技术含量和复杂度的阶段，Aop增强功能，后面要学习的Spring的注解功能等、spring高频面试题Bean的循环引用问题都是在这个阶段体现的；





*  **Bean的完成阶段**

经过初始化阶段，Bean就成为了一个完整的Spring Bean，被存储到单例池singletonObjects中去了，即完成了Spring Bean的整个生命周期。





