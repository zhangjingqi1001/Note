# 4. Spring的注解开发

可以对照[Spring Bean、XML方式Bean配置、Bean实例化配置、Bean注入](https://blog.csdn.net/weixin_51351637/article/details/131056590)进行学习

# 一、Bean 基本注解开发

注解方式慢慢成为xml配置的替代方案

基本Bean注解，主要是使用注解的方式替代原有xml的\<bean\> 标签及其标签属性的配置

```xml
<bean id="" name="" class="" scope="" lazy-init="" init-method="" destroy-method="" 
      
abstract="" autowire="" factory-bean="" factory-method=""></bean>
```



**使用@Component 注解替代\<bean\>标签**

| XML 配置                | 注解       | 描述                                                     |
| ----------------------- | ---------- | -------------------------------------------------------- |
| \<bean id="" class=""\> | @Component | 被该注解标识的类，会在指定扫描范围内被Spring加载并实例化 |



## 1.1 @Component Bean的配置

**value属性**指定当前Bean实例的beanName,也可以省略不写，不写的情况下为当前类名首字母小写

```java
//获取方式：applicationContext.getBean("userDao");
@Component("userDao")
public class UserDaoImpl implements UserDao {
}

//获取方式：applicationContext.getBean("userDaoImpl");
@Component
public class UserDaoImpl implements UserDao {
}
```

**这样配置还不算完，Spring还不知道我们要扫描这个注解，所以还需要配置扫描的范围**

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd">

    <!-- 告知Spring框架去com.zhangjngqi包及其子包下去扫描使用了注解的类 -->
    <context:component-scan base-package="com.zhangjingqi"/>
</beans>    
```



**此时就能获取到注解创建的UserServiceImpl对象**

```java
ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml");
Object userService = applicationContext.getBean("userDaoImpl");
System.out.println(userService);
```



## 1.2 其他注解配置Bean

@Component就单纯一个value属性，那么**xml配置\<bean\> 时那些属性怎么进行配置呢**？

Spring 是通过注解方式去配置的之前 \<bean\> 标签中的那些属性，例如：@Scope

```xml
<bean id="" name="" class="" scope="" lazy-init="" init-method="" destroy-method="" 
abstract="" autowire="" factory-bean="" factory-method=""></bean>
```

>  记不得了可以看一下这篇文章[Spring Bean、XML方式Bean配置、Bean实例化配置、Bean注入](https://blog.csdn.net/weixin_51351637/article/details/131056590)

| xml配置                    | 注解           | 描述                                                         |
| -------------------------- | -------------- | ------------------------------------------------------------ |
| \<bean scope=""\>          | @Scope         | 在类上或使用了@Bean标注的方法上，标注Bean的作用范围，取值为singleton或prototype |
| \<bean lazy-init=""\>      | @Lazy          | 在类上或使用了@Bean标注的方法上，标注Bean是否延迟加载，取值为true和false |
| \<bean init-method=""\>    | @PostConstruct | 在方法上使用，标注Bean的实例化后执行的方法                   |
| \<bean destroy-method=""\> | @PreDestroy    | 在方法上使用，标注Bean的销毁前执行方法                       |



```java
@Component("userDao")
@Scope("singleton")
@Lazy(true)
public class UserDaoImpl implements UserDao{
   @PostConstruct
   public void init(){}
    
   @PreDestroy
   public void destroy(){}
}
```





## 1.3 @Component 衍生注解

>  在这篇文章中也有对衍生注解的介绍，但是就是一点点而已[SpringBoot——IOC与AOP](https://blog.csdn.net/weixin_51351637/article/details/130779252)

| 注解        | 说明                                            |
| ----------- | ----------------------------------------------- |
| @Controller | 标注在控制器                                    |
| @Service    | 标注在业务类上                                  |
| @Repository | 标注在数据访问类上（由于与Mybatis整合，用的少） |

>   不属于上面三层的，大多数使用@Component就可以

```java
@Repository("userDao")
public class UserDaoImpl implements UserDao{}

@Service("userService")
public class UserServiceImpl implements UserService{}

@Controller("userService")
public class UserController {}
```







# 二、Bean依赖注入注解开发

Bean依赖注入的注解，主要是使用注解的方式替代xml的 <property> 标签完成属性的注入操作

**之前的注入方式**

```xml
<bean id="" class="">
   <property name="" value=""/>
   <property name="" ref=""/>
</bean>
```



**如今注解注入方式**

| 属性注入注解 | 描述                                                   |
| ------------ | ------------------------------------------------------ |
| @Value       | 使用在字段或方法上，用于注入普通数据                   |
| @Autowired   | 使用在字段或方法上，用于根据类型（byType）注入引用数据 |
| @Qualifier   | 使用在字段或方法上，结合@Autowired，根据名称注入       |
| @Resource    | 使用在字段或方法上，根据类型或名称进行注入             |



>   **说明**
>
>  @Resource注解是Java EE规范提供的，它在JDK中的javax.annotation.Resource包中定义。
>
>  在Spring中，可以使用@Resource注解来注入Bean，但它也支持其他注解，如@Autowired和@Inject。
>
>  这些注解提供了相同的功能，但有些微小的差异。
>
>  @Autowired注解是Spring提供的，而@Inject注解是JSR-330规范中定义的。



## 2.1 @Value

*  **直接注入普通属性**

```java
@Value("haohao")
private String username;

@Value("haohao")
public void setUsername(String username){
    System.out.println(username);
}
```



>  基本上没这么做的，主要看第二点，注入注入properties文件中的属性



*  **注入properties文件中的属性**

>  SpringBoot读取方式[ 在SpringBoot中读取yaml配置文件中的数据、全部数据、部分数据_yaml 数组对象 读取_](https://blog.csdn.net/weixin_51351637/article/details/124048275)
>
>  下面来看一下Spring读取properties文件



```java
@Value("${jdbc.username}")
private String username;

@Value("${jdbc.username}")
public void setUsername(String username){
    System.out.println(username);
}
```

**加载properties文件**

```xml
<context:property-placeholder location="classpath:jdbc.properties"/>
```





## 2.2 @Autowired

```java
//使用在属性上直接注入
@Autowired
private UserDao userDao;

//使用在方法上直接注入
@Autowired
public void setUserDao(UserDao userDao){
      System.out.println(userDao);
}
```



当容器中同一类型的Bean实例有多个时，会尝试自动根据名字进行匹配(如果名字匹配不成狗就会报错)

```java
//匹配当前Bean
@Repository("userDao")
public class UserDaoImpl implements UserDao{}

@Repository("userDao2")
public class UserDaoImpl2 implements UserDao{}
```



下面的这段话也能注入UserDao，但是只不过仅仅在此方法中使用

```java
@Autowired
public void xxx(UserDao userDao){
    System.out.println(userDao);
}
```



下面这段自动注入的含义是，在Spring容器中找UserDao类型的对象，然后放入到userDaoList集合当中

```java
@Autowired
public void yyy(List<UserDao> userDaoList){
    System.out.println(userDaoList);
}
```



## 2.3 @Qualifier

@Qualifier配合@Autowired可以完成根据名称注入Bean实例，**使用@Qualifier指定名称**

```java
@Autowired
@Qualifier("userDao2")
  private UserDao userDao;

@Autowired
@Qualifier("userDao2")
public void setUserDao(UserDao userDao){
  System.out.println(userDao);
}
```



>  别的地方@Qualifier可以单独使用



## 2.4 @Resource

**@Resource注解存在与 javax.annotation 包中，Spring对其进行了解析**

>   **说明**
>
>  @Resource注解是Java EE规范提供的，它在JDK中的javax.annotation.Resource包中定义。
>
>  在Spring中，可以使用@Resource注解来注入Bean，但它也支持其他注解，如@Autowired和@Inject。
>
>  这些注解提供了相同的功能，但有些微小的差异。
>
>  @Autowired注解是Spring提供的，而@Inject注解是JSR-330规范中定义的。

**@Resource注解既可以根据类型注入，也可以根据名称注入，无参就是根据类型注入，有参数就是根据名称注入**

```java
@Resource
private UserDao userDao;

@Resource(name = "userDao2")
public void setUserDao(UserDao userDao){
    System.out.println(userDao);
}
```

@Resource注解会首先根据name属性指定的名称去查找对应的Bean进行注入，如果找到了，则使用名称匹配的方式注入；

如果没有指定name属性或者找不到匹配的Bean，则根据类型进行注入。

如果有多个同类型的Bean，也会使用名称匹配的方式来确定要注入哪个Bean。需要注意的是，如果有多个同类型且同名称的Bean，那么@Resource注解会抛出NoUniqueBeanDefinitionException异常。



>  **@Resource与@Autowired区别**：
>
>  *  来源不同：@Resource是Java EE规范定义的注解，而@Autowired是Spring框架定义的注解。
>
>  *  注入方式不同：@Resource默认按照Bean的名称进行注入，如果找不到与名称相匹配的Bean，则按照类型进行注入。而@Autowired默认按照类型进行注入，如果出现多个相同类型的Bean，则再按照名称进行匹配。
>
>  *  属性名称不同：@Autowired没有name属性，而@Resource有name属性，可以指定要注入Bean的名称。
>
>  *  是否支持JSR-330：@Autowired支持JSR-330的@Inject注解，而@Resource不支持。



# 三、非自定义注解开发







