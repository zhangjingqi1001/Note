# 存储引擎



# 一、 存储引擎

## 1.1 MySQL结构



![image-20230523140643048](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230523140643048.png)



*  **连接层**

​          **最上层是一些客户端和链接服务**，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于TCP/IP的通信。

​         **主要完成一些类似于连接处理、授权认证、及相关的安全方案**。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。**服务器也会为安全接入的每个客户端验证它所具有的操作权限。**



*  **服务层**

​          第二层架构**主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。**

​           **所有跨存储引擎的功能也在这一层实现，如 过程、函数等**。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，**是否利用索引**等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。







*  **引擎层**

​          存储引擎层， **存储引擎真正的负责了MySQL中数据的存储和提取**，**服务器通过API和存储引擎进行通信。**

​          **不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎**。数据库中的索引是在存储引擎层实现的。



   **索引是在存储引擎层实现的，不同的存储引擎，索引存储结构是不一样的**

​    **innodb 存储引擎是 MySQL 5.5 之后的默认引擎**



*  **存储层**

​      **主要是将数据存储在文件系统之上，并完成与存储引擎的交互**

​        控制数据库中的数据该如何保存、如何取，如何组织，最终数据库中的数据时存储在磁盘当中的

​      数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交





## 1.2 存储引擎简介



​     **存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型**

  

>  ​     创建表时没有指定存储引擎，会赋予一个默认的存储引擎。
>
>  **innodb 存储引擎是 MySQL 5.5 之后的默认引擎**
>
>  ​      比如查看之前创建的表：
>
>  ```sql
>  show create table account;
>  ```
>
>  ```sql
>  CREATE TABLE `account` (
>    `id` int NOT NULL AUTO_INCREMENT COMMENT 'ID',
>    `name` varchar(10) DEFAULT NULL COMMENT '姓名',
>    `money` double(10,2) DEFAULT NULL COMMENT '余额',
>    PRIMARY KEY (`id`)
>  ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='账户表'
>  ```
>
>  

​     





*  **建表时指定存储引擎**

```sql
CREATE TABLE 表名(
字段1 字段1类型 [ COMMENT 字段1注释 ] ,
......
字段n 字段n类型 [COMMENT 字段n注释 ]
) ENGINE = INNODB [ COMMENT 表注释 ] ;
```





*  **查询当前数据库支持的存储引擎**

```sql
show engines;
```

   InnoDB 被标识 “DEFAULT”，说明是默认的

![image-20230523143203137](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230523143203137.png)



## 1.3  存储引擎特点



### 1.3.1 InnoDB

 #### 1.3.1.1 InnoDB 基本介绍



InnoDB是一种**兼顾高可靠性和高性能的通用存储引擎**，在 MySQL 5.5 之后，InnoDB是默认的MySQL 存储引擎。



**特点**

*  DML操作（增、删、改）遵循ACID模型（事务四大特性），**支持事务**
*  **行级锁**，提高并发访问性能；
*  支持**外键**FOREIGN KEY约束，保证数据的完整性和正确性；



**涉及磁盘文件**

*  **xxx.ibd**：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，**存储该表的表结构（frm-早期的 、sdi-新版的）、数据和索引。**

​           比如account表，存储引擎使用的是InnoDB，那account就会对应一个磁盘文件account.ibd

>  ​       **参数：innodb_file_per_table**
>
>  ​            此参数决定是多张表共享一个表空间文件还是每一个表对应于一个表空间文件
>
>  ​          **如果该参数开启，代表对于InnoDB引擎的表，每一张表都对应一个ibd文件**
>
>  ​           在MySQL8.0中是打开的
>
>  ```sql
>  innodb_file_per_table
>  ```
>
>  ![image-20230523144615344](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230523144615344.png)
>
>  ​      可以观察一下MySQL安装目录下的data目录，下面中的每一个目录都是一个数据库，随便点进去一个，比如“itcast”数据库
>
>  ![image-20230523144858938](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230523144858938.png)
>
>  ​    
>
>  ​    **每一个ibd文件就对应一张表**，在这个ibd文件中不仅存放表结构、数据，还会存放该表对应的索引信息
>
>  ​    而该文件是基于二进制存储的，不能直接基于记事本打开，我们可以使用mysql提供的一个**指令 ibd2sdi **，通过该指令就可以从ibd文件中提取sdi信息，而sdi数据字典信息中就包含该表的表结构
>
>  ​      比如 “  ibd2sdi account.ibd ”
>
>  
>
>  ![image-20230523144946160](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230523144946160.png)



#### 1.3.1.2 InnoDB 逻辑存储结构

*  **TableSpace**： 表空间

​           ibd文件属于表空间文件，在表空间中可以包含多个Segment段



*   **Segment**： 段

​           表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等

​            InnoDB中对于段的管理，都是引擎自身完成，不需要人为对其控制。
​             一个段中包含多个区。



*   **Extent**： 区

​             **区是表空间的单元结构，每个区的大小为1M。**

​             默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页



*    **Page**： 页

​                 我们存储的一行一行的内容

​                  页是组成区的最小单元，**页也是InnoDB存储引擎磁盘管理的最小单元**，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。



*    **Row**： 行

​       InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段(后面会详细介绍)。



![image-20230523150638909](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230523150638909.png)



### 1.3.2 MyISAM



​      MyISAM是MySQL早期的默认存储引擎



**特点**

*   不支持事务，不支持外键
*   支持表锁，不支持行锁
*   访问速度快



**文件**

*  xxx.sdi：存储表结构信息
*  xxx.MYD: 存储数据
*  xxx.MYI: 存储索引





### 1.3.3 Memory

​     Memory引擎的表数据时存储在内存中，由于受到硬件问题，或者断电影响，**只能将这些表作为临时表或缓存使用**。



 **特点**

*  内存存放，访问速度快
*  hash索引（默认）



**文件**

​       xxx.sdi： 存储表结构信息

  因为存放在内存当中，所以只需要一个文件即可





## 1.4 三种引擎特点及区别

![image-20230523164638566](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230523164638566.png)





*  **InnoDB引擎 和MyISAM引擎的区别？**

①. InnoDB引擎, 支持事务, 而MyISAM不支持。

②. InnoDB引擎, 支持行锁和表锁, 而MyISAM仅支持表锁, 不支持行锁。

③. InnoDB引擎, 支持外键, 而MyISAM是不支持的。





## 1.5 存储引擎选择



*  **InnoDB**

   ​     是Mysql的默认存储引擎，支持事务、外键。

   ​     如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。

   

*  **MyISAM**

​           如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，**并且对事务的完整性、并发性要求不是很高**，那么选择这个存储引擎是非常合适的。



*  **MEMORY**

​        **被当前比较流行的Redis替代了**

​          将所有数据保存在内存中，访问速度快，**通常用于临时表及缓存**。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。





# 二、 索引 - 重点

## 2.1 介绍

​     **索引**：是帮助MySQL高效获取数据的数据结构（有序）。

​     在数据之外，数据库系统还维护着满足特定查找算法的数据结构，**这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引**



>   **有无索引在查询的时候有什么区别？**
>
>  *  **无索引**
>
>  ​          如左侧所示，没有索引，如果我们想找到age=48的数据，只能从上往下一个一个比对
>
>  *  **有索引**
>
>  ​          如右图所示，将表中的数据形成一个最优二叉树，在下图中的数据中，只需要匹配3次就可以匹配到age=45的数据
>
>  ​          此二叉树并不是真实的索引结构，只是以二叉树为例做出演示
>
>  [数据结构与算法——赫夫曼树基本实现](https://blog.csdn.net/weixin_51351637/article/details/129941022)
>
>  ![image-20230523183533929](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230523183533929.png)



**优点**

*   提高数据检索效率，降低数据库IO成本 （**提高查询效率**）

*   通过索引列对数据进行排序，降低数据排序成本，抵消CPU消耗（**提高排序效率**）



**劣势**

*  索引列也是要占用空间的 （这个缺点也可以不考虑，因为磁盘比较便宜）
*   索引大大提高了查询效率，同时也降低更新表的速度，如对表进行insert、update、delete时，效率降低





## 2.2 索引结构

​    索引是在第三层存储引擎层实现的，也就是说根据存储引擎的不同，索引的数据结构也不相同



| **索引结构**        | **描述**                                                     |
| ------------------- | ------------------------------------------------------------ |
| **B+Tree 索引 **    | 最常见的索引类型，大部分引擎都支持 B+ 树索引                 |
| Hash 索引           | 底层数据结构是用哈希表实现的, **只有精确匹配索引列的查询才有效, 不支持范围查询** |
| R-tree(空间索引）   | 空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 |
| Full-text(全文索引) | 是一种通过建立倒排索引,快速匹配文档的方式。类似于Lucene,Solr,ES |



**我们平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引。**

| **索引**    | **InnoDB**      | **MyISAM** | **Memory** |
| ----------- | --------------- | ---------- | ---------- |
| B+tree索引  | 支持            | 支持       | 支持       |
| Hash 索引   | 不支持          | 不支持     | 支持       |
| R-tree 索引 | 不支持          | 支持       | 不支持     |
| Full-text   | 5.6版本之后支持 | 支持       | 不支持     |



### 2.3.1 B-Tree 多路平衡二叉树

 二叉树： 一个结点下面最多包含两个子节点

**资料**： [ 数据结构与算法——二叉树遍历、查找、删除、顺序存储二叉树、线索化二叉树](https://blog.csdn.net/weixin_51351637/article/details/129422343)



**二叉树缺点**： 

*  **顺序插入时，会形成一个链表，查询性能大大降低**

*  **大数据情况下，层级越深，检索速度越慢**



为了解决这两种情况，我们采取一下**措施**

*  **对于第一种情况将二叉树转变成红黑树**

​               红黑树是一个自平衡二叉树，但是仍存在层级越深，检索速度越慢的问题

![image-20230523195036558](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230523195036558.png)



*  **对于第二种情况我们使用 B-Tree 多路平衡二叉树**



​        以一颗最大度数（max-degree）为5（5阶）的B-Tree为例（每个结点最多存储4个Key，5个指针）

>   树的度数指的是一个结点的子结点个数。
>
>  ​      最大度数为5阶的含义为一个结点的子结点最多有五个

​     最上面的数据是（20,30,62,89），

   * * 小于20，走第一个指针
     * 20-30之间，走第二个指针
     * 30-62之间，走第三个指针
     * 62-89之间，走第四个指针
     * 89以上，走第五个指针

![image-20230523200106063](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230523200106063.png)



**下面进行演示：  依旧是五阶**

*  **首先插入四条数据（0023,0234,0345,0899）**

​                 此时正好是四个Key，五个指针

![image-20230523200658644](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230523200658644.png)

*  **再插入1200数据**

   ​      不能再往上面那个图添加了，如果添加之后变成了6阶，5个Key，6个指针了，所以**此时树会发生裂变—中间元素向上分裂**

​            如果1200插入进来后，0345会变成中间元素，会向上分裂

![image-20230523201647812](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230523201647812.png)

*  **再插入1234数据**

​        1234 > 0345，所以向右侧插入

![image-20230523201745027](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230523201745027.png)

*  **不断地插入数据**

![image-20230523201821555](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230523201821555.png)



*  **插入1000数据**

​        我们发现不能再继续往右下角插入了，已经慢了，所以仍然需要中间元素向上分裂，1000插入进来后，中间元素是1200，此时变成了

![image-20230523201948925](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230523201948925.png)



*  **不断插入**

![image-20230523202101139](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230523202101139.png)



*  **插入2456**

​      此时也不能向右下角插入，慢了，继续中间元素向上分裂，但是我们发现上面的元素也满了

![image-20230523202248916](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230523202248916.png)



### 2.3.2 B+Tree

​     **B+Tree是B-Tree的变种，我们以一颗最大度数（max-degree）为5（5阶）的b+tree为例(4个Key，5个指针)**



*  在B+Tree当中，**所有的元素都会出现在叶子结点**

​          非叶子结点主要起到索引的作用，而叶子结点是用来存放数据的，最终在非叶子结点中形成了一个单项列表

![image-20230523202621111](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230523202621111.png)



**演示**

*  **插入数据（0232 ，0234，0567,1000）**

![image-20230523203611987](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230523203611987.png)



*  **再存储 890元素**

​      此时再插入后显然不是5阶，所以要中间元素向上分裂（0567）

​      与刚刚不一样的是，0567不仅向上还存在，向下也存在，并且形成了一个单项链表

​       **所有的元素出现在叶子结点**

![image-20230523203823029](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230523203823029.png)



*  **插入数据1234**

​           向右下角插入

![image-20230523204040750](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230523204040750.png)

*  **插入2345**

​           此时不能往右下角插入了，需要分裂

![image-20230523204129902](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230523204129902.png)





**在MySQL中的B+Tree索引是什么样子的呢？**

   MySQL索引数据结构对经典的B+Tree进行了优化。

   在原来B+Tree的基础上，增加一个指向相邻结点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能

![image-20230523204847592](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230523204847592.png)



>   之前介绍过，叶在InnoDB当中默认是16K



### 2.3.3 Hash结构

**资料**：[ 数据结构——哈希表_](https://blog.csdn.net/weixin_51351637/article/details/129417607?ydreferer=aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTM1MTYzNy9jYXRlZ29yeV8xMjE0MTE4NS5odG1sP3NwbT0xMDAxLjIwMTQuMzAwMS41NDgy)

   **只有Memory存储引擎支持Hash结构，但是InnoDB引擎具有自适应Hash功能，Hash索引是存储引擎根据B+Tree在指定条件下自动构建的**

​    **哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中**



**比如**

​    首先算出每一条数据的Hash值，再通过数据库内部的哈希函数去计算每一个name的值，用这个值确定在落在哪一个哈希表的槽位上

  如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。

![image-20230523205816072](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230523205816072.png)







**特点**

*   Hash索引只能用于对等比较(=，in)，不支持范围查询（between，>，< ，...）
*  无法利用索引完成排序操作
*  查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引