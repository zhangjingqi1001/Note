# 视图/存储过程/触发器



# 一、视图

   **视图（View）是一种虚拟存在的表。**

   视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。



>   通俗的讲：视图是保存了查询的SQL，不保存查询结果。所以我们在创建视图的时候，主要工作就是创建这条SQL语句





## 1.1 语法



### 1.1.1 创建视图



​     如果我们想要**替换某个视图** 使用：OR REPLACE

​     CREATE  OR REPLACE ： 创建或替换一个视图

​     AS: 表示要封装的数据时什么样子的

​     视图是虚拟的，最终的数据来源于select语句

​     CASCADED | LOCAL ： 检查选项

​      **select语句中查询的表就是视图关联的基表（基本表）**



```sql
CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [CASCADED | LOCAL ] CHECK OPTION ]
```



**student表中有id,name,no三个字段，下面为id，name创建视图**

  我们封装的数据就是 as select返回的数据

```sql
create or replace view stu_v_1 as SELECT id,name from student where id<=10;
```

![image-20230526094924443](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230526094924443.png)





### 1.1.2 查询

*  **查看创建视图语句**

```sql
show create view 视图名称;
```



![image-20230526100304203](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230526100304203.png)



我们查看一下创建视图语句，发现有一些我们没有指定的默认参数

```sql
CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `stu_v_1` AS select `student`.`id` AS `id`,`student`.`name` AS `name` from `student` where (`student`.`id` <= 10)
```





*  **查看视图数据** 

```sql
select * from 视图名称...;
```

![image-20230526100507900](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230526100507900.png)



### 1.1.3 修改



*  **方式一**

   创建和修改都是这个语句，创建视图的时候OR REPLACE可以不添加，但是修改视图的时候要添加

```sql
CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [CASCADED | LOCAL ] CHECK OPTION ]
```



​     **为视图添加一个no字段**

```sql
create or replace view stu_v_1 as SELECT id,name,no from student where id<=10;
```

![image-20230526101833124](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230526101833124.png)



*  **方式二**

```sql
ALTER VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [ CASCADED |LOCAL ] CHECK OPTION ]
```



 **将视图恢复为id，name字段**

```sql
alter view stu_v_1 as  SELECT id,name from student where id<=10;
```

![image-20230526100507900](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230526100507900.png)



### 1.1.4 删除

```sql
DROP VIEW [IF EXISTS] 视图名称 [,视图名称] ...
```



```sql
drop view if exists stu_v_1;
```



### 1.1.5 对数据的操作

  对视图进行增加数据的操作，视图是虚拟的，真正的数据在数据库当中，我们要去student表中找（也就是基表）。我们点开视图看也能看到这两条数据

```sql
insert into stu_v_1 values(6,'Tom');
```



​      在插入这条数据，但是在视图中并没有找到。原因就是我们视图创建的where条件是age<20,Tom22的age是30，显然查询不到

```sql
insert into stu_v_1 values(30,'Tom22');
```

 

​    **为了避免从视图插入的数据但是视图中查询不到的情况，我们需要在常见视图的时候指定检查选项**





## 1.2 检查选项

​     刚刚在语法中出现了CASCADED、LOCAL，下面解释。

```sql
CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [CASCADED | LOCAL ] CHECK OPTION ]
```





>  ​     当使用WITH CHECK OPTION子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如 插入，更新，删除，以使其符合视图的定义（如果违背了条件，就不允许操作）。 
>
>  ​     MySQL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。
>
>  ​    **为了确定检查的范围，mysql提供了两个选项： CASCADED 和 LOCAL，默认值为 CASCADED。**





​    **首先创建视图**

​       这种场景下使用CASCADED 还是 LOCAL都可以

```sql
create or replace view stu_v_1 as select id,name from student where id<=20 WITH CASCADED CHECK OPTION;
```



**向视图中插入数据**

```sql
insert into stu_v_1 values(30,'Tom22');
```

 **阻止了这条数据的插入**

![image-20230526105146525](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230526105146525.png)





### 1.2.1 cascaded



*   **情况一**

​      定义视图v1，当我们向v1中插入的元素不符合id<20,也能进行插入

![image-20230526110023201](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230526110023201.png)



​    定义视图v2，基于v1创建的，并且指定了“with cascaded check option”,

​    所以当我们操作v2视图的时候，会先判断是否符合条件即是否符合id>=10

​    由于我们添加的是cascaded，所以还要去检查是否满足v1视图的条件，即是否满足id<=20

![image-20230526110120851](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230526110120851.png)



​     此时v2视图关联着v1，并且使用了cascaded，那默认v1也有cascaded，假如说v1此时关联着v4，那此时v4也需要验证条件，以此类推（如果此时v3，什么也没有，关联着v1，那此时v1也什么也没有）

![image-20230526110621818](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230526110621818.png)





*  **情况二**
   v3视图不会检查，v2,v1会进行检查

![image-20230526111207143](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230526111207143.png)







### 1.2.2 local

*  **情况一**

v2关联v1，此时v2会检查，但是v1不会检查

![image-20230526115009948](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230526115009948.png)







*  **情况二**

  v3不会检查，v2检查，v1不会检查

![image-20230526115049437](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230526115049437.png)



## 1.3 视图的更新

​      要使视图可更新，视图中的行与基础表中的行之间**必须存在一对一的关系**。

>   **视图当中的一行数据对应基础表中的一行数据才可以更新**
>
>     比如基础表当中的两条数据对应视图中的一条数据，此时不能更新





​      **如果视图包含以下任何一项，则该视图不可更新**



*  **聚合函数或窗口函数**

​             SUM()、MIN()、MAX()、COUNT()等

```sql
create view stu_v_count as SELECT count(*) from student;
```

![image-20230526213859903](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230526213859903.png)



​          我们插入一下试试

```sql
insert into stu_v_count value(10);
```

​         提示不可插入

![image-20230526214454966](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230526214454966.png)



**如果我们往student表中插入一条数据会不会变？**

```sql
insert into student values(5,'Tom',30) ;
```



**答案是会的！**



*  **DISTINCT**



*  **GROUP BY**



*  **HAVING**



*  **UNION 或 UNION ALL**





## 1.4 视图的作用

*  **简单**

​       视图不仅可以简化用户对数据的理解，也可以简化他们的操作。   

​       那些被经常使用的查询可以定义为视图，从而使得用户不必为以后的操作每次指定全部的条件



*   **安全**

​        数据库可以授权，但不能授权到数据库特定行和特定列上、

​        通过视图用户只能查询和修改他们所见到的数据。



*  **数据独立**

​         视图可以帮助用户屏蔽真实表结构变化带来的影响

​         比如说基表name字段修改为了username，那我们只需要修改一下视图就好了

 ```sql
 create or replace view 视图 as select ... , username as name, ...  with local check option
 ```





## 1.5 案例

### 1.5.1 案例1

​      为了保证数据库表的安全性，开发人员在操作tb_user表时，只能看到的用户的基本字段，屏蔽手机号和邮箱两个字段。



```sql
create view tb_user_view as select id,name,profession,age,gender,status,createtime from tb_user;
```







### 1.5.2 案例2

​       查询每个学生所选修的课程（三张表联查），这个功能在很多的业务中都有使用到，为了简化操作，定义一个视图

```sql
create view tb_stu_course_view 
as select s.name student_name , s.no student_no ,c.name course_name 
from student s, student_course sc , course c 
where s.id =sc.studentid and sc.courseid = c.id;
```









# 二、存储过程































