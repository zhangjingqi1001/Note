# SpringSecurity简介



# 一、基本概念

## 1.1 认证（Authentication）方式

**系统为什么要认证**？

认证是为了保护系统的隐私数据与资源，用户的身份合法方可访问该系统的资源



**什么是认证（登录）**？

用户认证就是判断一个用户的身份是否合法的过程



**常见的用户身份认证方式**

* 用户名密码登录
* 二维码登录
* 手机短信登录
* 指纹认证
* 人脸识别
* ......

## 1.2 会话(Session)介绍

> 下面这个文章中有对session的理解：[基于Session实现短信登录_c# 登录session怎么使用_我爱布朗熊的博客-CSDN博客](https://blog.csdn.net/weixin_51351637/article/details/127519489)
>
> [过滤器与拦截器 - 登录校验与登录认证（JWT令牌技术）_jwt过滤器_我爱布朗熊的博客-CSDN博客](https://blog.csdn.net/weixin_51351637/article/details/130720932)

用户认证通过后，为了避免用户的每次操作都进行认证可将用户的信息保存在会话中。

**会话**就是系统为了保持当前用户的登录状态所提供的机制

**常见的有基于session方式、基于token方式**等



* **基于session的认证方式**

  它的交互流程是，用户认证成功后，在服务端生成用户相关的数据保存在session(当前会话)中，发给客户端的sesssion_id 存放到 cookie 中，这样用户客户端请求时带上 session_id 就可以验证服务器端是否存在 session 数据，以此完成用户的合法校验，当用户退出系统或session过期销毁时,客户端的session_id也就无效了。

> 有一些用户在使用浏览器的时候会禁用Cookie，这会导致发一次请求，用户登录一次

* **基于token的认证方式**

  它的交互流程是，用户认证成功后，服务端生成一个token发给客户端，客户端可以放到 cookie 或 localStorage等存储中，每次请求时带上 token，服务端收到token通过验证后即可确认用户身份。可以使用Redis 存储用户信息（分布式中共享session）。

  

  基于session的认证方式由Servlet规范定制，服务端要存储session信息需要占用内存资源，客户端需要支持cookie；基于token的方式则一般不需要服务端存储token，并且不限制客户端的存储方式。如今移动互联网时代更多类型的客户端需要接入系统，系统多是采用前后端分离的架构进行实现，所以基于token的方式更适合。





## 1.3 授权(Authorization)介绍

**为什么要授权**（控制资源被访问）？

因为不同的用户可以访问的资源不一样



**什么是授权**（给用户颁发权限）？

授权是用户认证通过后，根据用户的权限来控制用户访问资源的过程

拥有资源的访问权限则正常访问，没有权限则拒绝访问







## 1.4 RBAC

**RBAC（Role-Based Access Control） 基于角色的访问控制**

![image-20230925222010168](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230925222010168.png)







**用户，角色，权限** 本质：就是把权限打包给角色（角色拥有一组权限），又将角色分配给用户（用户拥有多个角色）。

最少包括五张表 （用户表、角色表、用户角色表、权限表、角色权限表）







# 二、SpringSecurity入门

**声明式（注解）的安全访问控制解决方案的安全框架**

提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IoC，DI（控制反转Inversion of Control ,DI:Dependency Injection 依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作



## 2.1 快速入门

### 2.1.1 Maven坐标

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
    <version>2.4.2</version>
</dependency>
```



### 2.1.2 接口

```java
@RestController
@RequestMapping("/hello")
public class HelloController {

    @GetMapping("/hello")
    private String hello(){
        return "hello";
    }

}
```

访问上面的接口就会出现下面的页面（登录）

![image-20231007105125017](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20231007105125017.png)



默认的用户名是User，密码是在控制台上的UUID

![image-20231007105319945](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20231007105319945.png)



登录上后便可以访问接口。

之后不会使用这种方式



我们也可以**退出，访问IP:端口号/logout**

![image-20231007105829342](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20231007105829342.png)



### 2.1.3 源码

**为什么默认的用户名是user**？**并且密码是一串UUID**？

如下代码所示

![image-20231007111234007](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20231007111234007.png)



## 2.2  配置文件配置用户名和密码

在配置文件中配置如下信息

```yaml
spring:
  security:
    user:
      name: admin
      password: 123456
```

此时我们再使用默认的用户就不行了，而且控制台也不会输出UUID形式的密码了

![image-20231007110802830](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20231007110802830.png)

****

**Spring Security配置文件中默认配置用户是单一的用户，大部分系统都有多个用户，多个用户如何配置**？

可以使用基于内存的多用户管理







## 2.3 基于内存的多用户管理





