# 支付宝支付功能

官方文档地址：[支付宝开放平台 (alipay.com)](https://open.alipay.com/api/detail?code=I1080300001000041203)

[TOC]



# 一、统一收单下单并支付页面接口



> 文档网址：[统一收单下单并支付页面接口 - 支付宝文档中心 (alipay.com)](https://opendocs.alipay.com/open/028r8t?pathHash=8e24911d&scene=22&ref=api)
>
> 沙箱调用及事例：[支付宝开放平台 (alipay.com)](https://open.alipay.com/api/apiDebug?apiNames=alipay.trade.close&frontProdCode=I1080300001000041203&backProdCode=I1011000100000000005)
>
> ![image-20230917172925345](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917172925345.png)

## 1.1 参数简单说明

“公共请求参数”中的部分必选参数已经在“一、配置准备”进行准备了

有一些必选参数，比如说“sign 签名”字段，是在AlipayConfig对象向支付宝发起调用之前，“签名”这个参数就会被自动生成，不用我们去手动设置

> 有一些比较重要的可选参数“return_url”、“notify_url”后面也会使用到

另外一个比较重要的“公共请求参数”是“**biz_content 请求参数的集合字段**”

![image-20230917131828867](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917131828867.png)



在“公共请求参数”中，有一个字段“**biz_content**”，表示**请求参数的集合，“请求参数”指的便是下图中的请求参数**。

简单的来讲就是**业务的具体参数**了，这些参数需要我们在编程时进行填写

![image-20230917131957312](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917131957312.png)

也有**公共响应参数**

![image-20230917134733858](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917134733858.png)

**响应参数**

![image-20230917134821060](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917134821060.png)

**响应实例**

响应内容的是一个表单，表单中还包含一个自动提交的脚本“document.forms[0].submit();”，会自动把form表单提交到action所指定的地址中。

> action地址也是支付宝开发平台提供的地址

最终展示的支付宝的支付登录页面就是提交到action地址之后产生的一种结果。

> 实际上我们需要在我们的商户页面中添加一个系统接口，这个接口需要前端页面调用，这个接口再调用统一下单并支付页面接口，调用后支付宝会给我们的系统返回一个form表单（如下所示的form表单，以字符串的形式返回）
>
> 然后我们商城的后台系统会将此字符串返回给前端，前端便可以直接执行表单的提交“document.forms[0].submit();”，这个提交后相当于前端直接提交给支付宝开放平台，并没有经过商城后端，此时支付宝开放平台就会给用户展示一个支付页面
>
> 这个支付页面有两个选项，一个是支付二维码，一个是支付宝账号登录

![image-20230917135737298](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917135737298.png)

### 1.1.1 总结

* **所有接口的“公共参数”都是相同的，“请求参数”是各不一样的**

* **某些“公共参数”是在AlipayClient配置对象中添加的，“可选参数”在需要时添加即可**

* **实际上”请求参数“是“公共参数”中的“biz_content”字段，而且此字段应该是一个JSON类型的字符串**

```java
JSONObject bizContent = new JSONObject();
//商户订单号，商家自定义，保持唯一性
bizContent.put("out_trade_no", "20210817010101004");
//支付金额，最小值0.01元
bizContent.put("total_amount", 0.01);
//订单标题，不可使用特殊符号
bizContent.put("subject", "测试商品");
//电脑网站支付场景固定传值FAST_INSTANT_TRADE_PAY
bizContent.put("product_code", "FAST_INSTANT_TRADE_PAY");
request.setBizContent(bizContent.toString());
```

**或者说不使用上面JSON对象的形式，直接使用下面这种形式**

```java
AlipayTradePagePayRequest request = new AlipayTradePagePayRequest();

          AlipayTradePagePayModel model = new AlipayTradePagePayModel();
          model.setOutTradeNo("20150320010101001");
          model.setTotalAmount("88.88");
          model.setSubject("Iphone6 16G");
          model.setProductCode("FAST_INSTANT_TRADE_PAY");

request.setBizModel(model);
```

## 1.2  具体实现

**我们根据官方提供的时序图编写即可**

### 1.2.1 Controller层

```java
@Slf4j
@CrossOrigin//跨域
@RestController
@RequestMapping("/api/ali-pay")
@Api(tags = "网站支付宝支付")
public class AliPayController {

    @Resource
    private AliPayService aliPayService;
    
    //  传入商品的id进行下单
    @PostMapping("/trade/page/pay/{productId}")
    @ApiOperation("统一收单下单并支付接口")
    public R tradePagePay(@PathVariable("productId") Long productId) {
        log.info("统一收单下单并支付接口");
//      支付宝开放平台接受Request请求对象后，会生成一个html形式的from表单，包含自动提交的脚本
        String formStr = aliPayService.tradeCreate(productId);

        return R.ok().data("formStr",formStr);
    }
}
```

### 1.2.2 Service

```java
    @Transactional
    @Override
    public String tradeCreate(Long productId) {
        AlipayTradePagePayResponse response = null;
        try {
//          1.生成订单
            OrderInfo orderInfo = orderInfoService.createOrderByProductId(productId);
//          2.调用支付宝接口
//          请求的支付宝开放平台的接口名alipay.trade.page.pay，所以对象叫做AlipayTradePagePayRequest
            AlipayTradePagePayRequest request = new AlipayTradePagePayRequest();
//          异步接收地址，仅支持http/https，公网可访问
//          request.setNotifyUrl("");
//          同步跳转地址，仅支持http/https
//          request.setReturnUrl("");

            /******必传参数******/
            JSONObject bizContent = new JSONObject();
//          商户订单号，商家自定义，保持唯一性，64个字符以内，仅支持字母、数字、下划线且需保证在商户端不重复
            bizContent.put("out_trade_no", orderInfo.getOrderNo());

//          订单总金额，最小值0.01元，取值范围为 [0.01,100000000]。金额不能为0
            BigDecimal totalFee = new BigDecimal(orderInfo.getTotalFee().toString()).divide(new BigDecimal(100));
            bizContent.put("total_amount", totalFee);

//          订单标题，不可使用特殊符号，如 /，=，& 等
            bizContent.put("subject", orderInfo.getTitle());

//          电脑网站支付场景固定传值FAST_INSTANT_TRADE_PAY
            bizContent.put("product_code", "FAST_INSTANT_TRADE_PAY");

//          此时是完整的Request对象
            request.setBizContent(bizContent.toString());

//          响应结果的名字
            response = alipayClient.pageExecute(request);

            if (response.isSuccess()) {
                log.info("调用成功 - "+response);
                log.info(response.getBody());
            } else {
                log.info("调用失败 - "+response);
                log.info("返回描述 - "+response.getMsg());
                log.info("返回状态码 - "+response.getCode());
                throw  new RuntimeException("创建支付交易失败");
            }
        } catch (AlipayApiException e) {
            e.printStackTrace();
            throw  new RuntimeException("创建支付交易失败");
        }

        return response.getBody();
    }
```

### 1.2.3 展示

![image-20230917162626141](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917162626141.png)



**账号登录支付**

![image-20230917163335161](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917163335161.png)

![image-20230917163357845](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917163357845.png)

![image-20230917163413145](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917163413145.png)



**支付宝扫码支付**

使用沙箱版支付宝扫码即可

![image-20230917162649551](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917162649551.png)

支付成功后便是下面这个样子

![image-20230917163109747](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917163109747.png)

但是我们希望支付成功后是我们的商城页面，而不是下面这个页面，下面来更改一下，如3.1.3所示

## 1.3 支付成功 - 同步跳转回商户页面（return_url参数）

在支付宝的文档中，有如下两个字段

![image-20230917163750691](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917163750691.png)

现在主要看**return_url参数**，指定支付完成后跳转到哪个页面

```java
AlipayTradePagePayRequest request = new AlipayTradePagePayRequest();

//同步跳转地址，仅支持http/https
request.setReturnUrl(config.getProperty("alipay.return-url"));//http://localhost:8080/#/success
```



当我们支付成功后，如下图所示

![image-20230917164617262](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917164617262.png)

**很成功的跳转到了下图页面**

![image-20230917164637723](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917164637723.png)



# 二、支付成功异步通知

## 2.0 补充说明ngrok

> 官方网站：https://ngrok.com/
>
> 注册并登录

在官网下载后解压

![image-20230917180955086](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917180955086.png)

**命令行输入**

```sh
ngrok authtoken 你自己的token
```

token在这个地方复制即可

![image-20230917181644044](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917181644044.png)

启动ngrok,我们希望内网穿透到我们服务的8090端口

```sh
ngrok http 8090
```

“connecting”表示正在连接的状态

![image-20230917182056400](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917182056400.png)

“online”表示在线，已经连接成功

![image-20230917182147015](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917182147015.png)

我们可以看到内网穿透的地址有两个，一个是http，另一个是https

```properties
# 服务器异步通知页面路径  需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问
# 注意：每次重新启动ngrok，都需要根据实际情况修改这个配置
alipay.notify-url=https://a90b-101-27-21-172.ngrok-free.app/api/ali-pay/trade/notify
```





## 2.1 流程说明



当我们支付成功后，下面的订单状态要修改为“支付成功”

![image-20230917174524169](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917174524169.png)

**但是我们怎么知道支付宝端已经完成支付了呢**？

当我们支付成功后，支付宝会根据returnUrl帮我跳转到支付成功的页面

![image-20230917174734349](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917174734349.png)





与此同时，支付宝端还会向我们的客户端发起一个异步通知参数

如时序图中的7

所以我们就需要在商户系统当中开发一个接口，等待支付宝端成功支付之后向我们的商户系统发起调用（此时就需要用到内网穿透，可以让支付宝能够调用到我们系统中的异步请求接口）

![image-20230917175008390](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917175008390.png)





> 内网穿透知识点：[微信支付-基础支付APIv3-支付通知-内网穿透_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1US4y1D77m?p=48&vd_source=c01240addcba226237f3c4781490fbae)

## 2.2 异步结果通知

需要在之前Service层的tradeCreate设置异步通知地址

```java
            AlipayTradePagePayRequest request = new AlipayTradePagePayRequest();
//          异步接收地址，仅支持http/https，公网可访问
            request.setNotifyUrl(config.getProperty("alipay.notify-url"));
```



> 官网[异步通知说明 - 支付宝文档中心 (alipay.com)](https://opendocs.alipay.com/open/270/105902?pathHash=d5cd617e&ref=api)
>
> ![image-20230917211245733](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917211245733.png)

### 2.2.1 通知参数及通知结果

**分为“公共参数”和“业务参数”**

在“公共参数”中，notify_type字段一般是trade_status_sync，是不变的

![image-20230917212338970](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917212338970.png)

而且**异步通知是带有签名sign的，所以我们需要验签**，当签名校验成功了，才可以正确的接收通知并做之后的业务处理

如果签名验证不成功，说明是非法的

![image-20230917212451723](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917212451723.png)

**在“业务参数”中，有个字段为trade_no**,是支付宝交易号。在支付宝端，支付宝会对每一笔交易生成一个支付宝交易号（**支付宝端唯一交易编号**）

![image-20230917212704354](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917212704354.png)

**商家订单号**，之前在发送支付请求时我们自己生成的商家订单号，在异步通知中又给我们返回回来了，便于我们在回调通知当中去查找当时的订单数据

![image-20230917212852695](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917212852695.png)



我们可以看一下**通知的触发条件**：

当trade_status字段是TRADE_SUCCESS时，会触发异步通知

![image-20230917221319800](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917221319800.png)

**下面这个第一条挺重要的，返回结果要是“success”**

![image-20230917222525470](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917222525470.png)

```java
/**
 * @param params 将支付宝的请求参数转换成Map集合
 */
@PostMapping("/trade/notify")//注意要和配置文件中alipay.notify-url一致
public String tradeNotify(@RequestParam Map<String, String> params) {
    ....
    //向支付宝返回的成功的结果
    return "success";
}
```



> 其他详细信息官方文档可看：[异步通知说明 - 支付宝文档中心 (alipay.com)](https://opendocs.alipay.com/open/270/105902?pathHash=d5cd617e&ref=api)



### 2.2.2 异步返回结果验签

> [异步通知说明 - 支付宝文档中心 (alipay.com)](https://opendocs.alipay.com/open/270/105902?pathHash=d5cd617e&ref=api)

我们引入的支付宝的SDK，所以我们可以使用比较方便的形式进行验签

```java
        //异步通知的验签
        boolean signVerified = AlipaySignature.rsaCheckV1(params,
//              支付宝公钥
                config.getProperty("alipay.alipay-public-key"),
//              编码方式
                AlipayConstants.CHARSET_UTF8,
//               签名类型
                AlipayConstants.SIGN_TYPE_RSA2); //调用SDK验证签名
        if (!signVerified) {
            // TODO 验签失败则记录异常日志，并在response中返回failure.
            log.error("支付成功 - 异步通知验签失败");
            return "failure";
        }
        log.info("支付成功 - 异步验签通知成功");
            // TODO 验签成功后，按照支付结果异步通知中的描述，对支付结果中的业务内容进行二次校验，校验成功后在response中返回success并继续商户自身业务处理，校验失败返回failure
```

**上面的操作相当于下图中的前四步**

![image-20230917233437468](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917233437468.png)

### 2.2.3 业务内容二次校验

> **异步通知验签之后就要做业务内容的二次校验**
>
> 下面要完成的就是第五步
>
> ![image-20230917233618777](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917233618777.png)



```java
//      TODO 2.业务内容二次校验
//      2.1 商家需要验证该通知数据中的 out_trade_no 是否为商家系统中创建的订单号。
//      将此订单去数据库中查询，如果查询到是存在的，那就是我们商户系统中的订单；如果查询不到的话，说明不是我们商户系统中的订单
        String outTradeNo = params.get("out_trade_no");
        OrderInfo order = orderInfoService.getOrderByOrderNo(outTradeNo);
        if (order == null) {
            log.info("订单不存在");
            return result;//failure
        }
//      2.2 判断 total_amount 是否确实为该订单的实际金额（即商家订单创建时的金额）
//      这个地方注意，商户系统中是以分为单位，但是支付宝中是以元为单位
        String totalAmount = params.get("total_amount");
//      将支付宝给我们的金额乘100转换成分，与商户系统中的金额进行对比
        int totalAmountInt = new BigDecimal(totalAmount).multiply(new BigDecimal("100")).intValue();//乘100
        int totalFeeInt = order.getTotalFee();
        if (totalAmountInt != totalFeeInt) {
            log.error("金额校验失败");
            return result;//failure
        }
//      2.3 校验通知中的 seller_id（或者 seller_email) 是否为 out_trade_no 这笔单据的对应的操作方（有的时候，一个商家可能有多个 seller_id/seller_email）
//      这个地方不一致的话，说明你付给别人了
        String sellerId = params.get("seller_id");//商户PID，我们的是2088721011169741
        String sellerIdProperty = config.getProperty("alipay.seller-id");
        if (!sellerId.equals(sellerIdProperty)) {
            log.error("商家PID校验失败");
            return result;//failure
        }
//      2.4 验证 app_id 是否为该商家本身
        String appId = params.get("app_id");
        String appIdProperty = config.getProperty("alipay.app-id");
        if (!appId.equals(appIdProperty)) {
            log.error("AppID校验失败");
            return result;//failure
        }
//      2.5在支付宝的业务通知中，只有交易通知状态为 TRADE_SUCCESS 或 TRADE_FINISHED 时，支付宝才会认定为买家付款成功
//      在这个地方我们只判断TRADE_SUCCESS即可，因为TRADE_FINISHED是不能退款的，但是我们以后是可以退款的
        String tradeStatus = params.get("trade_status");
        if (!"TRADE_SUCCESS".equals(tradeStatus)) {
            log.error("支付未成功");
            return result;//failure
        }
```

### 2.2.4 处理订单业务

![image-20230918225106994](C:\Users\jd\AppData\Roaming\Typora\typora-user-images\image-20230918225106994.png)

**Controller层**

```java
//      TODO 3.处理业务、修改订单状态、记录支付日志
//      校验成功后在response中返回success并继续商户自身业务处理，校验失败返回failure
        aliPayService.processOrder(params);//将所有的回调参数传入
```



**调用的Service层AliPayServiceImpl**

```java
    /**
     * 处理订单
     * @param params
     */
    @Override
    public void processOrder(Map<String, String> params) {
        log.info("处理订单");
//      获取订单号
        String orderNo = params.get("out_trade_no");
//      更新订单状态
        orderInfoService.updateStatusByOrderNo(orderNo, OrderStatus.SUCCESS);//OrderStatus.SUCCESS 支付成功
//      记录支付日志
        paymentInfoService.createPaymentInfoForAliPay(params);
        
    }
```

**调用的Service层PaymentInfoServiceImpl**

```java
    /**
     * 记录支付宝支付日志
     */
    @Transactional
    @Override
    public void createPaymentInfoForAliPay(Map<String, String> params) {
        log.info("记录支付日志");
//      获取订单号
        String orderNo = params.get("out_trade_no");
//      支付系统交易编号(支付宝交易凭证号)
        String transactionId = params.get("trade_no");
//      交易状态
        String tradeStatus = params.get("trade_status");
//      交易总金额
        String totalAmount = params.get("total_amount");
        int totalAmountInt = new BigDecimal(totalAmount).multiply(new BigDecimal("100")).intValue();

        PaymentInfo paymentInfo = new PaymentInfo();
        paymentInfo.setOrderNo(orderNo);
        paymentInfo.setPaymentType(PayType.ALIPAY.getType());
        paymentInfo.setTransactionId(transactionId);
        paymentInfo.setTradeType("电脑网站支付");
        paymentInfo.setTradeState(tradeStatus);
        paymentInfo.setPayerTotal(totalAmountInt);

        String paymentInfoJSON = JSONObject.toJSONString(params);
        paymentInfo.setContent(paymentInfoJSON);//通知参数
//      插入数据库
        baseMapper.insert(paymentInfo);
    }
```

### 2.2.5 处理重复通知

> [异步通知说明 - 支付宝文档中心 (alipay.com)](https://opendocs.alipay.com/open/270/105902?pathHash=d5cd617e&ref=api)

![image-20230918225130102](C:\Users\jd\AppData\Roaming\Typora\typora-user-images\image-20230918225130102.png)

**为什么要过滤重复的通知结果数据呢**？

如下原因。支付宝会给商户系统发送通知，而我们的商户系统会给我们的支付宝端返回一个“success”，如果4分钟内支付宝端没有收到“success”，支付宝就会间隔10分钟再次通知

假设我们的商户系统在给支付宝发送了“success”时由于网络等其他原因并没有成功返回给支付宝，那么支付宝就会重复向商户系统发送通知

支付宝又发送通知后，我们的数据库的支付记录就会记录一笔账单两或多次（相当于我们支付了一次，但是数据库中至少有1条），我们的支付状态也会修改第二次（支付状态的修改对程序不会造成影响）

![image-20230918230243886](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230918230243886.png)





```java
    /**
     * 处理订单
     * @param params
     */
    @Override
    public void processOrder(Map<String, String> params) {
        log.info("处理订单");
//      获取订单号
        String orderNo = params.get("out_trade_no");

//      TODO 处理重复通知
//      接口调用的幂等性：无论接口被调用多少次，以下业务执行一次
        String orderStatus = orderInfoService.getOrderStatus(orderNo);
        if (!OrderStatus.NOTPAY.getType().equals(orderStatus)){
//          只要不是未支付，就执行下面这个地方
            return;
        }
//      更新订单状态
        orderInfoService.updateStatusByOrderNo(orderNo, OrderStatus.SUCCESS);//OrderStatus.SUCCESS 支付成功
//      记录支付日志
        paymentInfoService.createPaymentInfoForAliPay(params);

    }
```

新增的代码如下图所示

```java
//      TODO 处理重复通知
//      接口调用的幂等性：无论接口被调用多少次，以下业务执行一次
        String orderStatus = orderInfoService.getOrderStatus(orderNo);
        if (!OrderStatus.NOTPAY.getType().equals(orderStatus)){
//          只要不是未支付，就执行下面这个地方
            return;
        }
```



### 2.2.6 数据锁

我们在2.2.4编写的业务逻辑存在线程并发安全问题，所以我们可以加一把锁

```java
private  final ReentrantLock lock = new ReentrantLock();
```

> **ReentrantLock**是Java中的一个**可重入锁类**，用于**实现线程同步和互斥**
>
> ReentrantLock是Java提供的一种**高级锁机制**，它支持可重入特性，即同一个线程可以多次获得该锁而不会造成死锁。
>
> 在多线程环境中，ReentrantLock可用于保护临界区，防止多个线程同时访问共享资源或共享数据的代码段。
>
> 通过使用`lock()`方法获取锁并在代码块执行完毕后使用`unlock()`方法释放锁，可以确保只有一个线程在任意时刻能够进入被保护的临界区
>
> 一般而言，`ReentrantLock`比传统的`synchronized`关键字提供了更多的灵活性和功能，例如可中断的锁、公平性选择、条件变量等。但在使用时需要格外小心，确保正确处理锁的获取和释放，避免死锁和资源争用的问题



```java
    /**
     * 处理订单
     *
     * @param params
     */
    @Override
    public void processOrder(Map<String, String> params) {
        log.info("处理订单");
//      获取订单号
        String orderNo = params.get("out_trade_no");
//      尝试获取锁：成功获取则立即返回true，获取失败则立即返回false，不必一直等待锁的释放
        if (lock.tryLock()) {
            try {
//              处理重复通知
//              接口调用的幂等性：无论接口被调用多少次，以下业务执行一次
                String orderStatus = orderInfoService.getOrderStatus(orderNo);
                if (!OrderStatus.NOTPAY.getType().equals(orderStatus)) {
//                  只要不是未支付，就执行下面这个地方
                    return;
                }
//              更新订单状态
                orderInfoService.updateStatusByOrderNo(orderNo, OrderStatus.SUCCESS);//OrderStatus.SUCCESS 支付成功
//              记录支付日志
                paymentInfoService.createPaymentInfoForAliPay(params);
            } finally {
                lock.unlock();
            }
        }
    }
```



#### Controller

下面接口中的params参数，就是异步通知参数

```java
/**
 * @param params 将支付宝的请求参数转换成Map集合
 * @return
 */
@ApiOperation("支付通知")
@PostMapping("/trade/notify")//注意要和配置文件中alipay.notify-url一致
public String tradeNotify(@RequestParam Map<String, String> params) {
    log.info("支付通知");
    log.info("通知参数 - "+params);
    return "";
}
```

####  Service

















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































