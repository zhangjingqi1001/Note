# 支付宝支付

# 一、配置准备

## 1.1 properties配置文件

```properties
# 支付宝支付相关参数

# 应用ID,您的APPID，收款账号既是您的APPID对应支付宝账号
alipay.app-id=你的APPID

# 商户PID,卖家支付宝账号ID
alipay.seller-id=你的商户ID

# 支付宝网关
alipay.gateway-url=https://openapi-sandbox.dl.alipaydev.com/gateway.do


# 商户私钥，您的PKCS8格式RSA2私钥
alipay.merchant-private-key= 你的私钥
# 支付宝公钥,查看地址：https://openhome.alipay.com/platform/keyManage.htm 对应APPID下的支付宝公钥
alipay.alipay-public-key= 支付宝公钥
# 接口内容加密秘钥，对称秘钥
alipay.content-key= 生成的秘钥

# 页面跳转同步通知页面路径
alipay.return-url=http://localhost:8080/#/success

# 服务器异步通知页面路径  需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问
# 注意：每次重新启动ngrok，都需要根据实际情况修改这个配置
alipay.notify-url=https://a863-180-174-204-169.ngrok.io/api/ali-pay/trade/notify

```

将上面的properties文件变成springboot的标准配置文件（我这里已经添加过了，我再重新写一遍）



![](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230906235121302.png)

![image-20230906235313497](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230906235313497.png)

然后从这里选择配置文件即可，但是我已经添加过了，所以显示没有

![image-20230906235332428](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230906235332428.png)







## 1.2 读取参数

配置类

```java
@Configuration
@PropertySource("classpath:alipay-sandbox.properties")
public class AliPayClientConfig {

}
```

读取参数

```java
@Resource
private Environment config;

@Test
void getAliProperties(){
    log.info(config.getProperty("alipay.app-id"));
}
```



## 1.3 客户端对象

此客户端对象封装了签名和验签功能

https://opendocs.alipay.com/open/01bxlm?pathHash=1cc7d70b

有两个版本，Easy版本实现起来更加的方便简洁，但是Easy版并没有覆盖所有的Alipay的功能

所以我们选择通用版

![image-20230907204202898](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230907204202898.png)

点击下面的“Maven项目依赖”

![image-20230907204515249](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230907204515249.png)

在这里复制依赖粘贴到项目中

![image-20230907204743507](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230907204743507.png)

```xml
<!--ali支付宝的SDK-->
<dependency>
    <groupId>com.alipay.sdk</groupId>
    <artifactId>alipay-sdk-java</artifactId>
    <version>4.38.72.ALL</version>
</dependency>
```

之后我们要创建一个远程连接的终端对象，我们要用这个对象调用ali提供的支付相关的接口

> 我们希望这个对象能够帮我们封装签名和验签
>
> https://opendocs.alipay.com/common/02kf5q

**公钥方式**

公钥方式是指开发者将APPID、应用私钥 (private key)、支付宝公钥(alipay public key) 配在代码中对请求内容进行签名，并对支付宝返回的内容进行验签的方法。

**开放平台SDK封装了签名实现**，只需在**创建 DefaultAlipayClent 对象**时，设置请求网关(gateway)、应用id (app_id)、应用私钥 (private_key)、编码格式 (charset)、支付宝公 (alipay_public .key) 、签名类型(sign_type)即可，**报文请求时会自动进行签名**。

![image-20230907210319321](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230907210319321.png)



```java
AlipayConfig alipayConfig = new AlipayConfig();
//设置网关地址
alipayConfig.setServerUrl(URL);
//设置应用APPID
alipayConfig.setAppId(APPID);
//设置应用私钥
alipayConfig.setPrivateKey(PRIVATE_KEY);
//设置请求格式，固定值json
alipayConfig.setFormat("json");
//设置字符集
alipayConfig.setCharset(CHARSET);
//设置支付宝公钥
alipayConfig.setAlipayPublicKey(ALIPAY_PUBLIC_KEY);
//设置签名类型
alipayConfig.setSignType(SIGN_TYPE);

//构造client
AlipayClient alipayClient = new DefaultAlipayClient(alipayConfig);
```

如下所示：

```java
@Configuration
@PropertySource("classpath:alipay-sandbox.properties")
public class AliPayClientConfig {
    @Resource
    private Environment config;

    @Bean
    public AlipayClient alipayClient() throws AlipayApiException {
        AlipayConfig alipayConfig = new AlipayConfig();
//      设置网关地址
        alipayConfig.setServerUrl(config.getProperty("alipay.gateway-url"));
//      设置应用APPID
        alipayConfig.setAppId(config.getProperty("alipay.app-id"));
//      设置应用私钥
        alipayConfig.setPrivateKey(config.getProperty("alipay.merchant-private-key"));
//      设置请求格式，固定值json
        alipayConfig.setFormat(AlipayConstants.FORMAT_JSON);
//      设置字符集
        alipayConfig.setCharset(AlipayConstants.CHARSET_UTF8);
//      设置支付宝公钥
        alipayConfig.setAlipayPublicKey(config.getProperty("alipay.alipay-public-key"));
//       设置签名类型
        alipayConfig.setSignType(AlipayConstants.SIGN_TYPE_RSA2);
//      构造client
        AlipayClient alipayClient = new DefaultAlipayClient(alipayConfig);
        return alipayClient;
    }
}
```



# 二、API了解

文档地址：https://opendocs.alipay.com/open/028r8t?pathHash=8e24911d&scene=22&ref=api

## 2.1 API预览

**统一收单下单并支付页面接口**：会显示一个支付二维码，用户扫描便可以支付

**统一收单线下交易查询接口**：支付完成后需要查询一下订单的状态，便是此接口。商户可以通过该接口主动查询订单状态，完成下一步的业务逻辑

> 当商户后台、网络、服务器等出现异常，商户系统最终未接收到支付通知； 
>
> 调用支付接口后，返回系统错误或未知交易状态情况； 调用alipay.trade.pay，返回INPROCESS的状态；
>
>  调用alipay.trade.cancel之前，需确认支付状态

**统一收单交易退款接口**：支付成功后需要退款时所要调用的接口

**统一收单交易退款查询**：退款完成时需要查询一下退款的状态

**收单退款冲退完成通知**：完成退款接口调用的时候，一个异步通知的接口

**统一收单交易关闭接口**：关闭订单，比如说超时关单或者管理员主动关单

**查询对账单下载地址**：对账接口，获取账单下载地址，下载账单



**支付成功通知**：如下图所示。支付成功通知或者是支付状态通知，就需要参考下面这个文档

![image-20230907225940460](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230907225940460.png)





## 2.2 签名验签

我们看一下这个支付宝开放平台开发助手

![image-20230907230320178](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230907230320178.png)

点击之后，如下面所示

![image-20230907230429491](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230907230429491.png)

再点击，会有下面的详细介绍

![image-20230907230453423](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230907230453423.png)





## 2.3 支付调用流程

**官网时序图如下图所示**

![image-20230907230806031](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230907230806031.png)

该时序图设计三个方面：用户、商户系统（也就是我们的网站）、支付宝支付平台

1. **用户首先向商户系统发送一个交易请求**，此交易请求相当于下订单了

2. 商户系统调用alipay.trade.page.pay（下单接口），向支付宝平台发起支付请求，**支付宝向用户展示支付二维码和支付宝的登录窗口**

   用户此时有**两种方式选择支付**：

   **一种**是手机支付宝选择扫描支付二维码，进行正常的支付流程，之后用户确认支付即可；

   **另一种**方式是用户选择支付宝的登录界面，输入用户名和支付密码进行登录，登录之后会把页面切换成一个支付页面，用户选择支付渠道并输入支付密码后，确认支付即可。

3. **支付宝再用户确认支付之后会对用户输入的指纹或密码进行确认，进行一个支付校验**

![image-20230917103253480](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917103253480.png)

4. **如果支付校验成功了，商户系统的浏览器会跳转到支付成功的页面**

支付宝怎么知道要跳转到商户平台的哪个页面呢？

在时序图1.1发起支付请求时，我们会把“商户支付成功页面”以returnUrl的形式转递给支付宝。就是说如果用户支付成功了，你就帮我跳转到returnUrl这个地址

![image-20230917103505964](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917103505964.png)

> 这个只是用户可以在商户系统中看到“支付成功”的页面，但是商户系统本身也要对订单进行处理

5. **商户系统也要接收到支付成功的通知**

这个”通知“就是我们在商户系统中提前开发的接口，此接口叫”回调接口“。

为什么叫**回调接口**？

因为支付成功后，支付宝那边确认支付成功后，会在支付宝端主动的向我们的商户系统发起调用的一个接口（此接口商户系统开发，支付宝调用）

我们在接口的执行流程当中会修改商户系统中的订单状态，将订单由未支付，改成已支付，这一次支付便完成了

![image-20230917104245635](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917104245635.png)

6. **有可能由于网络的原因，时序图中的7步骤中商户系统自己编写的接口不能被支付宝成功调用或者说支付宝没有成功调用商户系统中的接口时，商户系统就不能处理订单了，也没有办法把订单的状态由未支付改成已支付，怎么办**？

此时我们的商户系统会向支付宝主动发起一个查看交易状态的请求，我们自己查询一下订单是否支付成功了，如果支付成功了，支付宝就会将订单的交易信息进行返回，商户系统收到后就会修改订单的状态

![image-20230917104959315](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917104959315.png)

> 这种情况下，我们不开发回调接口，直接查询支付宝的订单状态也是可以的
>
> 两种都使用也是可以的，双重保障



> 此流程图在https://opendocs.alipay.com/open/270/105899?pathHash=d57664bf&ref=api
>
> ![image-20230907230847640](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230907230847640.png)



# 三、支付功能

官方文档地址：[支付宝开放平台 (alipay.com)](https://open.alipay.com/api/detail?code=I1080300001000041203)





## 3.1 统一收单下单并支付页面接口

> 文档网址：[统一收单下单并支付页面接口 - 支付宝文档中心 (alipay.com)](https://opendocs.alipay.com/open/028r8t?pathHash=8e24911d&scene=22&ref=api)
>
> 沙箱调用及事例：[支付宝开放平台 (alipay.com)](https://open.alipay.com/api/apiDebug?apiNames=alipay.trade.close&frontProdCode=I1080300001000041203&backProdCode=I1011000100000000005)
>
> ![image-20230917172925345](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917172925345.png)

### 3.1.1 参数简单说明

“公共请求参数”中的部分必选参数已经在“一、配置准备”进行准备了

有一些必选参数，比如说“sign 签名”字段，是在AlipayConfig对象向支付宝发起调用之前，“签名”这个参数就会被自动生成，不用我们去手动设置

> 有一些比较重要的可选参数“return_url”、“notify_url”后面也会使用到

另外一个比较重要的“公共请求参数”是“**biz_content 请求参数的集合字段**”

![image-20230917131828867](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917131828867.png)



在“公共请求参数”中，有一个字段“**biz_content**”，表示**请求参数的集合，“请求参数”指的便是下图中的请求参数**。

简单的来讲就是**业务的具体参数**了，这些参数需要我们在编程时进行填写

![image-20230917131957312](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917131957312.png)

也有**公共响应参数**

![image-20230917134733858](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917134733858.png)

**响应参数**

![image-20230917134821060](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917134821060.png)

**响应实例**

响应内容的是一个表单，表单中还包含一个自动提交的脚本“document.forms[0].submit();”，会自动把form表单提交到action所指定的地址中。

> action地址也是支付宝开发平台提供的地址

最终展示的支付宝的支付登录页面就是提交到action地址之后产生的一种结果。

> 实际上我们需要在我们的商户页面中添加一个系统接口，这个接口需要前端页面调用，这个接口再调用统一下单并支付页面接口，调用后支付宝会给我们的系统返回一个form表单（如下所示的form表单，以字符串的形式返回）
>
> 然后我们商城的后台系统会将此字符串返回给前端，前端便可以直接执行表单的提交“document.forms[0].submit();”，这个提交后相当于前端直接提交给支付宝开放平台，并没有经过商城后端，此时支付宝开放平台就会给用户展示一个支付页面
>
> 这个支付页面有两个选项，一个是支付二维码，一个是支付宝账号登录

![image-20230917135737298](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917135737298.png)

#### 3.1.1.1 总结

* **所有接口的“公共参数”都是相同的，“请求参数”是各不一样的**

* **某些“公共参数”是在AlipayClient配置对象中添加的，“可选参数”在需要时添加即可**

* **实际上”请求参数“是“公共参数”中的“biz_content”字段，而且此字段应该是一个JSON类型的字符串**

```java
JSONObject bizContent = new JSONObject();
//商户订单号，商家自定义，保持唯一性
bizContent.put("out_trade_no", "20210817010101004");
//支付金额，最小值0.01元
bizContent.put("total_amount", 0.01);
//订单标题，不可使用特殊符号
bizContent.put("subject", "测试商品");
//电脑网站支付场景固定传值FAST_INSTANT_TRADE_PAY
bizContent.put("product_code", "FAST_INSTANT_TRADE_PAY");
request.setBizContent(bizContent.toString());
```

**或者说不使用上面JSON对象的形式，直接使用下面这种形式**

```java
AlipayTradePagePayRequest request = new AlipayTradePagePayRequest();

          AlipayTradePagePayModel model = new AlipayTradePagePayModel();
          model.setOutTradeNo("20150320010101001");
          model.setTotalAmount("88.88");
          model.setSubject("Iphone6 16G");
          model.setProductCode("FAST_INSTANT_TRADE_PAY");

request.setBizModel(model);
```







### 3.1.2 具体实现

我们根据官方提供的时序图编写即可

#### 3.1.2.1 Controller层

```java
@Slf4j
@CrossOrigin//跨域
@RestController
@RequestMapping("/api/ali-pay")
@Api(tags = "网站支付宝支付")
public class AliPayController {

    @Resource
    private AliPayService aliPayService;
    
    //  传入商品的id进行下单
    @PostMapping("/trade/page/pay/{productId}")
    @ApiOperation("统一收单下单并支付接口")
    public R tradePagePay(@PathVariable("productId") Long productId) {
        log.info("统一收单下单并支付接口");
//      支付宝开放平台接受Request请求对象后，会生成一个html形式的from表单，包含自动提交的脚本
        String formStr = aliPayService.tradeCreate(productId);

        return R.ok().data("formStr",formStr);
    }
}
```

#### 3.1.2.2 Service

```java
    @Transactional
    @Override
    public String tradeCreate(Long productId) {
        AlipayTradePagePayResponse response = null;
        try {
//          1.生成订单
            OrderInfo orderInfo = orderInfoService.createOrderByProductId(productId);
//          2.调用支付宝接口
//          请求的支付宝开放平台的接口名alipay.trade.page.pay，所以对象叫做AlipayTradePagePayRequest
            AlipayTradePagePayRequest request = new AlipayTradePagePayRequest();
//          异步接收地址，仅支持http/https，公网可访问
//          request.setNotifyUrl("");
//          同步跳转地址，仅支持http/https
//          request.setReturnUrl("");

            /******必传参数******/
            JSONObject bizContent = new JSONObject();
//          商户订单号，商家自定义，保持唯一性，64个字符以内，仅支持字母、数字、下划线且需保证在商户端不重复
            bizContent.put("out_trade_no", orderInfo.getOrderNo());

//          订单总金额，最小值0.01元，取值范围为 [0.01,100000000]。金额不能为0
            BigDecimal totalFee = new BigDecimal(orderInfo.getTotalFee().toString()).divide(new BigDecimal(100));
            bizContent.put("total_amount", totalFee);

//          订单标题，不可使用特殊符号，如 /，=，& 等
            bizContent.put("subject", orderInfo.getTitle());

//          电脑网站支付场景固定传值FAST_INSTANT_TRADE_PAY
            bizContent.put("product_code", "FAST_INSTANT_TRADE_PAY");

//          此时是完整的Request对象
            request.setBizContent(bizContent.toString());

//          响应结果的名字
            response = alipayClient.pageExecute(request);

            if (response.isSuccess()) {
                log.info("调用成功 - "+response);
                log.info(response.getBody());
            } else {
                log.info("调用失败 - "+response);
                log.info("返回描述 - "+response.getMsg());
                log.info("返回状态码 - "+response.getCode());
                throw  new RuntimeException("创建支付交易失败");
            }
        } catch (AlipayApiException e) {
            e.printStackTrace();
            throw  new RuntimeException("创建支付交易失败");
        }

        return response.getBody();
    }
```

#### 3.1.2.3 展示

![image-20230917162626141](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917162626141.png)



**账号登录支付**

![image-20230917163335161](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917163335161.png)

![image-20230917163357845](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917163357845.png)

![image-20230917163413145](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917163413145.png)



**支付宝扫码支付**

使用沙箱版支付宝扫码即可

![image-20230917162649551](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917162649551.png)

支付成功后便是下面这个样子

![image-20230917163109747](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917163109747.png)

但是我们希望支付成功后是我们的商城页面，而不是下面这个页面，下面来更改一下，如3.1.3所示



#### 3.1.2.4  支付成功 - 同步跳转回商户页面（return_url参数）

在支付宝的文档中，有如下两个字段

![image-20230917163750691](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917163750691.png)

现在主要看**return_url参数**，指定支付完成后跳转到哪个页面

```java
AlipayTradePagePayRequest request = new AlipayTradePagePayRequest();

//同步跳转地址，仅支持http/https
request.setReturnUrl(config.getProperty("alipay.return-url"));//http://localhost:8080/#/success
```



当我们支付成功后，如下图所示

![image-20230917164617262](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917164617262.png)

**很成功的跳转到了下图页面**

![image-20230917164637723](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917164637723.png)

## 3.2 支付成功异步通知

### 3.2.0 补充说明ngrok

> 官方网站：https://ngrok.com/
>
> 注册并登录

在官网下载后解压

![image-20230917180955086](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917180955086.png)

**命令行输入**

```sh
ngrok authtoken 你自己的token
```

token在这个地方复制即可

![image-20230917181644044](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917181644044.png)

启动ngrok,我们希望内网穿透到我们服务的8090端口

```sh
ngrok http 8090
```

“connecting”表示正在连接的状态

![image-20230917182056400](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917182056400.png)

“online”表示在线，已经连接成功

![image-20230917182147015](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917182147015.png)

我们可以看到内网穿透的地址有两个，一个是http，另一个是https

```properties
# 服务器异步通知页面路径  需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问
# 注意：每次重新启动ngrok，都需要根据实际情况修改这个配置
alipay.notify-url=https://a90b-101-27-21-172.ngrok-free.app/api/ali-pay/trade/notify
```







### 3.2.1 流程说明

当我们支付成功后，下面的订单状态要修改为“支付成功”

![image-20230917174524169](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917174524169.png)

**但是我们怎么知道支付宝端已经完成支付了呢**？

当我们支付成功后，支付宝会根据returnUrl帮我跳转到支付成功的页面

![image-20230917174734349](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917174734349.png)





与此同时，支付宝端还会向我们的客户端发起一个异步通知参数

如时序图中的7

所以我们就需要在商户系统当中开发一个接口，等待支付宝端成功支付之后向我们的商户系统发起调用（此时就需要用到内网穿透，可以让支付宝能够调用到我们系统中的异步请求接口）

![image-20230917175008390](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917175008390.png)





> 内网穿透知识点：[微信支付-基础支付APIv3-支付通知-内网穿透_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1US4y1D77m?p=48&vd_source=c01240addcba226237f3c4781490fbae)





### 3.2.2 异步结果通知

需要在之前Service层的tradeCreate设置异步通知地址

```java
            AlipayTradePagePayRequest request = new AlipayTradePagePayRequest();
//          异步接收地址，仅支持http/https，公网可访问
            request.setNotifyUrl(config.getProperty("alipay.notify-url"));
```



### 

> 官网[异步通知说明 - 支付宝文档中心 (alipay.com)](https://opendocs.alipay.com/open/270/105902?pathHash=d5cd617e&ref=api)
>
> ![image-20230917211245733](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917211245733.png)





#### 3.2.2.1 通知参数及通知结果

**分为“公共参数”和“业务参数”**

在“公共参数”中，notify_type字段一般是trade_status_sync，是不变的

![image-20230917212338970](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917212338970.png)

而且**异步通知是带有签名sign的，所以我们需要验签**，当签名校验成功了，才可以正确的接收通知并做之后的业务处理

如果签名验证不成功，说明是非法的

![image-20230917212451723](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917212451723.png)

**在“业务参数”中，有个字段为trade_no**,是支付宝交易号。在支付宝端，支付宝会对每一笔交易生成一个支付宝交易号（**支付宝端唯一交易编号**）

![image-20230917212704354](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917212704354.png)

**商家订单号**，之前在发送支付请求时我们自己生成的商家订单号，在异步通知中又给我们返回回来了，便于我们在回调通知当中去查找当时的订单数据

![image-20230917212852695](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917212852695.png)



我们可以看一下**通知的触发条件**：

当trade_status字段是TRADE_SUCCESS时，会触发异步通知

![image-20230917221319800](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917221319800.png)

**下面这个第一条挺重要的，返回结果要是“success”**

![image-20230917222525470](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917222525470.png)

```java
/**
 * @param params 将支付宝的请求参数转换成Map集合
 */
@PostMapping("/trade/notify")//注意要和配置文件中alipay.notify-url一致
public String tradeNotify(@RequestParam Map<String, String> params) {
    ....
    //向支付宝返回的成功的结果
    return "success";
}
```



> 其他详细信息官方文档可看：[异步通知说明 - 支付宝文档中心 (alipay.com)](https://opendocs.alipay.com/open/270/105902?pathHash=d5cd617e&ref=api)





#### 3.2.2.2 异步返回结果验签

> [异步通知说明 - 支付宝文档中心 (alipay.com)](https://opendocs.alipay.com/open/270/105902?pathHash=d5cd617e&ref=api)

我们引入的支付宝的SDK，所以我们可以使用比较方便的形式进行验签

```java
        //异步通知的验签
        boolean signVerified = AlipaySignature.rsaCheckV1(params,
//              支付宝公钥
                config.getProperty("alipay.alipay-public-key"),
//              编码方式
                AlipayConstants.CHARSET_UTF8,
//               签名类型
                AlipayConstants.SIGN_TYPE_RSA2); //调用SDK验证签名
        if (!signVerified) {
            // TODO 验签失败则记录异常日志，并在response中返回failure.
            log.error("支付成功 - 异步通知验签失败");
            return "failure";
        }
        log.info("支付成功 - 异步验签通知成功");
            // TODO 验签成功后，按照支付结果异步通知中的描述，对支付结果中的业务内容进行二次校验，校验成功后在response中返回success并继续商户自身业务处理，校验失败返回failure
```

**上面的操作相当于下图中的前四步**

![image-20230917233437468](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917233437468.png)



#### 3.2.2.3 业务内容二次校验

下面要完成的就是第五步

![image-20230917233618777](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917233618777.png)

#### 3.2.2.1 Controller

下面接口中的params参数，就是异步通知参数

```java
/**
 * @param params 将支付宝的请求参数转换成Map集合
 * @return
 */
@ApiOperation("支付通知")
@PostMapping("/trade/notify")//注意要和配置文件中alipay.notify-url一致
public String tradeNotify(@RequestParam Map<String, String> params) {
    log.info("支付通知");
    log.info("通知参数 - "+params);
    return "";
}
```

#### 3.2.2.2 Service

















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































