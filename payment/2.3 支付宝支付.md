# 支付宝支付功能

官方文档地址：[支付宝开放平台 (alipay.com)](https://open.alipay.com/api/detail?code=I1080300001000041203)

[TOC]



# 一、统一收单下单并支付页面接口



> 文档网址：[统一收单下单并支付页面接口 - 支付宝文档中心 (alipay.com)](https://opendocs.alipay.com/open/028r8t?pathHash=8e24911d&scene=22&ref=api)
>
> 沙箱调用及事例：[支付宝开放平台 (alipay.com)](https://open.alipay.com/api/apiDebug?apiNames=alipay.trade.close&frontProdCode=I1080300001000041203&backProdCode=I1011000100000000005)
>
> ![image-20230917172925345](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917172925345.png)

## 1.1 参数简单说明

“公共请求参数”中的部分必选参数已经在“一、配置准备”进行准备了

有一些必选参数，比如说“sign 签名”字段，是在AlipayConfig对象向支付宝发起调用之前，“签名”这个参数就会被自动生成，不用我们去手动设置

> 有一些比较重要的可选参数“return_url”、“notify_url”后面也会使用到

另外一个比较重要的“公共请求参数”是“**biz_content 请求参数的集合字段**”

![image-20230917131828867](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917131828867.png)



在“公共请求参数”中，有一个字段“**biz_content**”，表示**请求参数的集合，“请求参数”指的便是下图中的请求参数**。

简单的来讲就是**业务的具体参数**了，这些参数需要我们在编程时进行填写

![image-20230917131957312](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917131957312.png)

也有**公共响应参数**

![image-20230917134733858](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917134733858.png)

**响应参数**

![image-20230917134821060](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917134821060.png)

**响应实例**

响应内容的是一个表单，表单中还包含一个自动提交的脚本“document.forms[0].submit();”，会自动把form表单提交到action所指定的地址中。

> action地址也是支付宝开发平台提供的地址

最终展示的支付宝的支付登录页面就是提交到action地址之后产生的一种结果。

> 实际上我们需要在我们的商户页面中添加一个系统接口，这个接口需要前端页面调用，这个接口再调用统一下单并支付页面接口，调用后支付宝会给我们的系统返回一个form表单（如下所示的form表单，以字符串的形式返回）
>
> 然后我们商城的后台系统会将此字符串返回给前端，前端便可以直接执行表单的提交“document.forms[0].submit();”，这个提交后相当于前端直接提交给支付宝开放平台，并没有经过商城后端，此时支付宝开放平台就会给用户展示一个支付页面
>
> 这个支付页面有两个选项，一个是支付二维码，一个是支付宝账号登录

![image-20230917135737298](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917135737298.png)

### 1.1.1 总结

* **所有接口的“公共参数”都是相同的，“请求参数”是各不一样的**

* **某些“公共参数”是在AlipayClient配置对象中添加的，“可选参数”在需要时添加即可**

* **实际上”请求参数“是“公共参数”中的“biz_content”字段，而且此字段应该是一个JSON类型的字符串**

```java
JSONObject bizContent = new JSONObject();
//商户订单号，商家自定义，保持唯一性
bizContent.put("out_trade_no", "20210817010101004");
//支付金额，最小值0.01元
bizContent.put("total_amount", 0.01);
//订单标题，不可使用特殊符号
bizContent.put("subject", "测试商品");
//电脑网站支付场景固定传值FAST_INSTANT_TRADE_PAY
bizContent.put("product_code", "FAST_INSTANT_TRADE_PAY");
request.setBizContent(bizContent.toString());
```

**或者说不使用上面JSON对象的形式，直接使用下面这种形式**

```java
AlipayTradePagePayRequest request = new AlipayTradePagePayRequest();

          AlipayTradePagePayModel model = new AlipayTradePagePayModel();
          model.setOutTradeNo("20150320010101001");
          model.setTotalAmount("88.88");
          model.setSubject("Iphone6 16G");
          model.setProductCode("FAST_INSTANT_TRADE_PAY");

request.setBizModel(model);
```

## 1.2  具体实现

**我们根据官方提供的时序图编写即可**

### 1.2.1 Controller层

```java
@Slf4j
@CrossOrigin//跨域
@RestController
@RequestMapping("/api/ali-pay")
@Api(tags = "网站支付宝支付")
public class AliPayController {

    @Resource
    private AliPayService aliPayService;
    
    //  传入商品的id进行下单
    @PostMapping("/trade/page/pay/{productId}")
    @ApiOperation("统一收单下单并支付接口")
    public R tradePagePay(@PathVariable("productId") Long productId) {
        log.info("统一收单下单并支付接口");
//      支付宝开放平台接受Request请求对象后，会生成一个html形式的from表单，包含自动提交的脚本
        String formStr = aliPayService.tradeCreate(productId);

        return R.ok().data("formStr",formStr);
    }
}
```

### 1.2.2 Service

```java
    @Transactional
    @Override
    public String tradeCreate(Long productId) {
        AlipayTradePagePayResponse response = null;
        try {
//          1.生成订单
            OrderInfo orderInfo = orderInfoService.createOrderByProductId(productId,PayType.ALIPAY.getType());
//          2.调用支付宝接口
//          请求的支付宝开放平台的接口名alipay.trade.page.pay，所以对象叫做AlipayTradePagePayRequest
            AlipayTradePagePayRequest request = new AlipayTradePagePayRequest();
//          异步接收地址，仅支持http/https，公网可访问
//          request.setNotifyUrl("");
//          同步跳转地址，仅支持http/https
//          request.setReturnUrl("");

            /******必传参数******/
            JSONObject bizContent = new JSONObject();
//          商户订单号，商家自定义，保持唯一性，64个字符以内，仅支持字母、数字、下划线且需保证在商户端不重复
            bizContent.put("out_trade_no", orderInfo.getOrderNo());

//          订单总金额，最小值0.01元，取值范围为 [0.01,100000000]。金额不能为0
            BigDecimal totalFee = new BigDecimal(orderInfo.getTotalFee().toString()).divide(new BigDecimal(100));
            bizContent.put("total_amount", totalFee);

//          订单标题，不可使用特殊符号，如 /，=，& 等
            bizContent.put("subject", orderInfo.getTitle());

//          电脑网站支付场景固定传值FAST_INSTANT_TRADE_PAY
            bizContent.put("product_code", "FAST_INSTANT_TRADE_PAY");

//          此时是完整的Request对象
            request.setBizContent(bizContent.toString());

//          响应结果的名字
            response = alipayClient.pageExecute(request);

            if (response.isSuccess()) {
                log.info("调用成功 - "+response);
                log.info(response.getBody());
            } else {
                log.info("调用失败 - "+response);
                log.info("返回描述 - "+response.getMsg());
                log.info("返回状态码 - "+response.getCode());
                throw  new RuntimeException("创建支付交易失败");
            }
        } catch (AlipayApiException e) {
            e.printStackTrace();
            throw  new RuntimeException("创建支付交易失败");
        }

        return response.getBody();
    }
```

### 1.2.3 展示

![image-20230917162626141](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917162626141.png)



**账号登录支付**

![image-20230917163335161](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917163335161.png)

![image-20230917163357845](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917163357845.png)

![image-20230917163413145](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917163413145.png)



**支付宝扫码支付**

使用沙箱版支付宝扫码即可

![image-20230917162649551](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917162649551.png)

支付成功后便是下面这个样子

![image-20230917163109747](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917163109747.png)

但是我们希望支付成功后是我们的商城页面，而不是下面这个页面，下面来更改一下，如3.1.3所示

## 1.3 支付成功 - 同步跳转回商户页面（return_url参数）

在支付宝的文档中，有如下两个字段

![image-20230917163750691](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917163750691.png)

现在主要看**return_url参数**，指定支付完成后跳转到哪个页面

```java
AlipayTradePagePayRequest request = new AlipayTradePagePayRequest();

//同步跳转地址，仅支持http/https
request.setReturnUrl(config.getProperty("alipay.return-url"));//http://localhost:8080/#/success
```



当我们支付成功后，如下图所示

![image-20230917164617262](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917164617262.png)

**很成功的跳转到了下图页面**

![image-20230917164637723](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917164637723.png)



# 二、支付成功异步通知

## 2.0 补充说明ngrok

> 官方网站：https://ngrok.com/
>
> 注册并登录

在官网下载后解压

![image-20230917180955086](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917180955086.png)

**命令行输入**

```sh
ngrok authtoken 你自己的token
```

token在这个地方复制即可

![image-20230917181644044](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917181644044.png)

启动ngrok,我们希望内网穿透到我们服务的8090端口

```sh
ngrok http 8090
```

“connecting”表示正在连接的状态

![image-20230917182056400](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917182056400.png)

“online”表示在线，已经连接成功

![image-20230917182147015](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917182147015.png)

我们可以看到内网穿透的地址有两个，一个是http，另一个是https

```properties
# 服务器异步通知页面路径  需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问
# 注意：每次重新启动ngrok，都需要根据实际情况修改这个配置
alipay.notify-url=https://a90b-101-27-21-172.ngrok-free.app/api/ali-pay/trade/notify
```





## 2.1 流程说明



当我们支付成功后，下面的订单状态要修改为“支付成功”

![image-20230917174524169](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917174524169.png)

**但是我们怎么知道支付宝端已经完成支付了呢**？

当我们支付成功后，支付宝会根据returnUrl帮我跳转到支付成功的页面

![image-20230917174734349](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917174734349.png)





与此同时，支付宝端还会向我们的客户端发起一个异步通知参数

如时序图中的7

所以我们就需要在商户系统当中开发一个接口，等待支付宝端成功支付之后向我们的商户系统发起调用（此时就需要用到内网穿透，可以让支付宝能够调用到我们系统中的异步请求接口）

![image-20230917175008390](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917175008390.png)





> 内网穿透知识点：[微信支付-基础支付APIv3-支付通知-内网穿透_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1US4y1D77m?p=48&vd_source=c01240addcba226237f3c4781490fbae)

## 2.2 异步结果通知

需要在之前Service层的tradeCreate设置异步通知地址

```java
            AlipayTradePagePayRequest request = new AlipayTradePagePayRequest();
//          异步接收地址，仅支持http/https，公网可访问
            request.setNotifyUrl(config.getProperty("alipay.notify-url"));
```



> 官网[异步通知说明 - 支付宝文档中心 (alipay.com)](https://opendocs.alipay.com/open/270/105902?pathHash=d5cd617e&ref=api)
>
> ![image-20230917211245733](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917211245733.png)

### 2.2.1 通知参数及通知结果

**分为“公共参数”和“业务参数”**

在“公共参数”中，notify_type字段一般是trade_status_sync，是不变的

![image-20230917212338970](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917212338970.png)

而且**异步通知是带有签名sign的，所以我们需要验签**，当签名校验成功了，才可以正确的接收通知并做之后的业务处理

如果签名验证不成功，说明是非法的

![image-20230917212451723](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917212451723.png)

**在“业务参数”中，有个字段为trade_no**,是支付宝交易号。在支付宝端，支付宝会对每一笔交易生成一个支付宝交易号（**支付宝端唯一交易编号**）

![image-20230917212704354](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917212704354.png)

**商家订单号**，之前在发送支付请求时我们自己生成的商家订单号，在异步通知中又给我们返回回来了，便于我们在回调通知当中去查找当时的订单数据

![image-20230917212852695](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917212852695.png)



我们可以看一下**通知的触发条件**：

当trade_status字段是TRADE_SUCCESS时，会触发异步通知

![image-20230917221319800](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917221319800.png)

**下面这个第一条挺重要的，返回结果要是“success”**

![image-20230917222525470](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917222525470.png)

```java
/**
 * @param params 将支付宝的请求参数转换成Map集合
 */
@PostMapping("/trade/notify")//注意要和配置文件中alipay.notify-url一致
public String tradeNotify(@RequestParam Map<String, String> params) {
    ....
    //向支付宝返回的成功的结果
    return "success";
}
```



> 其他详细信息官方文档可看：[异步通知说明 - 支付宝文档中心 (alipay.com)](https://opendocs.alipay.com/open/270/105902?pathHash=d5cd617e&ref=api)



### 2.2.2 异步返回结果验签

> [异步通知说明 - 支付宝文档中心 (alipay.com)](https://opendocs.alipay.com/open/270/105902?pathHash=d5cd617e&ref=api)

我们引入的支付宝的SDK，所以我们可以使用比较方便的形式进行验签

```java
        //异步通知的验签
        boolean signVerified = AlipaySignature.rsaCheckV1(params,
//              支付宝公钥
                config.getProperty("alipay.alipay-public-key"),
//              编码方式
                AlipayConstants.CHARSET_UTF8,
//               签名类型
                AlipayConstants.SIGN_TYPE_RSA2); //调用SDK验证签名
        if (!signVerified) {
            // TODO 验签失败则记录异常日志，并在response中返回failure.
            log.error("支付成功 - 异步通知验签失败");
            return "failure";
        }
        log.info("支付成功 - 异步验签通知成功");
            // TODO 验签成功后，按照支付结果异步通知中的描述，对支付结果中的业务内容进行二次校验，校验成功后在response中返回success并继续商户自身业务处理，校验失败返回failure
```

**上面的操作相当于下图中的前四步**

![image-20230917233437468](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917233437468.png)

### 2.2.3 业务内容二次校验

> **异步通知验签之后就要做业务内容的二次校验**
>
> 下面要完成的就是第五步
>
> ![image-20230917233618777](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230917233618777.png)



```java
//      TODO 2.业务内容二次校验
//      2.1 商家需要验证该通知数据中的 out_trade_no 是否为商家系统中创建的订单号。
//      将此订单去数据库中查询，如果查询到是存在的，那就是我们商户系统中的订单；如果查询不到的话，说明不是我们商户系统中的订单
        String outTradeNo = params.get("out_trade_no");
        OrderInfo order = orderInfoService.getOrderByOrderNo(outTradeNo);
        if (order == null) {
            log.info("订单不存在");
            return result;//failure
        }
//      2.2 判断 total_amount 是否确实为该订单的实际金额（即商家订单创建时的金额）
//      这个地方注意，商户系统中是以分为单位，但是支付宝中是以元为单位
        String totalAmount = params.get("total_amount");
//      将支付宝给我们的金额乘100转换成分，与商户系统中的金额进行对比
        int totalAmountInt = new BigDecimal(totalAmount).multiply(new BigDecimal("100")).intValue();//乘100
        int totalFeeInt = order.getTotalFee();
        if (totalAmountInt != totalFeeInt) {
            log.error("金额校验失败");
            return result;//failure
        }
//      2.3 校验通知中的 seller_id（或者 seller_email) 是否为 out_trade_no 这笔单据的对应的操作方（有的时候，一个商家可能有多个 seller_id/seller_email）
//      这个地方不一致的话，说明你付给别人了
        String sellerId = params.get("seller_id");//商户PID，我们的是2088721011169741
        String sellerIdProperty = config.getProperty("alipay.seller-id");
        if (!sellerId.equals(sellerIdProperty)) {
            log.error("商家PID校验失败");
            return result;//failure
        }
//      2.4 验证 app_id 是否为该商家本身
        String appId = params.get("app_id");
        String appIdProperty = config.getProperty("alipay.app-id");
        if (!appId.equals(appIdProperty)) {
            log.error("AppID校验失败");
            return result;//failure
        }
//      2.5在支付宝的业务通知中，只有交易通知状态为 TRADE_SUCCESS 或 TRADE_FINISHED 时，支付宝才会认定为买家付款成功
//      在这个地方我们只判断TRADE_SUCCESS即可，因为TRADE_FINISHED是不能退款的，但是我们以后是可以退款的
        String tradeStatus = params.get("trade_status");
        if (!"TRADE_SUCCESS".equals(tradeStatus)) {
            log.error("支付未成功");
            return result;//failure
        }
```

### 2.2.4 处理订单业务

![image-20230918225106994](C:\Users\jd\AppData\Roaming\Typora\typora-user-images\image-20230918225106994.png)

**Controller层**

```java
//      TODO 3.处理业务、修改订单状态、记录支付日志
//      校验成功后在response中返回success并继续商户自身业务处理，校验失败返回failure
        aliPayService.processOrder(params);//将所有的回调参数传入
```



**调用的Service层AliPayServiceImpl**

```java
    /**
     * 处理订单
     * @param params
     */
    @Override
    public void processOrder(Map<String, String> params) {
        log.info("处理订单");
//      获取订单号
        String orderNo = params.get("out_trade_no");
//      更新订单状态
        orderInfoService.updateStatusByOrderNo(orderNo, OrderStatus.SUCCESS);//OrderStatus.SUCCESS 支付成功
//      记录支付日志
        paymentInfoService.createPaymentInfoForAliPay(params);
        
    }
```

**调用的Service层PaymentInfoServiceImpl**

```java
    /**
     * 记录支付宝支付日志
     */
    @Transactional
    @Override
    public void createPaymentInfoForAliPay(Map<String, String> params) {
        log.info("记录支付日志");
//      获取订单号
        String orderNo = params.get("out_trade_no");
//      支付系统交易编号(支付宝交易凭证号)
        String transactionId = params.get("trade_no");
//      交易状态
        String tradeStatus = params.get("trade_status");
//      交易总金额
        String totalAmount = params.get("total_amount");
        int totalAmountInt = new BigDecimal(totalAmount).multiply(new BigDecimal("100")).intValue();

        PaymentInfo paymentInfo = new PaymentInfo();
        paymentInfo.setOrderNo(orderNo);
        paymentInfo.setPaymentType(PayType.ALIPAY.getType());
        paymentInfo.setTransactionId(transactionId);
        paymentInfo.setTradeType("电脑网站支付");
        paymentInfo.setTradeState(tradeStatus);
        paymentInfo.setPayerTotal(totalAmountInt);

        String paymentInfoJSON = JSONObject.toJSONString(params);
        paymentInfo.setContent(paymentInfoJSON);//通知参数
//      插入数据库
        baseMapper.insert(paymentInfo);
    }
```

### 2.2.5 处理重复通知

> [异步通知说明 - 支付宝文档中心 (alipay.com)](https://opendocs.alipay.com/open/270/105902?pathHash=d5cd617e&ref=api)

![image-20230918225130102](C:\Users\jd\AppData\Roaming\Typora\typora-user-images\image-20230918225130102.png)

**为什么要过滤重复的通知结果数据呢**？

如下原因。支付宝会给商户系统发送通知，而我们的商户系统会给我们的支付宝端返回一个“success”，如果4分钟内支付宝端没有收到“success”，支付宝就会间隔10分钟再次通知

假设我们的商户系统在给支付宝发送了“success”时由于网络等其他原因并没有成功返回给支付宝，那么支付宝就会重复向商户系统发送通知

支付宝又发送通知后，我们的数据库的支付记录就会记录一笔账单两或多次（相当于我们支付了一次，但是数据库中至少有1条），我们的支付状态也会修改第二次（支付状态的修改对程序不会造成影响）

![image-20230918230243886](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230918230243886.png)





```java
    /**
     * 处理订单
     * @param params
     */
    @Override
    public void processOrder(Map<String, String> params) {
        log.info("处理订单");
//      获取订单号
        String orderNo = params.get("out_trade_no");

//      TODO 处理重复通知
//      接口调用的幂等性：无论接口被调用多少次，以下业务执行一次
        String orderStatus = orderInfoService.getOrderStatus(orderNo);
        if (!OrderStatus.NOTPAY.getType().equals(orderStatus)){
//          只要不是未支付，就执行下面这个地方
            return;
        }
//      更新订单状态
        orderInfoService.updateStatusByOrderNo(orderNo, OrderStatus.SUCCESS);//OrderStatus.SUCCESS 支付成功
//      记录支付日志
        paymentInfoService.createPaymentInfoForAliPay(params);

    }
```

新增的代码如下图所示

```java
//      TODO 处理重复通知
//      接口调用的幂等性：无论接口被调用多少次，以下业务执行一次
        String orderStatus = orderInfoService.getOrderStatus(orderNo);
        if (!OrderStatus.NOTPAY.getType().equals(orderStatus)){
//          只要不是未支付，就执行下面这个地方
            return;
        }
```



### 2.2.6 数据锁

我们在2.2.4编写的业务逻辑存在线程并发安全问题，所以我们可以加一把锁

```java
private  final ReentrantLock lock = new ReentrantLock();
```

> **ReentrantLock**是Java中的一个**可重入锁类**，用于**实现线程同步和互斥**
>
> ReentrantLock是Java提供的一种**高级锁机制**，它支持可重入特性，即同一个线程可以多次获得该锁而不会造成死锁。
>
> 在多线程环境中，ReentrantLock可用于保护临界区，防止多个线程同时访问共享资源或共享数据的代码段。
>
> 通过使用`lock()`方法获取锁并在代码块执行完毕后使用`unlock()`方法释放锁，可以确保只有一个线程在任意时刻能够进入被保护的临界区
>
> 一般而言，`ReentrantLock`比传统的`synchronized`关键字提供了更多的灵活性和功能，例如可中断的锁、公平性选择、条件变量等。但在使用时需要格外小心，确保正确处理锁的获取和释放，避免死锁和资源争用的问题



```java
    /**
     * 处理订单
     *
     * @param params
     */
    @Override
    public void processOrder(Map<String, String> params) {
        log.info("处理订单");
//      获取订单号
        String orderNo = params.get("out_trade_no");
//      尝试获取锁：成功获取则立即返回true，获取失败则立即返回false，不必一直等待锁的释放
        if (lock.tryLock()) {
            try {
//              处理重复通知
//              接口调用的幂等性：无论接口被调用多少次，以下业务执行一次
                String orderStatus = orderInfoService.getOrderStatus(orderNo);
                if (!OrderStatus.NOTPAY.getType().equals(orderStatus)) {
//                  只要不是未支付，就执行下面这个地方
                    return;
                }
//              更新订单状态
                orderInfoService.updateStatusByOrderNo(orderNo, OrderStatus.SUCCESS);//OrderStatus.SUCCESS 支付成功
//              记录支付日志
                paymentInfoService.createPaymentInfoForAliPay(params);
            } finally {
                lock.unlock();
            }
        }
    }
```



#### Controller

下面接口中的params参数，就是异步通知参数

```java
/**
 * @param params 将支付宝的请求参数转换成Map集合
 * @return
 */
@ApiOperation("支付通知")
@PostMapping("/trade/notify")//注意要和配置文件中alipay.notify-url一致
public String tradeNotify(@RequestParam Map<String, String> params) {
    log.info("支付通知");
    log.info("通知参数 - "+params);
    return "";
}
```



## 2.3 Controller 总结

重要代码

```java
    /**
     * @param params 将支付宝的请求参数转换成Map集合
     * @return
     */
    @ApiOperation("支付通知")
    @PostMapping("/trade/notify")//注意要和配置文件中alipay.notify-url一致
    public String tradeNotify(@RequestParam Map<String, String> params) throws AlipayApiException {
        log.info("支付通知");
        log.info("通知参数 - " + params);
        String result = "failure";

//      TODO 1.异步通知的验签
        boolean signVerified = AlipaySignature.rsaCheckV1(params,
//              支付宝公钥
                config.getProperty("alipay.alipay-public-key"),
//              编码方式
                AlipayConstants.CHARSET_UTF8,
//               签名类型
                AlipayConstants.SIGN_TYPE_RSA2); //调用SDK验证签名
        if (!signVerified) {
            //验签失败则记录异常日志，并在response中返回failure.
            log.error("支付成功 - 异步通知验签失败");
            return result;//failure
        }
        log.info("支付成功 - 异步验签通知成功");
//      验签成功后，按照支付结果异步通知中的描述，对支付结果中的业务内容进行二次校验，校验成功后在response中返回success并继续商户自身业务处理，校验失败返回failure

//      TODO 2.业务内容二次校验
//      2.1 商家需要验证该通知数据中的 out_trade_no 是否为商家系统中创建的订单号。
//      将此订单去数据库中查询，如果查询到是存在的，那就是我们商户系统中的订单；如果查询不到的话，说明不是我们商户系统中的订单
        String outTradeNo = params.get("out_trade_no");
        OrderInfo order = orderInfoService.getOrderByOrderNo(outTradeNo);
        if (order == null) {
            log.info("订单不存在");
            return result;//failure
        }
//      2.2 判断 total_amount 是否确实为该订单的实际金额（即商家订单创建时的金额）
//      这个地方注意，商户系统中是以分为单位，但是支付宝中是以元为单位
        String totalAmount = params.get("total_amount");
//      将支付宝给我们的金额乘100转换成分，与商户系统中的金额进行对比
        int totalAmountInt = new BigDecimal(totalAmount).multiply(new BigDecimal("100")).intValue();//乘100
        int totalFeeInt = order.getTotalFee();
        if (totalAmountInt != totalFeeInt) {
            log.error("金额校验失败");
            return result;//failure
        }
//      2.3 校验通知中的 seller_id（或者 seller_email) 是否为 out_trade_no 这笔单据的对应的操作方（有的时候，一个商家可能有多个 seller_id/seller_email）
//      这个地方不一致的话，说明你付给别人了
        String sellerId = params.get("seller_id");//商户PID，我们的是2088721011169741
        String sellerIdProperty = config.getProperty("alipay.seller-id");
        if (!sellerId.equals(sellerIdProperty)) {
            log.error("商家PID校验失败");
            return result;//failure
        }
//      2.4 验证 app_id 是否为该商家本身
        String appId = params.get("app_id");
        String appIdProperty = config.getProperty("alipay.app-id");
        if (!appId.equals(appIdProperty)) {
            log.error("AppID校验失败");
            return result;//failure
        }
//      2.5在支付宝的业务通知中，只有交易通知状态为 TRADE_SUCCESS 或 TRADE_FINISHED 时，支付宝才会认定为买家付款成功
//      在这个地方我们只判断TRADE_SUCCESS即可，因为TRADE_FINISHED是不能退款的，但是我们以后是可以退款的
        String tradeStatus = params.get("trade_status");
        if (!"TRADE_SUCCESS".equals(tradeStatus)) {
            log.error("支付未成功");
            return result;//failure
        }

//      TODO 3.处理业务、修改订单状态、记录支付日志
//      校验成功后在response中返回success并继续商户自身业务处理，校验失败返回failure
        aliPayService.processOrder(params);//将所有的回调参数传入


//      TODO 向支付宝返回的成功的结果（通知结果）
        return result;
    }
```



## 2.4 Service 总结

**重要代码**

```java
    /**
     * 处理订单
     * @param params
     */
    @Override
    public void processOrder(Map<String, String> params) {
        log.info("处理订单");
//      获取订单号
        String orderNo = params.get("out_trade_no");
//      尝试获取锁：成功获取则立即返回true，获取失败则立即返回false，不必一直等待锁的释放
        if (lock.tryLock()) {
            try {
//              处理重复通知
//              接口调用的幂等性：无论接口被调用多少次，以下业务执行一次
                String orderStatus = orderInfoService.getOrderStatus(orderNo);
                if (!OrderStatus.NOTPAY.getType().equals(orderStatus)) {
//                  只要不是未支付，就执行下面这个地方
                    return;
                }
//              更新订单状态
                orderInfoService.updateStatusByOrderNo(orderNo, OrderStatus.SUCCESS);//OrderStatus.SUCCESS 支付成功
//              记录支付日志
                paymentInfoService.createPaymentInfoForAliPay(params);
            } finally {
                lock.unlock();
            }
        }
    }
```





# 三、统一收单交易关闭接口

> [统一收单交易关闭接口 - 支付宝文档中心 (alipay.com)](https://opendocs.alipay.com/open/8dc9ebb3_alipay.trade.close?pathHash=0c042d2b&ref=api&scene=common)
>
> ![image-20230919213331664](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230919213331664.png)

**用户取消订单**

假如说用户进入了下面的页面，但是没有支付

![image-20230919210046889](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230919210046889.png)

就会出现下图的现象，显示未支付

![image-20230919210232463](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230919210232463.png)



## 3.1 请求参数

下面中，有两个特殊可选的：**trade_no（支付宝交易流水号）和out_trade_no（商户订单号），并且这两个参数要二选一**

![image-20230919214013591](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230919214013591.png)



## 3.2 Controller

```java
/***
 * 用户取消订单
 */
@ApiOperation("用户取消订单")
@PostMapping("/trade/close/{orderNo}")
public R cancel(@PathVariable String orderNo) {
    log.info("用户取消订单");
    aliPayService.cancelOrder(orderNo);
    return R.ok().setMessage("订单已取消");
}
```





## 3.3 Service

```java
 /**
     * 用户取消订单
     *
     * @param orderNo 订单号
     */
    @Override
    public void cancelOrder(String orderNo) {
//      调用支付宝提供的统一收单交易关闭接口
        this.closeOrder(orderNo);
//      更新用户的订单状态
        orderInfoService.updateStatusByOrderNo(orderNo, OrderStatus.CANCEL);//OrderStatus.CANCEL 用户已取消


    }

    /**
     * 统一收单交易关闭接口
     *
     * @param orderNo 商户订单号
     */
    @Transactional
    public void closeOrder(String orderNo) {
        log.info("统一收单交易关闭接口:" + orderNo);

        try {
            AlipayTradeCloseRequest request = new AlipayTradeCloseRequest();

            JSONObject bizContent = new JSONObject();
            bizContent.put("out_trade_no", orderNo); // 商户订单号
            request.setBizContent(bizContent.toString());

            AlipayTradeCloseResponse   response = alipayClient.execute(request);

            if (response.isSuccess()) {
                log.info("调用成功 - " + response);
                log.info(response.getBody());
            } else {
                log.info("调用失败 - " + response);
                log.info("返回描述 - " + response.getMsg());
                log.info("返回状态码 - " + response.getCode());
//              这个地方我们就不抛出异常了，让程序正常执行
//              在此else中出现的情况可能是支付宝并没有收到订单，进而没有收到out_trade_no，所以我们在这里使用out_trade_no查询不到
//              在cancelOrder方法中closeOrder方法执行完成之后，就会执行updateStatusByOrderNo，将订单状态修改为 用户已取消
//                throw new RuntimeException("统一收单交易关闭接口失败");
            }
        } catch (AlipayApiException e) {
            e.printStackTrace();
            throw new RuntimeException("统一收单交易关闭接口失败");
        }

    }
```



## 3.4 效果

测试的时候可能会出现下面的异常

原因：

1. 商户系统只展示了二维码，但是没有扫描二维码（扫码后，支付宝那边就会创建一个订单），支付宝那边没有这一笔订单
2. 用户在商户系统中使用支付宝账户登录了，并且到了输入密码的界面（支付宝在此界面就会创建一个订单），但是没有结账就返回了，也会出现这种情况

**总的来说出现下图的情况就是支付宝没有创建交易记录**

![image-20230919215919855](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230919215919855.png)



如果都不存在上面两种情况的话，如下图所示就是正常的

![image-20230919220220165](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230919220220165.png)





# 四、统一收单线下交易查询

在第七步当中，是支付宝端给商户管理系统发送一个异步通知，来通知我们这次支付是否是成功的

但是可能会出现商户端迟迟没有接收到支付宝的通知

原因可能是：

1. 支付宝端没有成功的发送通知 
2. 由于网络原因，商户管理系统没有接收到支付宝端的通知

![image-20230919222550401](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230919222550401.png)

为了避免这种情况，我们可以主动向支付宝端发起一个订单查询，也就是一个查单请求



## 4.1 参数

**请求参数**下面这俩参数二选一即可

![image-20230919225556076](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230919225556076.png)

**响应参数**，会用到下面这个数据

![image-20230919231648531](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230919231648531.png)



## 4.2 Controller

```java
    /**
     * @param orderNo
     * @return
     */
    @ApiOperation("查询订单")
    @GetMapping("/trade/query/{orderNo}")
    public R queryOrder(@PathVariable String orderNo) {
        log.info("查询订单");
        String result =  aliPayService.queryOrder(orderNo);
        return R.ok().setMessage("查询成功").data("result",result);
    }
```



## 4.3 Service

```java
/**
 * 查询订单
 * @param orderNo 商户订单号
 */
@Override
public String queryOrder(String orderNo) {

    try {
        AlipayTradeQueryRequest request = new AlipayTradeQueryRequest();

        JSONObject bizContent = new JSONObject();
        bizContent.put("out_trade_no", orderNo);

        request.setBizContent(bizContent.toString());
        AlipayTradeQueryResponse response = alipayClient.execute(request);

        if (response.isSuccess()) {
            log.info("调用成功 - " + response);
            log.info(response.getBody());
            return response.getBody();
        } else {
            log.info("调用失败 - " + response);
            log.info("返回描述 - " + response.getMsg());
            log.info("返回状态码 - " + response.getCode());
//            throw new RuntimeException("统一收单线下交易查询调用失败");
            return null; //订单在支付宝端并没有创建
        }

    } catch (AlipayApiException e) {
        e.printStackTrace();
        throw new RuntimeException("统一收单线下交易查询调用失败");
    }


}
```



## 4.4 定时任务

这个接口的调用并不是在页面上调用的，而是当商户系统收不到支付宝端发送的异步通知时再调用

![image-20230919230415415](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230919230415415.png)



“统一收单线下交易查询”是通过我们的**定时任务进行调用**的，比如说五分钟内没有接受到支付宝的异步通知，便查询一次 



**使用@EnableScheduling注解开启定时任务**

```java
@SpringBootApplication
//引入Spring Task
@EnableScheduling
public class PaymentDemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(PaymentDemoApplication.class, args);
    }

}
```

> [springboot---任务---整合quartz与task----定时任务（详细）_quartz和task_我爱布朗熊的博客-CSDN博客](https://blog.csdn.net/weixin_51351637/article/details/125493351)



### 4.4.1 定时查单 任务类

**定时查单的目的：查询创建超过minutes分钟并且未支付的订单**



```java
@Slf4j
@Component//定时任务要作为一个组件在Spring容器当中创建
public class AliPayTask {

    @Resource
    private OrderInfoService orderInfoService;

    @Resource
    private AliPayService aliPayService;

    /**
     * 从第0秒开始，每间隔30秒执行1次，查询创建超过5分钟并且未支付的订单
     * 秒 分 时 日 月 周
     * 以秒为例
     * *：每秒都执行
     * 1-3：从第1秒开始执行，到第3秒结束执行
     * 0/3：从第0秒开始，每隔3秒执行1次
     * 1,2,3：在指定的第1、2、3秒执行
     * ?：不指定
     * 日和周不能同时制定，指定其中之一，则另一个设置为?
     */
    @Scheduled(cron = "0/30 * * * * ?")
    public void  orderConfirm() throws Exception{
        log.info("aliPay orderConfirm 被执行");
//      获取超过5分钟没有支付的订单
        List<OrderInfo> orderInfoList =  orderInfoService.getNoPayOrderByDuration(5, PayType.ALIPAY.getType());

        for (OrderInfo orderInfo : orderInfoList) {
            String orderNo = orderInfo.getOrderNo();
            log.warn("超时订单 ===> {}", orderNo);
            
            // 核实订单状态：并调用支付宝查单接口
            aliPayService.checkOrderStatus(orderNo);
        }
    }


}
```

> 我们在4.4.1定时查单中查询出来的List\<OrderInfo\> orderInfoList集合只是我们自己业务系统中查询出来的，和支付宝端支付不支付无关
>
> 所以我们就需要将orderInfoList集合遍历，然后查看一下对应的订单在支付宝端是怎样的一个状态
>
> 这个地方会用到查单接口





### 4.4.2 获取超时订单Service

**查询创建超过minutes分钟并且未支付的订单**

> 这次说的未支付的订单是在我们自己数据库中标明的未支付的订单，而不是在支付宝端标明的未支付的订单

```java
    /**
     * 查询创建超过minutes分钟并且未支付的订单
     *
     * @param minutes
     * @return
     */
    @Override
    public List<OrderInfo> getNoPayOrderByDuration(int minutes,String paymentType) {

//      当前时间之前的minutes分钟;minus(Duration.ofMinutes(minutes)) 是对当前时间进行减法操作,以计算指定分钟数之前的时刻
//      Duration.ofMinutes(minutes) 创建了一个Duration对象，表示了指定分钟数的时间量
        Instant instant = Instant.now().minus(Duration.ofMinutes(minutes));
        log.info("instant - "+instant);
        QueryWrapper<OrderInfo> queryWrapper = new QueryWrapper<>();
//      未支付的订单
        queryWrapper.eq("order_status", OrderStatus.NOTPAY.getType());
//      小于等于instant时刻的，肯定是超过或等于minutes时间了
        queryWrapper.le("create_time", instant);
        queryWrapper.eq("payment_type",paymentType);

        List<OrderInfo> orderInfoList = baseMapper.selectList(queryWrapper);

        return orderInfoList;
    }
```



### 4.4.2 核实订单状态Service

```java
 /**
     * 根据商户订单号查询支付宝查单接口，核实订单状态
     *
     * 1.如果订单未创建，则直接更新商户端的订单状态即可
     * 2.如果订单未支付，则调用关单接口关闭订单，并更新商户端订单状态
     * 3.如果已经支付，则更新商户端订单状态，并记录支付日志
     *
     * @param orderNo 商户订单号
     */
    @Override
    public void checkOrderStatus(String orderNo) {
        log.info("根据订单号核实订单状态 ===》{}", orderNo);
        String result = this.queryOrder(orderNo);//如果返回的是null，表示支付宝端不存在此订单

        if (result == null) {
//          TODO 如果订单未创建，则直接更新商户端的订单状态即可
            log.info("核实订单未创建 ===》{}", orderNo);
//          更新本地订单状态,将订单关闭
            orderInfoService.updateStatusByOrderNo(orderNo, OrderStatus.CLOSED);
            return;
        }

        JSONObject resultJson = JSONObject.parseObject(result);
        log.info("resultJson - " + resultJson);
        String tradeStatus = resultJson.getJSONObject("alipay_trade_query_response").getString("trade_status");
        log.info("tradeStatus - " + tradeStatus);

//      TODO 如果订单未支付，则调用关单接口关闭订单，并更新商户端订单状态
        if (AliPayTradeState.NOTPAY.getType().equals(tradeStatus)) {
            log.info("核实订单未支付 ===》{}", orderNo);
//          调用关单接口关闭订单(统一收单交易关闭接口)
            this.closeOrder(orderNo);
//          并更新商户端订单状态(超时关闭)
            orderInfoService.updateStatusByOrderNo(orderNo, OrderStatus.CLOSED);
            return;
        }

//      TODO 如果已经支付，则更新商户端订单状态，并记录支付日志
//      正常情况下，用户付款后，商户系统会收到支付宝发送的一个异步通知，在这个通知中我们会接收到支付宝处理的结果，然后我们去修改订单的状态
//      但是在定时查单的过程中发现，明明已经支付的订单但是在商户系统中显示没有支付，这是怎么发生的呢？
//      原因是商户系统由于某些原因没有接收到异步通知 或者说 支付宝发送异步通知失败
//      所以这个时候我们可以主动调用支付宝端的查单接口来向支付宝确认支付结果
        if (AliPayTradeState.SUCCESS.getType().equals(tradeStatus)){
            log.info("核实订单已支付 ===》{}", orderNo);
//          修改订单的状态
            orderInfoService.updateStatusByOrderNo(orderNo, OrderStatus.SUCCESS);
            Map<String, String> params = JSON.parseObject(resultJson.getJSONObject("alipay_trade_query_response").toJSONString(), new TypeReference<Map<String, String>>() {
            });
//          记录支付日志
            paymentInfoService.createPaymentInfoForAliPay(params);
        }
    }
```









# 五、退款









# 六、退款查询



# 七、对账


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































