# RabbitMQ的可靠性

[TOC]

# 一、可靠性

![image-20240514140349680](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240514140349680.png)

支付服务向HIS服务发送请求，扣除用户余额

之后支付服务向消息队列发送消息通知，这个过程可能出现网络异常；消息代理向交易服务发送消息，也可能出现网络异常或者是消息队列直接挂掉；交易服务执行的执行的时候可能执行失败，这三种情况都会导致交易服务中的订单状态是未支付，导致整个业务都出现了状态不一致的情况

简单的说，**发送了一条消息，但是这条消息没有被成功消费**。

> 没有被消息的原因：消费者、请求转发者把消息弄丢，或者是交易服务执行消息的时候执行失败了，但是这条消息已经被消费了

**消息的可靠性就是保证消息发送出去之后至少被消费一次**



# 二、生产者可靠性

## 2.1 生产者重连

有时候由于网络的波动，可能会出现客户端连接MQ失败的情况，通过配置我们可以开启连接失败后的重连机制：

> 生产者向MQ发送消息，结果网络出现问题，连接不上MQ，此时发送直接失败了
>
> 所以我们开启了一个连不上之后的一个失败重连

```yaml
spring:
  rabbitmq:
    #设置MQ的连接超时时间 （假如说向MQ发送消息发了1s以上，就认为超时）      
    connection-timeout: 1s
    template:
      #重试
      retry:
        #开启超时重试机制  
        enabled: true
        #失败后的初始等待时间
        initial-interval: 1000ms
        #失败后下次的等待时长倍数， 下次等待时长=interval*multiplier
        #假如multiplier是2的话，那第一次失败等1s，第二次等2s，第三次等4s
        multiplier: 1
        #最大重试次数
        max-attempts: 3
```



当网络不稳定的时候，利用重试机制可以有效提高消息发送的成功率。**不过SpringAMQP提供的重试机制是阻塞式的重试，也就是说多次重试等待的过程中，当前线程是被阻塞的，会影响业务性能**。

如果对于业务性能有要求，建议禁用重试机制。如果一定要使用，请合理配置等待时长和重试次数，当然也可以考虑使用异步线程来执行发送消息的代码。

> 其实我们用MQ的目的就是效率好，异步，无需等待
>
> 但是这种方式反而却让效率降低了



## 2.2 生产者确认

### 2.2.1 原理

**RabbitMQ有Publisher Confirm和Publisher Return两种确认机制**

> 开启确认机制后，在MQ成功收到消息后会返回确认消息给生产者

**返回的结果如下所示**：

1. **消息投递到了MQ，但是路由失败。此时会通过Publisher Return返回路由异常原因，然后返回ACK，告知投递成功**

> 生产者确实投递到MQ了，但是在MQ上路由失败了
>
> 这种路由失败可能是因为routing key填写的不正确导致的或者是交换机没有绑定
>
> 这种情况大概率是由于开发者导致的，也大概率能避免

![image-20240515143311744](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240515143311744.png)

2. **临时消息投递到了MQ，并且入队成功，返回ACK，告知投递成功**

   > 这个地方强调了一个临时消息  
   >
   > non durable 是非持久的、临时的

   如果我们投递的消息时一个临时消息，到达非持久化的队列，消息在入队的那一刻就会立即返回一个ACK给我们的生产者



3. **持久化消息投递到了MQ，并且入队完成持久化，返回ACK，告知投递成功**

   此时消息不仅仅要进入队列，还要持久化保存到磁盘，之后才会向生产者返回ACK

![image-20240515144227667](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240515144227667.png)



4. **以上三种情况都认为投递成功了，除了其他情况都会返回NACK，告知投递失败**

 

### 2.2.2 代码实现

我们应该接收publisher给MQ的响应

* **同步等待MQ的响应，等不到一直卡在这里**
* **异步的接收MQ的响应，之后进行处理即可**



1. **在publisher服务的application.yaml中添加配置**

publisher-confirm-type有三种模式：

* none：关闭confirm机制
* simple：同步阻塞等待MQ的回执消息
* correlated：MQ异步回调方式返回回执消息

```yaml
spring:
  rabbitmq:
    #开启publisher confirm机制并设置confirm类型
    publisher-confirm-type: correlated
    #开启publisher returns机制 这个实在路由失败时返回消息
    publisher-returns: true
```



2. **每个RabbitMQTemplate中只能配置一个Return Callback，我们注入一个Bean即可**

```java
/**
 * ApplicationContextAware是spring提供的和Aware有关的一系列的东西 Aware是通知的意思
 * 当Spring容器初始化完毕的时候，会检查一下哪一些类实现了这个接口，就会去调用这些类中的方法，并且会把ApplicationContext传到方法里面
 */
@Slf4j
@Configuration
public class CommonConfig implements ApplicationContextAware {
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        RabbitTemplate rabbitTemplate = applicationContext.getBean(RabbitTemplate.class);
        //设置ReturnCallback
        rabbitTemplate.setReturnsCallback(new RabbitTemplate.ReturnsCallback() {
            //message 消息本身 replyCode响应的状态码 replyText响应的消息 Exchange交换机 routingKey路由信息
            @Override
            public void returnedMessage(ReturnedMessage returnedMessage) {
                log.debug("收到消息的Return Callback，exchange:{},routingKey:{},ReplyCode:{},ReplyText:{},message:{},",
                        returnedMessage.getExchange(), returnedMessage.getRoutingKey(),
                        returnedMessage.getReplyCode(), returnedMessage.getReplyText(),
                        returnedMessage.getMessage());
            }
        });
    }
}

```

3. **Confirm Callback是在每一个消息发送时单独的指定**

因为每个消息都应该有自己的通知，

```java
@Test
void testConfirm() throws InterruptedException {
    //1.创建cd
    //CorrelationData里面首先要有一个uuid，是当前消息的一个标识，每一次发消息都要有这样的一个data，这样以来到达MQ以后才能分辨哪个是哪个消息，防止消息之间产生混乱
    CorrelationData correlationData = new CorrelationData(UUID.randomUUID().toString());
    //2.添加
    //回调方面，我们采用了JDK中的Future（直接一段代码得到一个Future，但是拿到Future的那一刻，并没有拿到结果，因为是异步的，等执行成功后，才能从中取出结果），为其添加一个消息ConfirmCallback
    correlationData.getFuture().addCallback(new ListenableFutureCallback<CorrelationData.Confirm>() {
        //此ConfirmCallback有两个结果，onSuccess是成功onFailure是失败，但是这个失败不是ACK也不是NACK，而是指Spring内部在处理的时候失败了，这个失败和MQ没有任何的关系，这种失败一般情况下是不会触发的；
        @Override
        public void onFailure(Throwable ex) {
            log.error("消息回调失败", ex);
            System.out.println("消息回调失败"+ex);
        }

        //onSuccess是指MQ的回调成功了
        @Override
        public void onSuccess(CorrelationData.Confirm result) {
            log.debug("收到Confirm Callback回执");
            System.out.println("收到Confirm Callback回执");
            if (result.isAck()){
                log.debug("消息发送成功");
                System.out.println("消息发送成功");
            }else {
                log.debug("消息发送失败，原因：{}",result.getReason());
                System.out.println("消息发送失败"+result.getReason());
            }
        }
    });

    rabbitTemplate.convertAndSend("hmall.direct", "red", "hello", correlationData);//直接向队列发送消息

   Thread.sleep(5000); //睡眠等待回执

}
```

**效果图**

![image-20240515180038839](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240515180038839.png)

**模拟路由失败时**

```java
rabbitTemplate.convertAndSend("hmall.direct", "red5", "hello", correlationData);//直接向队列发送消息
```

返回消息如下所示，但是注意，Confirm Callback中依然是ACK

![image-20240515180709035](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240515180709035.png)





# 三、MQ可靠性

生产者的可靠性确保了消息一定能够到达MQ队列，MQ本身如果把消息弄丢了怎么办？

在默认情况下，**RabbitMQ会将接收到的信息保存在内存中以降低消息收发的延迟。这样会导致两个问题**：

* **MQ重启或者宕机了，内存中的消息会丢失**

* **内存空间有限，当消费者故障或处理过慢时，会导致消息积压，引发MQ堵塞（page out），其他消息就会发送不过去**

  新发的消息就会卡在这里

![image-20240517140534146](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240517140534146.png)

MQ的地方会做pageout的处理，将先发的消息落到磁盘上去，就会腾出一部分内存空间，而做这个操作的过程当中，整个MQ是堵塞的，再来新的请求是无法执行的

![image-20240517140751357](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240517140751357.png)

当pageout的处理完后，会再处理新的消息

![image-20240517140825917](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240517140825917.png)



为了解决上面两个问题，要通过**数据持久化、改变队列的模式**

> 在MQ3.6之前会采用数据持久化
>
> 3.6之后提出了一个新的功能Lazy Queue也可以解决上面的问题



## 3.1 数据持久化

1. **交换机持久化**

创建交换机的是时候有一个Durable属性，是持久化的

> 我们在spring当中创建的交换机和队列，都是持久的

Transient表示临时交换机，重启之后交换机就没有了

![image-20240517141425979](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240517141425979.png)



2. **队列持久化**

![image-20240517141842604](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240517141842604.png)

3. **消息的持久化**

> Spring默认发的消息就是持久化的

需要在发消息时填写一个信息，将deliver_mode改成2

![image-20240517142008086](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240517142008086.png)

在目前的控制台上，直接向队列发送消息时，就会有一个deliver_mode

![image-20240517142223588](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240517142223588.png)

* **下面向MQ发送一百万条非持久化消息**

> 验证的时候记得把生产确认关闭，效率会有所下降

```java
@Test
void etstPageOut() {
    Message message = MessageBuilder.withBody("hello".getBytes(StandardCharsets.UTF_8))
            .setDeliveryMode(MessageDeliveryMode.NON_PERSISTENT)//设置消息为非持久化的
            .build();

    for (int i = 0; i < 1000000; i++) {
        rabbitTemplate.convertAndSend("simple.direct", message);//直接向队列发送消息

    }
}
```

结果如下所示，进入RabbitMQ内存的有五十多万，pageout出去了四十多万

并且在出现pageout的时候，消息处理速度的峰值降到了0

![image-20240517143708256](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240517143708256.png)



* **下面向MQ发送一百万条持久化消息**

```java
@Test
void etstPageOut() {
    Message message = MessageBuilder.withBody("hello".getBytes(StandardCharsets.UTF_8))
            .setDeliveryMode(MessageDeliveryMode.PERSISTENT)//设置消息为持久化的
            .build();

    for (int i = 0; i < 1000000; i++) {
        rabbitTemplate.convertAndSend("simple.direct", message);//直接向队列发送消息

    }
}
```

Persistent是消息进入到磁盘了，如下图所示，消息都会进入磁盘，没有一条消息做page out，消息的处理虽然有下降（因为做了磁盘的io），但是没有出现消息处理为0的时候（处理结束的时候，结束的时候肯定为0）

![image-20240517144434760](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240517144434760.png)





## 3.2 Lazy Queue

> 从RabbitMQ的3.6.0版本开始，增加Lazy Queue惰性队列概念

**惰性队列的特性如下所示**：

* **接收到消息后直接存入磁盘而非内存**

  内存中只保留最近的消息，默认2048条

  如果数据超过2048条后，读取稍微会慢一点点

* **消费者要消费消息时才会从磁盘中读取并加载到内存**

* **支持数百万条的消息存储**

> 在3.12版本后，所有队列都是Lazy Queue模式，无法更改，没有纯内存的模式

1. **控制台的方式创建Lazy Queue**

   点击“Lazy mode”，选中后会自动给队列添加x-queue-mode参数，类型是lazy

![image-20240517151053683](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240517151053683.png)

创建完成之后会多了一个“Args”参数

![image-20240520103312567](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240520103312567.png)

接下来向这个队列发送消息

```java
@Test
void etstPageOut() {
    Message message = MessageBuilder.withBody("hello".getBytes(StandardCharsets.UTF_8))
            .setDeliveryMode(MessageDeliveryMode.NON_PERSISTENT)//设置消息为非持久化的
            .build();

    for (int i = 0; i < 1000000; i++) {
        rabbitTemplate.convertAndSend("lazy.queue", message);//直接向队列发送消息

    }
```

最终我们在控制台发现，消息直接在PageOut里，并没有经过从In memory再到PageOut的过程

我们可以看publish数据的图，虽然一直再往磁盘里写，但是并没有影响publish写的效率，没有出现堵塞的情况

![image-20240520104215318](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240520104215318.png)

2. **代码的方式创建Lazy队列**

   设置一个队列为惰性队列，只需要在生命队列时，指定x-queue-mode属性为lazy即可

```java
@Bean
public Queue lazyQueue(){
    return QueueBuilder
        .durable("lazy.queue")//lazy.queue是我们的队列
        .lazy()//开启Lazy模式
        .build();
}
```

​     **也可以用注解的方式**

之前我们只有name队列和durable持久化，现在多加了一个arguments参数，在里面可以指定键值对

```java
@RabbitListener(queuesToDeclare=@Queue(
      name = "lazy.queue",
      durable= "true",
    arguments=@Argument(name="x-queue-mode",value="lazy")
))
public void listenLazyQueue(String mes){
    log.info("接收到 lazy.queue的消息：{}",msg);
}
```



## 3.3 总结

**RabbitMQ如何保证消息的可靠性**

* **首先通过配置可以让交换机、队列以及发送的消息都持久化**

  这样队列中的消息会持久化到磁盘，MQ重启消息依然存在



* **RabbitMQ在3.6版本引入了LazyQueue，并且在3.12版本后会成为队列的默认模式**

  LazyQueue会将所有的消息都持久化



* **开启持久化和生产者确认时，RabbitMQ只有在消息持久化完成后才会给生产者返回ACK回执**



# 四、消费者可靠性

消息到达消费者之后，消费者也可能会由于种种原因导致消息丢失



## 4.1 消费者确认机制

为了确认消费者是否成功处理消息，RabbitMQ提供了消费者确认机制

**当消费者处理消息结束后，应该向RabbitMQ发送一个回执，告知RabbitMQ自己消息处理状态**

**回执**有三种可选值：

* **ack**：

  成功处理消息，RabbitMQ从队列中删除改消息

* **nack**：

  消息处理失败，RabbitMQMQ需要再次投递消息

* **reject**：

  消息处理失败并拒绝该消息，RabbitMQ从队列中删除该消息

  这种情况消息本身是有问题的，比如消息的格式错误，导致代码运行过程中报错

![image-20240520105942244](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240520105942244.png)

> 这种回执Spring已经帮我们封装好了，如果我们数据的处理过程中是成功的，会自动帮我们去向RabbitMQ发送成功的ack回执；如果数据的处理过程中发生了异常，会发送nack或者reject回执。
>
> 失败的时候发送nack或者reject，取决于异常的类型，如果是普通运行异常就是nack，如果是请求参数异常就会reject



**SpringAMQP已经实现了消息确认功能，并允许我们通过配置文件选择ACK处理方式**

* **none**：

  不处理，即消息投递给消费者后立刻ack，消息会立刻从MQ删除，非常不安全，不建议使用

  ```yaml
  spring:
    rabbitmq:
      listener:
        simple:
          prefetch: 1
          acknowledge-mode: none 
  ```

  

* **manual**：

  手动处理。需要自己在业务代码中调用api，发送ack或reject，存在业务入侵，但更灵活

  ```yaml
  spring:
    rabbitmq:
      listener:
        simple:
          prefetch: 1
          acknowledge-mode: manual 
  ```

  

* **auto**：

  自动模式，SpringAMQP利用AOP对我们的消息处理逻辑做了环绕增强，当业务正常执行时则自动返回ack，当业务出现异常时，根据异常判断返回不同的结果

  * 业务异常返回nack
  * 消息处理或者校验异常(如消息转换异常MessageConversionException)，自动返回reject

  ```yaml
  spring:
    rabbitmq:
      listener:
        simple:
          prefetch: 1
          acknowledge-mode: auto 
  ```



## 4.2 消费者失败处理

### 4.2.1 介绍

> 我们使用auto自动模式，让消息处理失败后给RabbitMQ回调nack，之后RabbitMQ又给我们的消费者发送，之后再消息处理失败向RabbitMQ回调nack......这样来回折腾消息，会给我们的系统带来一个很大的压力

现在我们考虑，消息失败后要不要直接扔回到MQ

当消费者出现异常后，消息会不断requeue重新入队到队列，再重新发送给消费者，然后再次异常，再次requeue，无限循环导致MQ的消息处理飙升，带来不必要的压力。

**我们利用Spring的retry机制，在消费者出现异常时利用本地重试，而不是无限制的requeue到MQ队列**

> 当消费者接收到MQ的消息后，运行失败了，此时不会将消息扔回MQ，而是现在本地重试一下

**配置本地重试机制**

```yaml
spring:
  rabbitmq:
    listener:
      simple:
        prefetch: 1
        acknowledge-mode: none
        retry:
          #开启消费者失败重试机制
          enabled: true
          #失败后的初始等待时间
          initial-interval: 1000ms
          #失败后下次的等待时长倍数， 下次等待时长=interval*multiplier
          multiplier: 1
          #最大重试次数
          max-attempts: 3
          stateless: true #true无状态，false有状态，如果业务中包含事物，这里改为false
```

但是经过我们的测试，如果在本地重试的次数超过3次后，就会把次消息扔了，RabbitMQ中也没有了

这种确实不太好，没有进行来回投

**重试多次依然失败该怎么做**？

在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有MessageRecoverer接口来处理，包含三种不同的实现：

* **RejectAndDontRequeueRecoverer**

  重试耗尽后，直接Reject，丢弃消息，默认就是这种方式

  

* **ImmediateRequeueMessageRecoverer**

  重试耗尽后，返回nack，消息重新入队

  

* **RepublishMessageRecoverer**

  重试耗尽后，将失败消息投递到指定的交换机

  ![image-20240520170934549](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240520170934549.png)

### 4.2.2 RepublishMessageRecoverer

将失败处理策略改为RepublishMessageRecoverer

1. **定义接收失败消息的交换机、队列及其绑定关系**

```java
//交换机
@Bean
public DirectExchange errorExchange() {
    // 交换机名称error.direct
    return new DirectExchange("error.direct");
}

//定义队列
@Bean
public Queue errorQueue() {
    return new Queue("error.queue");
}

// 绑定
@Bean
public Binding errorBinding(Queue errorQueue,DirectExchange errorExchange){
    //"error"是交换机和队列绑定的那个key
    return BindingBuilder.bind(errorQueue).to(errorExchange).with("error");
}
```

2. **定义RepublishMessageRecoverer**

```java
//配置消息转换
@Bean
public MessageRecoverer messageRecoverer(RabbitTemplate rabbitTemplate){
    //RabbitTemplate是AmqpTemplate的子类
    return new RepublishMessageRecoverer(rabbitTemplate,"error.direct","error");
}
```

3. **上面这些配置，我们希望在没开启失败重试机制的时候，不注入下面的Bean**

```java
@Configuration
//@ConditionalOnProperty当某个属性满足条件时会生效
@ConditionalOnProperty(prefix = "spring.rabbitmq.listener.simple.retry",
        //当spring.rabbitmq.listener.simple.retry.enabled=true的时候，会加载下面的配置
        name = "enabled",
        havingValue = "true")
public class ErrorConfiguration {
.............
}
```



### 4.2.3 总结

* **开启消费者确认机制为auto，由Spring确认消息处理成功后返回ack，异常时返回nack**
* **开启消费者失败重试机制，并设置MessageRecoverer，多次重试失败后将消息投递到异常交换机，最后人工处理**





## 4.3 业务幂等性

> 上面的方法已经能够确保消息至少被消费一次
>
> 我们将项目部署之后，消费者最终会消费几次消息是不能确定的，因为我们有一个重试机制
>
> 假如因为网络波动，消费者消费成功了，但是因为某种原因我们认为他没消费成功，此时一个消息就可能被处理多次，一条消息消费者重复消费成功了好几次

**当出现重新消费时，我们的业务必须得保证能够做到业务幂等性**

> 幂等是一个数学概念，用函数表达式来描述是f(x)=f(f(x))
>
> 在程序开发中，则是指同一个业务执行一次或多次对业务状态的影响是一致的

我们应该让所有的任务都保证幂等性，防止多次执行成功

![image-20240523105900075](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240523105900075.png)



### 4.3.1 基于消息id

* **方案1**

1. 每一次消息都生成一个唯一id，与消息一起投递给消费者
2. 消费者接收到消息后处理自己的业务，业务处理成功后将消息id保存到数据库
3. 如果下次又收到相同的消息，去数据库查询判断是否存在，存在则为重复消息放弃处理

> 在生产者和消费者中添加下列的配置

```java
@Bean
public MessageConverter messageConverter() {
    //import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;
    //1.定义消息转换器
    Jackson2JsonMessageConverter jjmc = new Jackson2JsonMessageConverter();
    //2.配置自动创建爱你消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息
    jjmc.setCreateMessageIds(true);//改成true后，会自动生成消息ID
    return jjmc;
}
```

此时发送消息的信息，如下所示，与之前相比，多了一个message_id字段

![image-20240523112605798](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240523112605798.png)

> **存在的问题**
>
> 需要在业务方法中做一些额外的事情，比如向数据库中检查消息是否被处理过之类的，存在业务侵入



### 4.3.2 基于业务逻辑

* **方案2**

**结合业务逻辑，基于业务逻辑本身做判断**

> 需要在支付后修改订单状态为已支付，应该在修改订单状态前查询订单状态，判断状态是否是未支付。只有未支付订单才需要修改，其他状态不需要修改

![image-20240523113236715](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240523113236715.png)

**如下所示的实现**，是保证业务幂等的一个方法

```java
@Component
@RequiredArgsConstructor
public class PayStatusListener{
    private final IOrderService orderService ;
    
    @RabbitListener(bindings=@QueueBinding(
        value=@Queue(name="mark.order.pay.queue",durable="true"),
        exchange=@Exchange(name="pay.topic",type=ExchangeTypes.TOPIC),
        key="pay.success"
    ))
    public void listenOrderPay(Long orderId){
        //1.查询订单
        Order order = orderService.getById(orderId);
        //2.判断状态是否是未支付 (status!=1 表示非未付款)
        if(order==null || order.getStatus() !=1){
            //订单不存在或状态异常
            return;
        }
        // 下面其实只处理未付款的情况
        //3.如果未支付，标记订单状态为已支付
        orderService.markOrderPaySuccess(orderId);
    }
    
}
```

上面的代码是当Status为1的时候，我们会利用一个乐观锁的方式（更新订单状态）将数据库中的此条方式锁住。

但是这种方式是有并发的安全问题，假如两条消息时一起来的，也就是两个线程，同时查询的数据库发现订单是未支付，就会并行修改订单的状态为已支付，虽然并行修改同一个数据的同一个值没什么影响，但是从逻辑上来说是有问题的，也就是**出现并发修改的情况**

**上面的情况可以用一条非常简单的SQL语句解决**

```sql
update order set status = 2 where id = ? and status = 1 
```



```java
@Component
@RequiredArgsConstructor
public class PayStatusListener{
    private final IOrderService orderService ;
    
    @RabbitListener(bindings=@QueueBinding(
        value=@Queue(name="mark.order.pay.queue",durable="true"),
        exchange=@Exchange(name="pay.topic",type=ExchangeTypes.TOPIC),
        key="pay.success"
    ))
    public void listenOrderPay(Long orderId){
        //一条SQL语句解决的业务逻辑
        orderService.lambdaUpdate()
            .set(Order::getStatus,2)
            .set(Order::getPayTime,LocalDateTime.now())
            .eq(Order::getId,orderId)
            .eq(Order::getStatus,1)
            .update();
    }
    
}
```





### 4.3.3 总结

**如何保证支付服务与交易服务之间的订单状态一致性**？

* 首先，支付服务会正在用户支付成功以后利用MQ消息通知交易服务完成订单状态同步。
* 其次，为了保证MQ消息的可靠性，我们采用了生产者确认机制、消费者确认、消费者失败重试（这种也可以作为兜底方案）等策略，确保消息投递和处理的可靠性。同时也开启了MQ的持久化，避免因服务者机导致消息丢失。
* 最后，我们还在交易服务更新订单状态时做了业务幂等判断，避免因消息重复消费导致订单状态异常。



**如果交易服务消息处理失败了，有没有什么兜底方案**？

* 我们可以在交易服务设置定时任务，定期主动查询订单支付状态。这样即便MQ通知失败，还可以利用定时任务作为兜底方案，确保订单支付状态的最终一致性。

