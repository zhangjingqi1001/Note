# 使用Mybatis调用存储过程

> **存储过程知识点**：[MySQL — 视图、存储过程、触发器_我爱布朗熊的博客-CSDN博客](https://blog.csdn.net/weixin_51351637/article/details/130922940?ydreferer=aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTM1MTYzNy9jYXRlZ29yeV8xMjMxMTY3My5odG1sP3NwbT0xMDAxLjIwMTQuMzAwMS41NDgy)



# 一、获取存储过程的返回单个值



## 1.1 存储过程

```sql
create procedure p4(in score int,out result varchar(10))
 begin
 
  if score >= 85 then
     set result := '优秀';
  elseif score >= 60 then
     set result := '及格';
  else
     set result := '不及格';
  end if;
```



## 1.2 Mapper 层

```java
//  测试调用存储过程
   void checkScore(Map<String,Object> param);
```



```xml
<select id="checkScore" statementType="CALLABLE" >
    {
        call p4(#{score, mode=IN, jdbcType= INTEGER}, #{result , mode=OUT, jdbcType=VARCHAR})
        }
</select>
```

(#{score, mode=IN, jdbcType= INTEGER} 表示**存储过程的入参**

* score： 入参名称 
* mode=IN ： 表示这个参数是一个入参
* jdbcType= INTEGER：表示入参的类型是一个INTEGER

#{result , mode=OUT, jdbcType=VARCHAR}) 表示**存储过程的出参**

* result：表示输出参数的名称
* mode=OUT： 表示该参数是一个输出参数
* jdbcType=VARCHAR：表示返回结果的类型是一个VARCHAR



> 我试了试，如果将result返回结果jdbcType=VARCHAR删除掉，就会报错
>
> 而score加不加score影响不大
>
> ![image-20230831141518998](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230831141518998.png)



### 1.2.1 关于jdbcType

> `jdbcType` 是用于指定数据库列的 JDBC 类型的属性。它用于在映射文件（XML）或注解中提供关于参数与结果集的类型信息
>
> 常用的jdbcType值
>
> BIT              FLOAT         CHAR               TIMESTAMP       OTHER       UNDEFINED
>
> TINYINT     REAL            VARCHAR        BINARY               BLOB         NVARCHAR
>
> SMALLINT  DOUBLE     LONGVARCHAR    VARBINARY   CLOB        NCHAR
>
> INTEGER     NUMERIC    DATE           LONGVARBINARY   BOOLEAN     NCLOB
>
> BIGINT        DECIMAL    TIME             NULL            CURSOR

* **注意！！！使用的时候jdbcType的值一定要是大写的**

在mybatis的mapper文件中jdbcType属性底层对应的是一个JdbcType枚举类，所以jdbcType属性的值对应的都是大写

* **jdbcType属性并不是在任何时候都需要设置的**

一般情况下是在值可能为空时设置，确定值不为空时，可以不设置



### 1.2.2 jdbcType用法

* **参数映射**

在映射文件或注解中指定参数类型时，可以使用 `jdbcType` 属性来告诉 MyBatis 使用哪种 JDBC 类型来映射该参数

例如，如果你有一个 Java 对象的属性类型是 `java.util.Date`，而该属性对应的数据库列类型是 `TIMESTAMP`，你可以使用 `jdbcType` 属性来指定为 `TIMESTAMP`，以便 MyBatis 可以正确地映射参数。

**XML方式**

```xml
<insert id="insertUser" parameterType="User">
  INSERT INTO users (id, name, created_at)
  VALUES (#{id}, #{name}, #{createdAt, jdbcType=TIMESTAMP})
</insert>

```

**注解方式**

```java
@Insert("INSERT INTO users (id, name, created_at) VALUES (#{id}, #{name}, #{createdAt, jdbcType=TIMESTAMP})")
void insertUser(User user);

```

* **结果映射**

告诉 MyBatis 应该使用哪种 JDBC 类型来映射结果。

你想将一个数据库列的类型映射到一个 Java 对象的属性类型上

```xml
<resultMap id="userResultMap" type="User">
  <result property="id" column="id" jdbcType="INTEGER"/>
  <result property="name" column="name" jdbcType="VARCHAR"/>
  <result property="createdAt" column="created_at" jdbcType="TIMESTAMP"/>
</resultMap>

```



```java
@Results(id = "userResultMap", value = {
    @Result(property = "id", column = "id", jdbcType = JdbcType.INTEGER),
    @Result(property = "name", column = "name", jdbcType = JdbcType.VARCHAR),
    @Result(property = "createdAt", column = "created_at", jdbcType = JdbcType.TIMESTAMP)
})
```





## 1.3 测试

```java
Map<String,Object> paramMap = new HashMap<>();
paramMap.put("score",60);

billMapper.checkScore(paramMap);

Object result = paramMap.get("result");

System.out.println(result);
```

及格

![image-20230831111547001](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230831111547001.png)



**但是这个地方，我并没有在paramMap中增加一个键为“result”的数据，为什么还能获取到呢**？

> result是我们在存储过程中定义的返回结果的名称

paramMap作为Mapper接口的参数，这个参数中的key和value可以与存储过程中的参数名称进行匹配

对于输入的参数，Mybatis会通过参数名称"score"将值"60"传递给存储过程的“score”参数

对于输出的参数，Mybatis会自动将存储过程的输出参数（OUT参数）的值放置在Map\<String, Object\>类型的参数对象中。

**这是因为MyBatis使用参数名称作为键，参数值作为值，将存储过程的输出结果映射到参数对象中**。

当执行带有输出参数的存储过程时，MyBatis会自动将输出参数的值设置到该Map对象中，以键值对的形式存储

MyBatis会执行存储过程并将输出参数的值设置到param对象中。这样，就可以通过访问param对象来获取存储过程执行后的输出参数值



# 二、存储过程返回查询结果（List）

## 1.1 存储过程

我们的这个存储过程有一个入参score，一个返回值result，还有一个查询select

```sql
create procedure p5(in score int,out result varchar(10))
 begin
 
  if score >= 85 then
     set result := '优秀';
  elseif score >= 60 then
     set result := '及格';
  else
     set result := '不及格';
  end if;
	
	select * from auth_info;
	 
 end;

call p5(10,@result);

select @result
```



## 1.2 Mapper

这个地方返回的是某个对象的集合，如果我们想返回某个对象也可以，改一下存储过程中的SQL

```java
public List<Auth> checkScoreAndGetAuth(Map<String,Object> param);
```

一定要记得添加 statementType="CALLABLE" ，否则会报错

```xml
<select id="checkScoreAndGetAuth" statementType="CALLABLE" resultType="com.pn.entity.Auth">
    {
        call p5(#{score, mode=IN,jdbcType=INTEGER}, #{result , mode=OUT, jdbcType=VARCHAR})
    }
</select>
```



## 1.3 测试

```java
Map<String,Object> paramMap = new HashMap<>();
paramMap.put("score",60);

List<Auth> authList = authMapper.checkScoreAndGetAuth(paramMap);

Object result = paramMap.get("result");

System.out.println(result);
System.out.println(authList);
```

select语句也能输出出来

![image-20230831144705683](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230831144705683.png)







# 三、ResultMap结果集

## 3.1 简单属性映射

将数据库查询结果的列映射到Java对象的属性

property指的是实体类User中的字段，column指的是数据库表中字段

```xml
<resultMap id="userResultMap" type="User">
  <id property="id" column="id" />
  <result property="username" column="username" />
  <result property="email" column="email" />
</resultMap>

```



## 3.2 嵌套对象映射

User对象中包含一个Address对象，可以进行嵌套映射

如下所示，我们将city、state、country三个字段封装到了Address类型的address属性中

```xml
<resultMap id="userResultMap" type="User">
  <id property="id" column="id" />
  <result property="username" column="username" />
  <result property="email" column="email" />
    
  <association property="address" javaType="Address">
    <result property="city" column="city" />
    <result property="state" column="state" />
    <result property="country" column="country" />
  </association>
    
</resultMap>

```



## 3.3  集合属性映射

将查询结果的多个行映射到一个集合属性，通常使用在一对多关系的映射中。

例如，一个User对象包含多个Order对象

```xml
<resultMap id="userResultMap" type="User">
  <id property="id" column="id" />
    
  <result property="username" column="username" />
  <result property="email" column="email" />
    
  <collection property="orders" ofType="Order">
    <id property="orderId" column="order_id" />
    <result property="orderDate" column="order_date" />
    <result property="orderAmount" column="order_amount" />
  </collection>
    
</resultMap>

```



## 3.4 Discriminator映射

> Discriminator 是一个用于根据不同条件选择不同 ResultMap 进行映射的工具
>
> 可以根据查询结果的某个列的值来决定使用哪个 ResultMap 进行进一步的属性映射



* **创建不同的 ResultMap**

创建三个不同的 ResultMap，分别映射用户对象的不同类型

```xml
<resultMap id="adminResultMap" type="User">
  <!-- AdminUser 类型相关映射定义 -->
</resultMap>

<resultMap id="guestResultMap" type="User">
  <!-- GuestUser 类型相关映射定义 -->
</resultMap>

<resultMap id="memberResultMap" type="User">
  <!-- MemberUser 类型相关映射定义 -->
</resultMap>

```



* **创建 Discriminator**

根据User对象的类型选择不同的ResultMap

> 在 Discriminator 中，你需要指定要检查的列以及每个条件对应的 ResultMap

当查询结果中的 "user_type" 列的值与某个条件匹配时，MyBatis 将使用该条件对应的 ResultMap 对象**进行进一步的属性映射**

```xml
<resultMap id="userResultMap" type="User">
  <id property="id" column="id" />
  <result property="username" column="username" />
  <result property="email" column="email" />
    
  <discriminator javaType="Integer" column="user_type">
    <case value="1" resultMap="adminResultMap" />
    <case value="2" resultMap="guestResultMap" />
    <case value="3" resultMap="memberResultMap" />
  </discriminator>
    
</resultMap>

```



* **使用 ResultMap 进行查询**

根据 "user_type" 列的值，MyBatis 使用相应的 ResultMap（如 "adminResultMap"、"guestResultMap"、"memberResultMap"）进行进一步的属性映射。

```xml
<select id="getUser" resultMap="userResultMap">
  SELECT id, username, email, user_type
  FROM users
  WHERE id = #{id}
</select>
```



## 3.5 @Results 注解使用

当数据库字段名与实体类对应的属性名不一致时，可以使用@Results映射来将其对应起来。

column为数据库字段名，porperty为实体类属性名，jdbcType为数据库字段数据类型，id为是否为主键

```java
@Select("select * from orders where id=#{id}")
    @Results({
            @Result(id=true,column = "id",property = "id"),
            @Result(column = "orderNum",property = "orderNum"),
            @Result(column = "orderTime",property = "orderTime"),
            @Result(column = "orderStatus",property = "orderStatus"),
            @Result(column = "peopleCount",property = "peopleCount"),
            @Result(column = "payType",property = "payType"),
            @Result(column = "orderDesc",property = "orderDesc")
    })
    Orders findById(String id) throws Exception;
```

**补充**

- @Result(id = true) - 表示该属性为主键。
- @Result(jdbcType = JdbcType.VARCHAR) - 指定列的JDBC类型。
- @Result(javaType = java.util.Date.class) - 指定属性的Java类型。
- @Result(typeHandler = MyCustomTypeHandler.class) - 指定用于处理属性值的类型处理器。





## 3.6 @ResultMap用法

当这段@Results代码需要在多个方法用到时，为了提高代码复用性，我们可以为这个@Results注解设置id，然后使用@ResultMap注解来复用这段代码

```java
@Select({"select id, name, class_id from my_student"})
@Results(id="studentMap", value={
    @Result(column="id", property="id", jdbcType=JdbcType.INTEGER, id=true),
    @Result(column="name", property="name", jdbcType=JdbcType.VARCHAR),
    @Result(column="class_id ", property="classId", jdbcType=JdbcType.INTEGER)
})
List<Student> selectAll();
 
@Select({"select id, name, class_id from my_student where id = #{id}"})
@ResultMap(value="studentMap")
Student selectById(integer id);
```













