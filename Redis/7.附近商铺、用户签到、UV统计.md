[TOC]



# 附近商铺、用户签到、UV统计

# 一、附近商铺

底层都是基于地理坐标进行搜索，支持地理坐标的技术有很多，Redis就是其中之一

## 1.1 GEO数据结构

**GEO**就是Geolocation的简写形式，代表**地理坐标**。

**Redis**在3.2版本中加入了对GEO的支持，**允许存储地理坐标信息**，帮助我们根据经纬度来检索数据。**常见的命令有**:

* **GEOADD**:添加一个地理空间信息，包含: 经度 (longitude)、纬度latitude)、值(member)

  这个值可以使任何一个东西，比如店名、数据库中的某个字段的

  ![image-20230708172439775](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230708172439775.png)

* **GEODIST**:计算指定的两个点之间的距离并返回

  可以选择返回的单位，m，km等

![image-20230708173048593](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230708173048593.png)

* **GEOHASH**:将指定member的坐标转为hash字符串形式并返回

![image-20230708174608759](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230708174608759.png)

* **GEOPOS**:返回指定member的坐标

![image-20230708174554656](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230708174554656.png)

* **GEORADIUS**:指定圆心（radius）、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.2以后已废弃

![image-20230708173454451](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230708173454451.png)

* **GEOSEARCH**:在指定范用内搜索member，并按照与指定点之间的距离排席后返回。范用可以是圆形或矩形。6.2.新功能

> 可以指定我们这个key中的某个成员作为圆心，也可以直接指定经纬度作为圆心
>
> BYRADIUS就是按照圆半径来搜索
>
> BYBOX按照矩形来搜（指定长宽之类的）
>
> COUNT表示查询多少条
>
> WITHDIST表示携带距离

![image-20230708173629747](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230708173629747.png)

* **GEOSEARCHSTORE**:与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。6.2.新功能



**需求**

**1.添加下面几条数据**

—北京南站(116.378248 39.865275）

—北京站 (116.42803 39.903738 )

—北京西站(116.322287 39.893729)

```
GEOADD g1 116.378248 39.865275 bjn 116.42803 39.903738 bjz 116.322287 39.893729 bjx
```

添加进去后发现底层的数据结构是ZSET，也就是SortedSet

下图中的value就是我们填进去的member，我们存进去的地理左边转换成了下面的一串数字，作为score传进去了

![image-20230708172720011](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230708172720011.png)



**2.计算北京南站到北京西的距离**

```
GEODIST g1 bjn bjx
```

![image-20230708173234545](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230708173234545.png)

若指定单位

```
GEODIST g1 bjn bjx km
```

![image-20230708173310446](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230708173310446.png)



**3.搜索天安门(116.397904 39.909005 )附近10km内的所有火车站，并按照距离升序排序**

```
GEOSEARCH g1 FROMLONLAT 116.397904 39.909005 BYRADIUS 10 km WITHDIST
```

![image-20230708174414172](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230708174414172.png)



## 1.2 导入店铺数据到GEO

看一下店铺表tb_shop

![image-20230708201202948](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230708201202948.png)

导入数据到GEO的时候并不是将所有的信息都导入，我们只需要导入经纬度坐标以及店铺id即可，店铺id充当GEO命令中的member

![image-20230708201517761](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230708201517761.png)

我们搜索的时候有一个限制条件，根据商户的类型做过滤，但是我们并没有把商铺的类型放入到GEO里面，所以过滤不了

为了解决这个问题，我们可以采取下面的措施：

按照商户类型做分组，类型相同的商户作为同一组，以typeId为Key存入同一个GEO集合中即可

![image-20230708202033899](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230708202033899.png)



```java
  @Resource
    private StringRedisTemplate stringRedisTemplate;

    @Test
    void loadShopData() {
//      TODO 1. 查询所有店铺信息
        List<Shop> list = shopService.list();
//      TODO 2. 把店铺分组，按照typeId分组，id一致的放到一个集合
        Map<Long, List<Shop>> map = list.stream().collect(Collectors.groupingBy(shop -> shop.getTypeId()));
//      TODO 3. 分批完成存储写入Redis
        for (Map.Entry<Long, List<Shop>> entry : map.entrySet()) {
//          TODO 3.1 获取类型id
            Long typeId = entry.getKey();
            String key = "shop:geo:" + typeId;
//          TODO 3.2 获取同类型的店铺集合
            List<Shop> value = entry.getValue();
//          TODO 3.3 写入Redis GEOADD key 经度 纬度 member
//          方法1：效率比较低，不采用
//            for (Shop shop : value) {
//              坐标我们可以一个个指定，也可以直接new一个Point对象
//              stringRedisTemplate.opsForGeo().add(key,new Point(shop.getX(),shop.getY()),shop.getId().toString());
//              方法2：
//            }
//          方法2
            List<RedisGeoCommands.GeoLocation<String>> locations = new ArrayList<>();

            for (Shop shop : value) {
//          下面泛型的类型是member的类型
                locations.add(new RedisGeoCommands.GeoLocation<>(
                        shop.getId().toString(),
                        new Point(shop.getX(), shop.getY())
                ));
            }
//          批量操作
            stringRedisTemplate.opsForGeo().add(key,locations);

        }

    }
```



**结果图**：

![image-20230708210546113](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230708210546113.png)

![image-20230708210531242](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230708210531242.png)



## 1.3 实现附近商户功能

我们使用的Springboot版本不是最新的，那对应的SpringDataRedis的版本也不是最新的

SpringDataRedis的2.3.9版本并不支持Redis 6.2提供的GEOSEARCH命令，因此我们需要提示其版本，修改Pom文件

> 可以下载一个插件：Dependency Analyzer

```xml
        <!--修改其中的版本-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
            <exclusions>
                <exclusion>
                    <groupId>org.springframework.data</groupId>
                    <artifactId>spring-data-redis</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>io.lettuce</groupId>
                    <artifactId>lettuce-core</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>org.springframework.data</groupId>
            <artifactId>spring-data-redis</artifactId>
             <!--使用2.6.2也可以-->
            <version>2.7.11</version>
        </dependency>
        <dependency>
            <groupId>io.lettuce</groupId>
            <artifactId>lettuce-core</artifactId>
            <version>6.1.10.RELEASE</version>
        </dependency>
```

**接口分析图**

![image-20230708201517761](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230708201517761.png)

**Controller层**

```java
    /**
     * 根据商铺类型分页查询商铺信息
     * @param typeId 商铺类型
     * @param current 页码
     * @return 商铺列表
     */
    @GetMapping("/of/type")
    public Result queryShopByType(
            @RequestParam("typeId") Integer typeId,
            @RequestParam(value = "current", defaultValue = "1") Integer current,
            @RequestParam(value = "x",required = false) Double x,
            @RequestParam(value = "y",required = false) Double y) {
        
        return shopService.queryShopByType(typeId,current,x,y);
        
    }
```

**Service层**

```java
 @Override
    public Result queryShopByType(Integer typeId, Integer current, Double x, Double y) {
//      TODO 1.判断是否需要根据坐标查询
        if (x == null || y == null) {
            //不需要坐标查询，按数据库查询
            Page<Shop> page = query()
                    .eq("type_id", typeId)
//                   SystemConstants.DEFAULT_PAGE_SIZE)==5
                    .page(new Page<>(current, SystemConstants.DEFAULT_PAGE_SIZE));
            // 返回数据
            return Result.ok(page.getRecords());
        }

//      TODO 2.计算分页参数
//      从哪开始
        int from = (current-1)*SystemConstants.DEFAULT_PAGE_SIZE;
//      从哪结束
        int end = current*SystemConstants.DEFAULT_PAGE_SIZE;

//      TODO 3.查询redis，按照距离排序、分页。结果：shopId和distance
        String key = "shop:geo:"+typeId;
        GeoResults<RedisGeoCommands.GeoLocation<String>> results = stringRedisTemplate.opsForGeo()
//              GEOSEARCH key FROMLONLAT x y BYRADIUS 10 km WITHDIST
//              第一个参数是key，第二个参数是圆心,第三个参数是半径,我们选择半径5000米以内的
                .search(key, GeoReference.fromCoordinate(x, y), new Distance(5000),
                        RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs()
//                              这个参数代表WITHDIST
                                .includeDistance()
//                               表示第一条数据到第end条数据
                                .limit(end));
//      TODO 4.解析出ShopID
        if(results==null){
            return Result.ok();
        }
        List<GeoResult<RedisGeoCommands.GeoLocation<String>>> list = results.getContent();
        if (list.size()<from){
//            因为我们下面要执行skip操作，如果list集合中元素小于from的话，会出现sql异常
            return Result.ok(Collections.emptyList());
        }
//      TODO 4.1 截取从from到end的数据
        List<Long> ids = new ArrayList<>(list.size());
        Map<String,Distance> distanceMap = new HashMap<>(list.size());
        list.stream().skip(from).forEach(result->{
//          TODO 4.2 获取店铺id
            String shopIdStr = result.getContent().getName();
            ids.add(Long.valueOf(shopIdStr));
//          TODO 4.3 获取距离
            Distance distance = result.getDistance();
            distanceMap.put(shopIdStr,distance);
        });
//      TODO 5.根据id查询Shop
//      依然要保证有序
        String idStr = StrUtil.join(",", ids);
        List<Shop> shops = query().in("id", ids)
                .last("order by FIELD(id," + idStr + ")")
                .list();
        for (Shop shop : shops) {
            shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());
        }
//      TODO 6.返回
        return Result.ok(shops);
    }
```

**根据距离排名的效果图**

![image-20230708225322683](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230708225322683.png)













































