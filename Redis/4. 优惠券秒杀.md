[TOC]



#  Redis 实现优惠券秒杀

电商离不开秒杀，秒杀离不开Redis



# 一、优惠券秒杀

## 1.1 全局唯一ID概述

每个店铺都可以发布优惠券

![image-20230628092618341](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230628092618341.png)

当用户抢购时，就会**生成订单**并保存到tb_voucher_order这张表中，而订单表**如果使用数据库自增ID就存在一些问题**

* **id规律性太明显**

  用户可以根据id猜测到一些信息。

  比如我昨天下单了一个商品，id为10，今天下单了一个商品，id为100，那我就能猜到这段时间内售出了90件商品



* **受单表数据量的限制**

  用户只要有订单的行为，就会不断的产生新的订单。

> 当网站达到一定规模后，一年会有上千万的订单，几年后单张表就保存不了如此大规模的数据。
>
> 我们只能分成单张表存储，每张表都采用id自增的方式，显然实现不了，因为mysql每张表都是各自计算自己自增长，都从“1”开始增长，那这样的话这几张表中某些数据id可能会重复
>
> 如果id重复，以后查询订单会出现问题



**为了解决上述问题，我们可以使用全局ID生成器**

全局ID生成器，是一种**在分布式系统下用来生成全局唯一ID的工具**

> 全局的含义：在同一个业务下，不管分布式系统将来有多少个服务、多少个节点、业务下分成了多少张不同的表，只要使用全局ID生成器得到的id，一定是当前业务内唯一id，不会出现冲突
>
> 当然不同业务的id出现冲突后也没有关系
>
> 单体项目也会用到全局ID生成器



**一般要满足下列特性**

* **唯一性**

* **高可用**

  起码用着用着不能挂掉

* **高性能**

  正确的生成id，并且生成id的速度要快

* **递增新**

  要有一个单调的递增的特性。虽然不是数据库那样自增，但是我们要确保整体的id是逐渐增大的一个过程，有利于数据库创建索引

* **安全性**

  规律性不能太明显

****



我们**Redis命令中有一个incr命令**的



> [Redis命令——通用命令、String类型、Key层级结构、Hash类型、List类型、Set类型、SortedSet类型_redis多个层级命令查询_我爱布朗熊的博客-CSDN博客](https://blog.csdn.net/weixin_51351637/article/details/127477603)



首先能**确保唯一性**，因为Redis独立于数据库之外的，不论数据库有几张表、几个数据库，Redis只有一个，那这样的话所有人来访问Redis时，它的自增一定是唯一的

> 高可用、高性能、递增性不解释了



**安全性比较麻烦一点，关键看我们采用什么自增**，如果还是1,2,3,4，.....的话安全性肯定差

**为了保证安全性，我们可以拼接一些其他信息**

考虑到数据库的性能，我们id仍然采用数值类型（Long）

![image-20230628095913369](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230628095913369.png)

> **第一位**永远是0，代表我们的符号永远是正数
>
> **中间一部分**放31bit的时间戳，其实就是增加id复杂性的，为什么是31位，因为我们想要以秒为单位（我们要定义一个初始的时间为基准，比如2000年，这31位bit代表秒，算出与2000年相差多少时间即可，31位bit最多可代表69年）
>
> **最后一部分**放置序列号，也就是Redis命令incr自增的值
>
> **这样规划的话，一秒内可支持2的32次方个订单量**



****

****

**全局唯一ID生成策略**

* **UUID**：

  使用JDK自带工具类就可以生成16进制的一长串的数值，因为是16进制，所以返回的是一个字符串结构，也没有单调递增的特性

* **Redis自增**

  上面已经分析了

* **snowflake 雪花算法**

  也是采用的long类型的64位的数字，自增采用当前机器的自增，内部维护的，所以要维护一个机械id

* **数据库自增**



**Redis自增ID策略**

* **每天一个key，方便统计订单量**
* **限定自增的值，让其不超过上限**
* **ID构造是时间戳+计数器**



## 1.2 Redis实现全局唯一ID

>  位运算[学习Redis全局ID自增的时候，为什么return的时候使用了或运算就可以了完成这个操作-大数据-CSDN问答](https://ask.csdn.net/questions/7827326?spm=1001.2014.3001.5505)



**实现代码**

```java
@Component
public class RedisIdWorker {
//  2022年1月1日0时0分0秒  的 秒数
    private static final long BEGIN_TIMESTAMP = 1640995200L;

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    /**
     * id生成策略
     *
     * @param keyPrefix 业务前缀
     * @return 生成的id
     */
    public long nextId(String keyPrefix) {
//      TODO 1.生成时间戳（当前时间减去我们规定的开始时间的秒数）
        LocalDateTime now = LocalDateTime.now();
        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);
        long timestamp = nowSecond  - BEGIN_TIMESTAMP;

//      TODO 2.生成序列号
//      同一个业务不要使用同一个key，因为incr自增有限度，2的64次方
//      为了预防订单数日积月累超过2的64次方，我们可以再拼接一个日期字符串，这样做还能方便以后统计
//      TODO 2.1 获取当前日期
        String date = now.format(DateTimeFormatter.ofPattern("yyyy:MM:dd"));

//      TODO 2.2 自增长
//      返回值是Long，但是我们改成了long，改完出现警告：会有空指针问题
//      但是并不会出现空指针问题,加入此key不存在,它会在自动帮我们创建一个key
        long count = stringRedisTemplate.opsForValue().increment("icr" + keyPrefix + ":" + date);

//      TODO 拼接两部分
//      我们的返回值是long,直接拼接timestamp与count就是字符串了,不能直接拼接
//      为了解决这个问题,我们使用位运算
//      timestamp<<32 时间戳向左移动32位,把redis自增的数创建出来,空出来的数以0位补充
//      | 代表或运算，一个为真，就是真 0|0=0， 0|1=1，因为后面32位都是0，所以还是count本身
        return timestamp<<32 | count ;
    }

//    public static void main(String[] args) {
////
//        LocalDateTime time = LocalDateTime.of(2022, 1, 1, 0, 0, 0);
//        传入一个时区作为参数
//        long second = time.toEpochSecond(ZoneOffset.UTC);
//        System.out.println(second);
//    }

}
```



**下面进行测试**

测试类中进行测试，如果一直转圈的话，将Redis客户端关闭再重新连接即可

```java
@Resource
private RedisIdWorker redisIdWorker;

private ExecutorService es = Executors.newFixedThreadPool(500);

@Test
void testIdWorker() throws InterruptedException {
    CountDownLatch latch = new CountDownLatch(300);

    Runnable task = () -> {
        for (int i = 0; i < 100; i++) {
            long id = redisIdWorker.nextId("order");
            System.out.println("id = " + id);
        }
        latch.countDown();
    };
    long begin = System.currentTimeMillis();
    for (int i = 0; i < 300; i++) {
        es.submit(task);
    }
    System.out.println("laizhelile");
    latch.await();
    long end = System.currentTimeMillis();
    System.out.println("time = " + (end - begin));
}
```

![image-20230628113040239](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230628113040239.png)

![image-20230628113249355](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230628113249355.png)





## 1.3 添加优惠券

平价券与特价券。**平价券可以任意购买，而特价券需要秒杀抢购**

![image-20230628135424992](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230628135424992.png)

* **tb_voucher**: 平价优惠券的基本信息，优惠券金额、使用规则

  下表中并没有库存，任意的人都可以随意购买

![image-20230628135947536](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230628135947536.png)



* **tb_seckill_voucher**:特价优惠券库存、开始抢购时间，结束抢购时间

![image-20230628140045841](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230628140045841.png)





### 1.3.1 entity

Voucher类，里面也包含了秒杀券的关键信息，库存、开始时间、结束时间

```java
@Data
@EqualsAndHashCode(callSuper = false)
@Accessors(chain = true)
@TableName("tb_voucher")
public class Voucher implements Serializable {

    private static final long serialVersionUID = 1L;

    /**
     * 主键
     */
    @TableId(value = "id", type = IdType.AUTO)
    private Long id;

    /**
     * 商铺id
     */
    private Long shopId;

    /**
     * 代金券标题
     */
    private String title;

    /**
     * 副标题
     */
    private String subTitle;

    /**
     * 使用规则
     */
    private String rules;

    /**
     * 支付金额
     */
    private Long payValue;

    /**
     * 抵扣金额
     */
    private Long actualValue;

    /**
     * 优惠券类型
     */
    private Integer type;

    /**
     * 优惠券类型
     */
    private Integer status;
    /**
     * 库存
     */
    @TableField(exist = false)
    private Integer stock;

    /**
     * 生效时间
     */
    @TableField(exist = false)
    private LocalDateTime beginTime;

    /**
     * 失效时间
     */
    @TableField(exist = false)
    private LocalDateTime endTime;

    /**
     * 创建时间
     */
    private LocalDateTime createTime;

    /**
     * 更新时间
     */
    private LocalDateTime updateTime;
}
```



SeckillVoucher类，秒杀券类，目的补充Voucher类

```java
@Data
@EqualsAndHashCode(callSuper = false)
@Accessors(chain = true)
@TableName("tb_seckill_voucher")
public class SeckillVoucher implements Serializable {

    private static final long serialVersionUID = 1L;

    /**
     * 关联的优惠券的id
     */
    @TableId(value = "voucher_id", type = IdType.INPUT)
    private Long voucherId;

    /**
     * 库存
     */
    private Integer stock;

    /**
     * 创建时间
     */
    private LocalDateTime createTime;

    /**
     * 生效时间
     */
    private LocalDateTime beginTime;

    /**
     * 失效时间
     */
    private LocalDateTime endTime;

    /**
     * 更新时间
     */
    private LocalDateTime updateTime;
}
```







### 1.3.2  Controller

```java
/**
 * 新增秒杀券
 * @param voucher 优惠券信息，包含秒杀信息
 * @return 优惠券id
 */
@PostMapping("seckill")
public Result addSeckillVoucher(@RequestBody Voucher voucher) {
    voucherService.addSeckillVoucher(voucher);
    return Result.ok(voucher.getId());
}
```

注意！ 我们使用Voucher接收要添加的实体类的信息，包含秒杀信息





### 1.3.3 Service层

```java
@Override
@Transactional
public void addSeckillVoucher(Voucher voucher) {
    // 保存优惠券
    save(voucher);
    
    // 保存秒杀信息
    SeckillVoucher seckillVoucher = new SeckillVoucher();
    seckillVoucher.setVoucherId(voucher.getId());
    seckillVoucher.setStock(voucher.getStock());
    seckillVoucher.setBeginTime(voucher.getBeginTime());
    seckillVoucher.setEndTime(voucher.getEndTime());
    seckillVoucherService.save(seckillVoucher);
}
```



### 1.3.4 测试

请求地址：http://localhost:8081/voucher/seckill、

添加请求头：authorization，具体的值去页面复制即可

```json
{
    "shopId": 1,
    "title": "100元代金券",
    "subTitle": "周一至周五均可使用",
    "rules": "全场通用\n无需预约\n可无限叠加\n不兑现、不找零\n仅限堂食",
    "payValue": 8000,
    "actualValue": 10000,
    "type": 1,
    "stock": 10,
    "beginTime": "2022-01-25T10:09:17",
    "endTime": "2025-01-26T12:09:04"
}
```

![image-20230628143151341](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230628143151341.png)



再看一下页面的展示效果

![image-20230628144040904](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230628144040904.png)





## 1.4 优惠券秒杀下单

涉及表 tb_voucher_order 订单表

目前来说对我们最重要的就是用户id，代金券id

![image-20230628144757871](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230628144757871.png)



**案例**：下单时需要判断两点

* 秒杀是否开始或结束，如果尚未开始或已经结束则无法下单
* 库存是否充足，不足则无法下单

![image-20230628150115919](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230628150115919.png)



### 1.4.1 entity

优惠券订单实体类

```java
@Data
@EqualsAndHashCode(callSuper = false)
@Accessors(chain = true)
@TableName("tb_voucher_order")
public class VoucherOrder implements Serializable {

    private static final long serialVersionUID = 1L;

    /**
     * 主键
     */
    @TableId(value = "id", type = IdType.INPUT)
    private Long id;

    /**
     * 下单的用户id
     */
    private Long userId;

    /**
     * 购买的代金券id
     */
    private Long voucherId;

    /**
     * 支付方式 1：余额支付；2：支付宝；3：微信
     */
    private Integer payType;

    /**
     * 订单状态，1：未支付；2：已支付；3：已核销；4：已取消；5：退款中；6：已退款
     */
    private Integer status;

    /**
     * 下单时间
     */
    private LocalDateTime createTime;

    /**
     * 支付时间
     */
    private LocalDateTime payTime;

    /**
     * 核销时间
     */
    private LocalDateTime useTime;

    /**
     * 退款时间
     */
    private LocalDateTime refundTime;

    /**
     * 更新时间
     */
    private LocalDateTime updateTime;
}
```



### 1.4.2 Controller

```java
@RestController
@RequestMapping("/voucher-order")
public class VoucherOrderController {

    @Resource
    private IVoucherOrderService voucherOrderService;

    @PostMapping("seckill/{id}")
    public Result seckillVoucher(@PathVariable("id") Long voucherId) {
        return voucherOrderService.seckillVoucher(voucherId);
    }
}
```



### 1.4.3 Service

优惠券的id与秒杀优惠券的id相同

```java
  @Resource
    private ISeckillVoucherService seckillVoucherService;

    @Resource
    private RedisIdWorker redisIdWorker;

    @Override
    @Transactional
    public Result seckillVoucher(Long voucherId) {
//      TODO 1.查询优惠券
        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);
        
//      TODO 2.判断秒杀是否开始
        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {
            return Result.fail("秒杀活动尚未开始");
        }
        
//      TODO 3.判断秒杀是否结束
        if (voucher.getEndTime().isBefore(LocalDateTime.now())) {
            return Result.fail("秒杀活动已经结束");
        }

//      TODO 4.判断库存是否充足
        if (voucher.getStock() < 1) {
            return Result.fail("库存不足");
        }
        
//      TODO 5.扣减库存
        boolean success = seckillVoucherService.update()
                .setSql("stock = stock-1")
                .eq("voucher_id", voucherId)
                .update();
        if (!success) {
            return Result.fail("扣减失败，可能库存不足");
        }
        
//      TODO 6.创建订单
//      我们只管订单id，代金券id，下单用户id
        VoucherOrder voucherOrder = new VoucherOrder();
        
//      TODO 6.1 订单id
//      使用自定义id生成器生成id
        long orderID  = redisIdWorker.nextId("order");
        voucherOrder.setId(orderID);
        
//      TODO 6.2 用户id
//      我们之前编写的登录拦截器
        UserDTO user = UserHolder.getUser();
        voucherOrder.setUserId(user.getId());
        
//      TODO 6.3 代金券id
        voucherOrder.setVoucherId(voucherId);

        save(voucherOrder);
        
//      TODO 7.返回订单id
        return Result.ok(orderID);
    }
```



>  可以看一下这篇文章，有对UserHolder登录拦截器的讲解
>
> [基于Session实现短信登录_c# 短信验证码登录_我爱布朗熊的博客-CSDN博客](https://blog.csdn.net/weixin_51351637/article/details/127519489)



### 1.4.3 测试

订单表中出现了数据

![image-20230628153853800](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230628153853800.png)

并且秒杀优惠券的数量也减少了1

![image-20230628154107655](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230628154107655.png)



## 1.5 库存超卖问题

真实的秒杀场景下，有无数的用户一起抢购，点击按钮，每秒钟的并发量可能成百上千

我们使用Jmeter来测试一下刚刚的程序，创建200个线程抢购优惠券，但是数据库中优惠券的数量为100，按理说应该有100个人抢不到

但是看一下最终结果图，发现有45%的人失败了，按理说应该是50%呀

![image-20230628154619135](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230628154619135.png)

看一下数据库的量，库存成-9了

![image-20230628154703556](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230628154703556.png)

在高并发的场景下出现了库存超卖问题，这是秒杀场景下很容易出现的问题，并且也是不可接收的一个问题



### 1.5.1 库存超卖原因

高并发场景不变，假设我们的库存量还有1件

线程2在线程1查询完后又进行查询，发现还有库存

这仅仅是两个线程，如果是更多线程的话更麻烦，扣减的更多

![image-20230628155231633](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230628155231633.png)



**超卖问题使典型的多线程安全问题，针对这一问题，常见的解决方案就是加锁**

悲观锁与乐观锁并不是一种真正的锁，而是一种锁设计的理念

> 悲观锁很影响效率，在抢购这种多线程并发的条件下，并不好用
>
> 而且是我们只是极少数情况会出现多线程并发问题，使用悲观锁并不是很好
>
> 乐观锁那是相当的乐观啊，那我们就是用乐观锁

![image-20230628163847818](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230628163847818.png)





### 1.5.2 介绍乐观锁

乐观锁的关键是判断之前查询得到的数据是否被修改过，常见的方式有两种：

* **版本号发**

  应用最广泛、普遍。

  字段中多增加一个version版本，每当数据做一次修改，版本号就会+1，想要判断数据有没有被修改过，比对一下版本号就可以了

  ![image-20230628170326566](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230628170326566.png)

![image-20230628170308385](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230628170308385.png)



* **CAS法**

其实是对版本号法做了一些优化，版本号发其实就是使用version标注数据有没有被修改

我们其实可以用库存代替版本，在更新时直接比较库存的数量有没有发生变化即可

![image-20230628170756367](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230628170756367.png)





### 1.5.3 乐观锁解决库存超卖

我们采用CAS法，修改之前的业务逻辑

只需要修改第五步，新增加一个条件

```java
//      TODO 5.扣减库存
        boolean success = seckillVoucherService.update()
                .setSql("stock = stock-1") //set stock = stock-1
                .eq("voucher_id", voucherId) //where  voucher_id= voucherId
                .eq("stock",voucher.getStock())//where  stock= stock
                .update();
        if (!success) {
            return Result.fail("扣减失败，可能库存不足");
        }
```

修改之后发现异常比率高达89%，失败的人大大增加了，还不如不改嘞

![image-20230628171453437](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230628171453437.png)

观察数据库，发现库存并没有多卖

![image-20230628171601497](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230628171601497.png)

**为什么没卖完，就这么错错误呢？**

牵扯 乐观锁一个弊端，成功率太低，如下图所示

![image-20230628171745219](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230628171745219.png)



**对乐观锁进行改进**

对库存来说非常好改，只需要库存大于0就行

```java
//      TODO 5.扣减库存
        boolean success = seckillVoucherService.update()
                .setSql("stock = stock-1") //set stock = stock-1
                .eq("voucher_id", voucherId) //where  voucher_id= voucherId
                .gt("stock",0)//where  stock>0
                .update();
        if (!success) {
            return Result.fail("扣减失败，可能库存不足");
        }
```

**完美达到我们的预期**

![image-20230628172110947](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230628172110947.png)





> 除此之外，为了提高成功率，可以采用分批加锁的方式，或者是分段加锁方式
>
> 我们可以把数据类资源分成多份。比如说库存总共100分，将其存到十张表中，每个表中库存量是10，用户在抢的时候可以去多张表里面去抢，成功率提高了10倍





## 1.6 实现一人一单功能

**需求**：修改秒杀业务，要求同一个优惠券，一个用户只能下一单

> 比之前多了一个判断而已，没什么大不了的！！！！！

![image-20230628192859694](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230628192859694.png)



>  TODO注释标识的内容就是我们新增的，一定要先判断订单是否存在，再决定是够扣减库存
>

```java
 @Resource
    private ISeckillVoucherService seckillVoucherService;

    @Resource
    private RedisIdWorker redisIdWorker;

    @Override
    @Transactional
    public Result seckillVoucher(Long voucherId) {
//      1.查询优惠券
        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);
//      2.判断秒杀是否开始
        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {
            return Result.fail("秒杀活动尚未开始");
        }
//      3.判断秒杀是否结束
        if (voucher.getEndTime().isBefore(LocalDateTime.now())) {
            return Result.fail("秒杀活动已经结束");
        }
//      4.判断库存是否充足
        if (voucher.getStock() < 1) {
            return Result.fail("库存不足");
        }

//      TODO 新增一人一单的判断
        UserDTO user = UserHolder.getUser();
//      TODO 查询订单
        int count = query().eq("user_id", user.getId())
                .eq("voucher_id", voucherId).count();
//      TODO 判断是否存在
        if (count > 0) {
//      TODO 用户至少下过一单，不能再下了
            return Result.fail("一人一单，不可重复下单");
        }
//      TODO 说明没买过，继续执行代码

//      5.扣减库存
        boolean success = seckillVoucherService.update()
                .setSql("stock = stock-1") //set stock = stock-1
                .eq("voucher_id", voucherId) //where  voucher_id= voucherId
                .gt("stock", 0)//where  stock>0
                .update();
        if (!success) {
            return Result.fail("扣减失败，可能库存不足");
        }

//      6.创建订单
//      我们只管订单id，代金券id，下单用户id
        VoucherOrder voucherOrder = new VoucherOrder();
//      6.1 订单id
//      使用自定义id生成器生成id
        long orderID = redisIdWorker.nextId("order");
        voucherOrder.setId(orderID);
//      6.2 用户id
//      我们之前编写的登录拦截器
        voucherOrder.setUserId(user.getId());
//      6.3 代金券id
        voucherOrder.setVoucherId(voucherId);

        save(voucherOrder);

//      7.返回订单id
        return Result.ok(orderID);
    }
```



![image-20230628194009803](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230628194009803.png)







但是！！！在高并发线程下（200个线程，同一个用户），异常率95%，显然有问题，有10个线程下单成功了

![image-20230628194258822](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230628194258822.png)

![image-20230628194357743](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230628194357743.png)

![image-20230628194407016](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230628194407016.png)



虽然在代码中做了一人一单的判断，但是问题依然存在

与库存超卖相同，在高并发的场景下，可能会存在一些线程差不多同时执行下面标红的内容，也就是说通过了“一人一单”的校验，那既然通过了，就能生成订单了，从而导致实际没有完成“一人一单”的需求

![image-20230628194636179](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230628194636179.png)



### 1.6.1 悲观锁解决“一人一单”多线程并发问题

在哪一段添加悲观锁？

校验一人一单、扣减库存、创建订单。

注意我们加锁的位置！！

* **不能加在createVoucherOrder方法上**

  如果在方法上添加synchronized,说明同步锁是this，当前对象

  不建议 把synchronized放在方法上，锁住此对象后，不管任何一个用户来了，都是这把锁，也就意味着整个方法被串行化了
  所谓“一人一单”，只需要对同一个用户加锁即可，如果不是同一个用户，无需加锁



* **不能加在createVoucherOrder方法里面**

  加载方法里面后，锁定的范围有点小了，因为我们还没有提交事务，锁就被释放了，再提交事务修改数据库数据之前，很有可能有其他线程进入createVoucherOrder方法实现一人一单的判断，查询订单发现不存在，不存在的原因很可能是没有提交事务

  为了避免这种情况，不能把锁加在createVoucherOrder方法里面

* **锁加在seckillVoucher方法返回值上**

  等createVoucherOrder方法全部执行完再释放锁，已经写入数据库了，很完美了

  ```java
  synchronized (user.getId().toString().intern()) {
      return createVoucherOrder(voucherId);
  }
  ```

>  有关锁的内容可以查看下面这篇文章[JavaSE——多线程详细_javase多线程_我爱布朗熊的博客-CSDN博客](https://blog.csdn.net/weixin_51351637/article/details/128251331)



**为什么createVoucherOrder会存在事物失效的情况**？

seckillVoucher在调用createVoucherOrder方法时其实是return  this.createVoucherOrder(voucherId);,this指的是当前对象，而不是它的代理对象，而事物要想生效，是因为Spring对当前的类做了动态代理，拿到了它的代理对象去做事物处理

但是this当前对象是没有事物功能的（这就是Spring事物失效的几种可能性之一）

解决办法之一就是获取当前对象的代理对象，如下所示

```java
        synchronized (user.getId().toString().intern()) {
//          获取当前对象的代理对象 强转
            VoucherOrderServiceImpl proxy = (VoucherOrderServiceImpl) AopContext.currentProxy();
            return proxy.createVoucherOrder(voucherId);
        }
```

这么做需要导入下面的依赖：

```xml
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
</dependency>
```

并且还需要启动类暴露这个代理对象，如果不暴露的话是获取不到的

```java
@MapperScan("com.hmdp.mapper")
@SpringBootApplication
@EnableAspectJAutoProxy(exposeProxy = true)
public class HmDianPingApplication {
       ....
}
```





**完整代码**

```java
    @Override
    public Result seckillVoucher(Long voucherId) {
//      1.查询优惠券
        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);
//      2.判断秒杀是否开始
        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {
            return Result.fail("秒杀活动尚未开始");
        }
//      3.判断秒杀是否结束
        if (voucher.getEndTime().isBefore(LocalDateTime.now())) {
            return Result.fail("秒杀活动已经结束");
        }
//      4.判断库存是否充足
        if (voucher.getStock() < 1) {
            return Result.fail("库存不足");
        }
        UserDTO user = UserHolder.getUser();
        synchronized (user.getId().toString().intern()) {
//          获取当前对象的代理对象 强转
            VoucherOrderServiceImpl proxy = (VoucherOrderServiceImpl) AopContext.currentProxy();
            return proxy.createVoucherOrder(voucherId);
        }
    }

    //  如果在方法上添加synchronized,说明同步锁是this，当前对象
//  不建议 把synchronized放在方法上，锁住此对象后，不管任何一个用户来了，都是这把锁，也就意味着整个方法被串行化了
//  所谓“一人一单”，只需要对同一个用户加锁即可，如果不是同一个用户，无需加锁
    @Transactional
    public Result createVoucherOrder(Long voucherId) {
//      TODO 新增一人一单的判断
        UserDTO user = UserHolder.getUser();
//      user.getId().toString()转换成字符串也无法保证线程安全，因为每次的String都不一样
//      我们可以加一个intern，是一个字符串对象规范表示，回去字符串常量池中找一找和此字符串的值一样的字符串地址并返回

//      TODO 查询订单
            int count = query().eq("user_id", user.getId())
                    .eq("voucher_id", voucherId).count();
//      TODO 判断是否存在
            if (count > 0) {
//      TODO 用户至少下过一单，不能再下了
                return Result.fail("一人一单，不可重复下单");
            }
//      TODO 说明没买过，继续执行代码
//      5.扣减库存
            boolean success = seckillVoucherService.update()
                    .setSql("stock = stock-1") //set stock = stock-1
                    .eq("voucher_id", voucherId) //where  voucher_id= voucherId
                    .gt("stock", 0)//where  stock>0
                    .update();
            if (!success) {
                return Result.fail("扣减失败，可能库存不足");
            }

//      6.创建订单
//      我们只管订单id，代金券id，下单用户id
            VoucherOrder voucherOrder = new VoucherOrder();
//      6.1 订单id
//      使用自定义id生成器生成id
            long orderID = redisIdWorker.nextId("order");
            voucherOrder.setId(orderID);
//      6.2 用户id
//      我们之前编写的登录拦截器
            voucherOrder.setUserId(user.getId());
//      6.3 代金券id
            voucherOrder.setVoucherId(voucherId);

            save(voucherOrder);

//      7.返回订单id
            return Result.ok(orderID);
    }
```

>  **补充：@Transactional修饰的方法为什么只能是public**
>
> 1. 访问权限：非公共方法（如私有方法、受保护的方法）对外部调用者不可见，因此不具备可以被事务切面拦截和织入的能力。而公共方法可以被任何调用者访问和调用，因此可以被事务切面拦截。
> 2. 代理方式：Spring框架通过AOP（面向切面编程）来实现`@Transactional` 的功能，通常使用动态代理技术。而动态代理只能为公共方法创建代理对象，无法为非公共方法创建代理对象。



## 1.7 集群下的线程并发安全问题

我们刚刚“一人一单”的操作，只适合在单机情况下使用

