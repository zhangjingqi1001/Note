# 多级缓存

# 一、多级缓存介绍

**缓存的作用**：减轻对数据库的压力，缩短服务响应的时间，从而提高服务的并发能力

但是如果是很高的并发量的话，仅仅靠Redis并不能满足高并发需求，而**多级缓存能够应对亿级流量**

## 1.1 传统缓存的问题

**传统的缓存策略**一般是请求到大Tomcat后，先查询Redis，如果未命中则查询数据库，**存在下面的问题**：

* **请求要经过Tomcat处理，Tomcat的性能成为整个系统的瓶颈**

用户请求依然进入Tomcat，而后由Tomcat去查询Redis缓存，并且Tomcat本身的并发能力并不如Redis，在这个场景中，Tomcat成为业务的瓶颈

* **Redis缓存失效时，会对数据库产生冲击**

![image-20230715221830760](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230715221830760.png)

## 1.2 多级缓存方案

**多级缓存**就是充分利用请求处理的每个环节，分别添加缓存，减轻Tomcat压力，提升服务性能：

* **① 用户可以通过浏览器或者手机去访问我们的服务器得到数据并且渲染，在这里我们就可以形成一级缓存了，称为浏览器客户端缓存**

> 浏览器可以把服务器返回的静态资源保存在本地的，下一次再去访问静态资源的时候，我们的服务器只需要检查一下数据有没有变化，没有变化便返回304状态码，浏览器接收到304状态码就直接把本地的数据渲染，用户就能直接看到了，这样就可以减少很多的数据传输，提高渲染和响应的速度

* **② 但是对于非静态数据，我们就不得不访问服务器端了，比如说请求到达了Nginx服务器**

> 以前的Nginx是用来做反向代理的，但是这里要形成第二级缓存，称为**Nginx本地缓存**

我们可以把数据缓存在Nginx本地，用户请求来了之后先看二级缓存有没有，如果有直接返回

* **③ 如果Nginx的本地缓存没有，直接查询Redis**

此处查询Redis形成第三级缓存。如果Redis命中了，就返回，如果没有命中才会到大Tomcat

> 以前Redis是在Tomcat之后查，现在是Nginx之后查

* **④Tomcat成为第四级缓存，叫做Tomcat进程缓存**

会在服务器的内部，利用类似map这样的形式（但并不是map），形成一个进程缓存

请求到大Tomcat之后先读取本地缓存，如果进程缓存命中后就直接返回，并不用去访问数据库了

> 这样Redis失效后，请求并不会直接打到mysql数据库上



**模型图**

![image-20230715223633094](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230715223633094.png)

****

现在大部分的压力集中在了Nginx内部，此时Redis不再是一个反向代理服务器，就变成了一个真正的外部服务，可以在里面写业务逻辑，那可以将Nginx形成一个集群，才能应对一个高并发

也可以用一个单独的Nginx，来做一个反向代理，请求先到达这个单独的Nginx，然后再由其反向代理到我们多个这样的本地缓存（编写业务的Nginx服务器），之后就是Redis、Tomcat、MYSQL

![image-20230715223948710](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230715223948710.png)









# 二、JVM进程缓存

也就是下图标红的位置

![image-20230715224153597](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230715224153597.png)



## 2.1 案例准备

### 2.1.1 导入SQL

```sql
/*
 Navicat Premium Data Transfer

 Source Server         : 192.168.150.101
 Source Server Type    : MySQL
 Source Server Version : 50725
 Source Host           : 192.168.150.101:3306
 Source Schema         : heima

 Target Server Type    : MySQL
 Target Server Version : 50725
 File Encoding         : 65001

 Date: 16/08/2021 14:45:07
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for tb_item
-- ----------------------------
DROP TABLE IF EXISTS `tb_item`;
CREATE TABLE `tb_item`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '商品id',
  `title` varchar(264) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '商品标题',
  `name` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '商品名称',
  `price` bigint(20) NOT NULL COMMENT '价格（分）',
  `image` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '商品图片',
  `category` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '类目名称',
  `brand` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '品牌名称',
  `spec` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '规格',
  `status` int(1) NULL DEFAULT 1 COMMENT '商品状态 1-正常，2-下架，3-删除',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `status`(`status`) USING BTREE,
  INDEX `updated`(`update_time`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 50002 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '商品表' ROW_FORMAT = COMPACT;

-- ----------------------------
-- Records of tb_item
-- ----------------------------
INSERT INTO `tb_item` VALUES (10001, 'RIMOWA 21寸托运箱拉杆箱 SALSA AIR系列果绿色 820.70.36.4', 'SALSA AIR', 16900, 'https://m.360buyimg.com/mobilecms/s720x720_jfs/t6934/364/1195375010/84676/e9f2c55f/597ece38N0ddcbc77.jpg!q70.jpg.webp', '拉杆箱', 'RIMOWA', '{\"颜色\": \"红色\", \"尺码\": \"26寸\"}', 1, '2019-05-01 00:00:00', '2019-05-01 00:00:00');
INSERT INTO `tb_item` VALUES (10002, '安佳脱脂牛奶 新西兰进口轻欣脱脂250ml*24整箱装*2', '脱脂牛奶', 68600, 'https://m.360buyimg.com/mobilecms/s720x720_jfs/t25552/261/1180671662/383855/33da8faa/5b8cf792Neda8550c.jpg!q70.jpg.webp', '牛奶', '安佳', '{\"数量\": 24}', 1, '2019-05-01 00:00:00', '2019-05-01 00:00:00');
INSERT INTO `tb_item` VALUES (10003, '唐狮新品牛仔裤女学生韩版宽松裤子 A款/中牛仔蓝（无绒款） 26', '韩版牛仔裤', 84600, 'https://m.360buyimg.com/mobilecms/s720x720_jfs/t26989/116/124520860/644643/173643ea/5b860864N6bfd95db.jpg!q70.jpg.webp', '牛仔裤', '唐狮', '{\"颜色\": \"蓝色\", \"尺码\": \"26\"}', 1, '2019-05-01 00:00:00', '2019-05-01 00:00:00');
INSERT INTO `tb_item` VALUES (10004, '森马(senma)休闲鞋女2019春季新款韩版系带板鞋学生百搭平底女鞋 黄色 36', '休闲板鞋', 10400, 'https://m.360buyimg.com/mobilecms/s720x720_jfs/t1/29976/8/2947/65074/5c22dad6Ef54f0505/0b5fe8c5d9bf6c47.jpg!q70.jpg.webp', '休闲鞋', '森马', '{\"颜色\": \"白色\", \"尺码\": \"36\"}', 1, '2019-05-01 00:00:00', '2019-05-01 00:00:00');
INSERT INTO `tb_item` VALUES (10005, '花王（Merries）拉拉裤 M58片 中号尿不湿（6-11kg）（日本原装进口）', '拉拉裤', 38900, 'https://m.360buyimg.com/mobilecms/s720x720_jfs/t24370/119/1282321183/267273/b4be9a80/5b595759N7d92f931.jpg!q70.jpg.webp', '拉拉裤', '花王', '{\"型号\": \"XL\"}', 1, '2019-05-01 00:00:00', '2019-05-01 00:00:00');

-- ----------------------------
-- Table structure for tb_item_stock
-- ----------------------------
DROP TABLE IF EXISTS `tb_item_stock`;
CREATE TABLE `tb_item_stock`  (
  `item_id` bigint(20) NOT NULL COMMENT '商品id，关联tb_item表',
  `stock` int(10) NOT NULL DEFAULT 9999 COMMENT '商品库存',
  `sold` int(10) NOT NULL DEFAULT 0 COMMENT '商品销量',
  PRIMARY KEY (`item_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = COMPACT;

-- ----------------------------
-- Records of tb_item_stock
-- ----------------------------
INSERT INTO `tb_item_stock` VALUES (10001, 99996, 3219);
INSERT INTO `tb_item_stock` VALUES (10002, 99999, 54981);
INSERT INTO `tb_item_stock` VALUES (10003, 99999, 189);
INSERT INTO `tb_item_stock` VALUES (10004, 99999, 974);
INSERT INTO `tb_item_stock` VALUES (10005, 99999, 18649);

SET FOREIGN_KEY_CHECKS = 1;

```

其中包含两张表：

- **tb_item**：商品表，包含商品的基本信息
- **tb_item_stock**：商品库存表，包含商品的库存信息

之所以将库存分离出来，是因为库存是更新比较频繁的信息，写操作较多。而其他信息修改的频率非常低。



> 其实就是一张表，但是做了一下分离
>
> 因为有一些信息需要经常修改，有一些信息很少修改，
>
> 修改之后需要修改缓存，操作Redis，那我们可以把经常修改的放到一张表，减少整条数据缓存过期的次数

### 2.1.2 导入item-service项目

![image-20230715224616348](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230715224616348.png)

其中的业务包括：

- 分页查询商品
- 新增商品
- 修改商品
- 修改库存
- 删除商品
- 根据id查询商品
- 根据id查询库存



业务全部使用mybatis-plus来实现，如有需要请自行修改业务逻辑。

启动服务，访问：http://localhost:8081/item/10001即可查询数据

![image-20230715232659409](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230715232659409.png)





### 2.1.3 导入商品查询页面

商品查询是购物页面，与商品管理的页面是分离的。

部署方式如图：

![image-20230715232819323](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230715232819323.png)

我们需要准备一个反向代理的nginx服务器，如上图红框所示，将静态的商品页面放到nginx目录中。

页面需要的数据通过ajax向服务端（nginx业务集群）查询。



**运行nginx服务**

然后访问 http://localhost/item.html?id=10001即可

























































