# Springboot日志操作

日志的操作还是挺重要的。

特别是将项目部署到服务器之后，我们只能通过日志的提示信息查看功能是否有问题

# 一、日志基础

**日志（log）作用**：

* **编程期调试代码**
* **运营期记录信息**
  * 记录日常运营重要信息（峰值流量、平均响应时长.....）
  * 记录应用报错信息（错误堆栈）
  * 记录运维过程数据（扩容、宕机、报警....）

> 简单的说，日志就是将错误记录下来，方便程序员修改bug和调试程序

**Springboot有内置的日志logback**（Spring官方推荐）



## 1.1 创建记录日志对象

```java
@RestController
@RequestMapping("/books")
public class BookController {
    //  org.slf4j.Logger;
    //  创建记录日志对象
    private static final Logger log = LoggerFactory.getLogger(BookController.class);

    @GetMapping
    public String getById(){
        System.out.println("springboot is running .... 2");

        log.debug("debug ...");//  专门给程序员调试使用的
        log.info("info ...");
        log.warn("warn ...");
        log.error("error ...");
//      还有一个日志级别是fatal，但是在这里没有提供对应的api，原因是和error合在一块了
//      在日志系统中，对于fatal的定义是“灾难性的后果”，fatal级别是系统处于崩溃状态，但是系统崩溃了，fatal还活着，这是不可能的，所以在这里API合在一块了
        return "springboot is running ...2";
    }
}
```

我们写了4条日志，但是控制台中只有3条，原因是默认日志级别是info类型的，info级别之下的不会打印

![image-20230909164453977](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230909164453977.png)

> 日志级别中有ALL < TRACE < DEBUG < INFO < WARN < ERROR < FATAL < OFF
>
> 通常使用4种：debug、info、warn、error
>
> 程序员经常使用的是debug和error
>
> 运维人员希望我们用的是info和error





## 1.2 修改日志级别

**第一种方式**

![image-20230909164833772](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230909164833772.png)

**第二种方式**

在application.yaml文件中

```yml
debug: true
```



**第三种方式**

可以这么设置但是不要这么做，这种方式只会打印和springboot相关的

```yaml
logging:
	level: debug
```

尽量下面这个样子，设置一下当前项目根路径下root所有的级别为debug

```yaml
logging:
	level: 
	root: debug
```

root表示根节点，即整体应用日志级别（所用的包里面的调试信息全部都会打印出来）

## 1.3  日志级别的力度控制

**调试程序的时候使用debug级别，但是老报框架里面的debug日志，但是我不想看这部分日志，怎么做**？

**设置日志级别的力度控制**，有各种各样的设置规则

* **设置某个包的日志级别**

  如下所示：整体info级别，但是com.zhangjingqi.controller包下是debug级别

  但是这种不推荐，包很多的话，根本设置不过来

```yaml
logging:
	level: 
	  root: info
	  com.zhangjingqi.controller: debug
```

* **设置分组，对某个分组设置日志级别**

  把若干个包打成一个组，对这个组设置日志级别

1. **第一步：设置分组**

```yaml
logging:
	level: 
	  root: info
	  com.zhangjingqi.controller: debug
	# 设置分组
	group: 
		ebank: com.zhangjingqi.controller,com.zhangjingqi.dao
		iservice: com.zhangjingqi.service
```

2. **第二步： 对组设置级别**

```yaml
logging:
	# 设置分组
	group: 
		ebank: com.zhangjingqi.controller,com.zhangjingqi.dao
		iservice: com.zhangjingqi.service
		
	level: 
	  root: info
	  # 对某个组设置日志级别
	  ebank: warn

```





## 1.4 快速创建日志对象

### 1.4.1 继承

我们不能在每个类中都采用下面这种形式创建日志对象，特别麻烦

```java
    private static final Logger log = LoggerFactory.getLogger(类名.class);
```

**我们可以采用继承一个类，这个类中有此方法，或者采用AOP的方式**

```java
public class BaseClass {

    private  Class clazz;

    public static  Logger log;

    public BaseClass() {
//      初始化当前类对象
        clazz = this.getClass();
//      初始化log对象
        log = LoggerFactory.getLogger(BookController.class);
    }

}
```



此时我们的controller层

```java
@RestController
@RequestMapping("/books")
public class BookController extends BaseClass{

    @GetMapping
    public String getById(){
        System.out.println("springboot is running .... 2");

        log.debug("debug ...");//  专门给程序员调试使用的
        log.info("info ...");
        log.warn("warn ...");
        log.error("error ...");
//      还有一个日志级别是fatal，但是在这里没有提供对应的api，原因是和error合在一块了
//      在日志系统中，对于fatal的定义是“灾难性的后果”，fatal级别是系统处于崩溃状态，但是系统崩溃了，fatal还活着，这是不可能的，所以在这里API合在一块了
        return "springboot is running ...2";
    }
}
```



### 1.4.2 Lombok 注解

```java
@Slf4j
@RestController
@RequestMapping("/books")
public class BookController {

    @GetMapping
    public String getById(){
        System.out.println("springboot is running .... 2");

        log.debug("debug ...");//  专门给程序员调试使用的
        log.info("info ...");
        log.warn("warn ...");
        log.error("error ...");
//      还有一个日志级别是fatal，但是在这里没有提供对应的api，原因是和error合在一块了
//      在日志系统中，对于fatal的定义是“灾难性的后果”，fatal级别是系统处于崩溃状态，但是系统崩溃了，fatal还活着，这是不可能的，所以在这里API合在一块了
        return "springboot is running ...2";
    }
}
```



```xml
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
</dependency>
```



# 二、日志输出格式控制

![image-20230909174437015](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230909174437015.png)

**如果我们的日志不想记录成上面那样，也是能够设置的**

* **设置日志输出格式**

  日志模板

```yaml
logging:
	pattern:
		console: "%d - %m%n"
```

* **%d**：日期

* **%m**：消息

* **%n**：换行，如果是%5n，表示占5位
* **%p**：level，日志级别

![image-20230909175045831](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230909175045831.png)

* **%clr()**：添加颜色，比如 %clr(%5n)，指定颜色 %clr(%5n){cyan}，指定为青色
* **%t**：线程名
* **%c**： 类名，这样默认是右对齐，如果是%-40c表示长度40位的左对齐；40位长，如果超过40位就做删除处理%-40.40c ,第二个40是对内容的截取



# 三、日志文件

，目前现在日志都是输出在控制台上，但是我们上线之后是看不到控制台的，这怎么办？

此时便需要将我们的日志记录到文件里面

```yaml
logging:
  level:
    root: info
  file:
    path: server.log
```

日志记录到磁盘不是实时刷新的，只有到达一定的缓冲量后才写入到磁盘

那生成的文件在哪里呢？

![image-20230910120909095](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230910120909095.png)

![image-20230910121029519](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230910121029519.png)

> **logging.file.path仅仅用于指定日志输出的目录，且不能指定输出的文件名，且默认名为spring.log  若指定的是相对目录，则会生成在当前总项目的目录下**

如果是下面这么配置

```yaml
logging:
  level:
    root: info
  file:
    name: server.log
```



文件中就会存在控制台的信息

![image-20230910121111898](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230910121111898.png)

随着项目的进行，日志信息越来越多，一个日志文件是不足以支撑的，我们可以**一天一个日志文件**

```yaml
logging:
  level:
    root: info
  file:
    name: "server.log"
    path: "E:/logging/"
  logback:
    rollingpolicy:
#     设置文件最大大小4KB
      max-file-size: 4KB
#     以后生成的文件格式就是 server.2020-01-01.0.log 最后那个0代表这天的第一个文件
      file-name-pattern: server.%d{yyyy-MM-dd}.%i.log
```



****

****

我们日志门面一般使用Slf4j，日志实现一般使用Logback

![image-20230910125629509](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230910125629509.png)

## 3.1 其他日志框架统一转换为slf4j

A系统：开发A系统时我们采用slf4j+logback实现，但是在开发A系统的时候我们要依赖spring等框架，而且每个框架底层也会用到日志，而且日志会各不相同

> Spring底层使用commons-logging日志，Hibernate底层使用jboos-logging日志

**我们现在想统一日志记录，一起使用slf4j和logback**

















