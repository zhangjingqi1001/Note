[TOC]



# 一、FastJson介绍



​     Fastjson是阿里巴巴的开源SON解析库它可以解析JSON格式的字符串，**支持将java Bean序列化为ISON字符串，也可以从JSON字符串反序列化到JavaBean。**



**Fastjson的优点**

- **速度快**
  **fastjson相对其他JSON库的特点是快**，从2011年fastjson发布1.1.版本之后其性能从未被其他ava实现的]SON库超越

  

- **使用广泛**
  fastjson在阿里巴巴大规模使用，在数万台服务器上部署，fastjson在业界被广泛接受。在2012年被开源中国评选为最受欢迎的国产开源软件之一

  

- **测试完备**
  fastjson有非常多的testcase，在1.2.11版本中，testcase超过3321个。每次发布都会进行回归测试，保证质量稳定

  

- **使用简单**
  fastison的API十分简洁



- **功能完备**
  支持泛型，支持流处理超大文本，支持枚举，支持序列化和反序列化扩展





# 二、FastJson序列化 API



**序列化：** **将Java对象转换成JSON格式字符串的过程。**





## 2.1 JSON对象转换成字符串

**使用 JSON.toJSONString(Object object)； 方法**



```java
public class ObjectToJSON {
    public static void main(String[] args) {
        Student student = new Student("张三",20,"北京市","zhangjinfqi@qq.com");
        String jsonString = JSON.toJSONString(student);
        System.out.println(jsonString);
    }
}
```

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Student {
    private String name;
    private Integer age;
    private String address;
    private String email;
}
```



![image-20230403171538032](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230403171538032.png)







## 2.2 List集合转换成JSON对象

**使用 JSON.toJSONString(Object object)； 方法**



```java
Student student1 = new Student("张三",20,"北京市","zhangjinfqi@qq.com");
Student student2 = new Student("张三",20,"北京市","zhangjinfqi@qq.com");
Student student3 = new Student("张三",20,"北京市","zhangjinfqi@qq.com");
Student student4 = new Student("张三",20,"北京市","zhangjinfqi@qq.com");

ArrayList<Student> list = new ArrayList<>();
list.add(student1);
list.add(student2);
list.add(student3);
list.add(student4);
String jsonString = JSON.toJSONString(list);
System.out.println(jsonString);
```



![image-20230403172132984](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230403172132984.png)







## 2.3 Map集合转换成JSON对象



```java
Map<String, Student> map = new HashMap<>();
Student student1 = new Student("张三", 20, "北京市", "zhangjinfqi@qq.com");
Student student2 = new Student("张三", 20, "北京市", "zhangjinfqi@qq.com");
Student student3 = new Student("张三", 20, "北京市", "zhangjinfqi@qq.com");
Student student4 = new Student("张三", 20, "北京市", "zhangjinfqi@qq.com");
map.put("1",student1);
map.put("2",student2);
map.put("3",student3);
map.put("4",student4);
String jsonString = JSON.toJSONString(map);
System.out.println(jsonString);
```



![image-20230403172608170](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230403172608170.png)







# 三、FastJSON反序列化



**将JSON格式的字符串转换成Java对象**





## 3.1 JSON字符串转Object对象

**JSON.parseObject(JSON字符串, 要转换成的类.class);**



```java
        String jsonString = "{\"address\":\"北京市\",\"age\":20,\"email\":\"zhangjinfqi@qq.com\",\"name\":\"张三\"}";
//        第一个参数传入JSON字符串，第二个参数传入我们要转换成的对象的类
        Student student = JSON.parseObject(jsonString, Student.class);
        System.out.println(student);
```



![image-20230403173718274](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230403173718274.png)





## 3.2  JSON字符串转List集合



```
JSON.parseArray(json格式字符串, 传递转换后的集合的泛型);
```



```java
        String jsonString = "[{\"address\":\"北京市\",\"age\":20,\"email\":\"zhangjinfqi@qq.com\",\"name\":\"张三\"},{\"address\":\"北京市\",\"age\":20,\"email\":\"zhangjinfqi@qq.com\",\"name\":\"张三\"},{\"address\":\"北京市\",\"age\":20,\"email\":\"zhangjinfqi@qq.com\",\"name\":\"张三\"},{\"address\":\"北京市\",\"age\":20,\"email\":\"zhangjinfqi@qq.com\",\"name\":\"张三\"}]";
//         第一个参数传递JSON格式字符串，第二个参数传递转换后的集合的泛型
        List<Student> studentsList = JSON.parseArray(jsonString, Student.class);
        System.out.println(studentsList);
```

![image-20230403174042963](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230403174042963.png)







## 3.3 JSON字符串转Map集合



```java
        String jsonString = "{\"1\":{\"address\":\"北京市\",\"age\":20,\"email\":\"zhangjinfqi@qq.com\",\"name\":\"张三\"},\"2\":{\"address\":\"北京市\",\"age\":20,\"email\":\"zhangjinfqi@qq.com\",\"name\":\"张三\"},\"3\":{\"address\":\"北京市\",\"age\":20,\"email\":\"zhangjinfqi@qq.com\",\"name\":\"张三\"},\"4\":{\"address\":\"北京市\",\"age\":20,\"email\":\"zhangjinfqi@qq.com\",\"name\":\"张三\"}}";
//      直接进行反序列化，Map集合是没有泛型的，也是可以正常输出的，但是没有泛型的集合是不安全的集合
//        Map map = JSON.parseObject(jsonString);

//        下面掉用户parseObject，传递参数TypeReference类型，在TypeReference的泛型中传递转后的Map集合即可
//         {}是什么意思？   因为TypeReference的构造方法是protected修饰的，只有子类才能调用，但是我们现在不是他的子类，在后面加{}让其在这成为匿名内部类，匿名内部类就是该类的子类对象
        Map<String, Student> map = JSON.parseObject(jsonString, new TypeReference<Map<String, Student>>() {
        });
        System.out.println(map);
```



![image-20230403175356986](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230403175356986.png)





# 四、JSONObject对象

## 4.1 JSON字符串转换成JSONObject

```java
JSONObject jsonObject = JSON.parseObject("JSON 字符串");
```



## 4.2 从JSONObject中得到某一个封装数据

```json
{
    "body":{
        "createBy":0,
        "aaa0":"sssss",
        "updateBy":0,
        "userId":10086,
        "userCode":"10088888"
    }
}
```

```java
// 将字符串转换成JSONObject
JSONObject responseObj = JSON.parseObject("{"body":{"createBy":0,"aaa0":"sssss","updateBy":0,"userId":10086,"userCode":"10088888"}}");

//获取body对象
JSONObject body = responseObj.getJSONObject("body");

//获取body里面的某个数据
String userCode = body.getString("userCode");
```



## 4.3 将JSONObject对象中的key按照ASCII排序

```java
//   按照ASCII码排序字段
public String sortByASCII(String jsonStr) {
    //创建JSONObject
    JSONObject jsonObject = JSON.parseObject(jsonStr);

    // 将JSONObject转换为Map对象
    Map<String, Object> innerMap = jsonObject.getInnerMap();

    // 创建一个新的TreeMap并将元素复制到其中
    TreeMap<String, Object> treeMap = new TreeMap<>(innerMap);

    // 创建一个新的JSONObject并使用TreeMap更新它
    JSONObject sortedJsonObject = new JSONObject(treeMap);

    return sortedJsonObject.toString();
}
```



# 五、关于将JSONObject之前返回前端的问题

 今天我将一个String类型的数据转换成JSONObject类型数据并且直接返回给了前端，发现前端怎么也调不通，我日志中的JSON数据也并没有什么问题，下面来探析一下

不用探析了，一个很傻逼的问题

Controller层封装了一下结果集，然后Service层又封装了一下结果集导致的





# 六、常用注解

@JsonProperty 注解和 @JSONField 注解

## 6.1 @JSONField

### 6.1.1  指定字段在生成的JSON中的名称

 使用场景：某一个字段是大写，但是我们转成JSON后变成小写，如下所示

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class GetIdentityIdDto implements Serializable {
    private static final long serialVersionUID = 3293035228265414449L;

    @NotBlank
    private String identityCard;

    @NotBlank
    private String Sex;

}
```

将上面的dto转成JSON

```java
GetIdentityIdDto dto = new GetIdentityIdDto("111","222");

String toJSONString = JSONObject.toJSONString(dto);

System.out.println(toJSONString);
```

输出结果,可以看出来“Sex”字段首字母变成小写了

```json
{
    "identityCard":"111",
    "sex":"222"
}
```



**解决方案**：通过@JSONField的name属性指定字段在生成的JSON中的名称

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class GetIdentityIdDto implements Serializable {
    private static final long serialVersionUID = 3293035228265414449L;

    @NotBlank
    private String identityCard;

    @NotBlank
    @JSONField(name = "Sex")
    private String Sex;

}
```

效果

```json
{
    "Sex":"222",
    "identityCard":"111"
}
```



### 6.1.2 ordinal属性指定字段的序列化顺序

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class GetIdentityIdTestDto implements Serializable {
    private static final long serialVersionUID = 3293035228265414449L;

    @NotBlank
    @JSONField(name = "identityCard",ordinal = 2)
    private String identityCard;

    @NotBlank
    @JSONField(name = "Sex",ordinal = 1)
    private String Sex;

}
```

输出的JSON串数据

```java
GetIdentityIdTestDto dto = new GetIdentityIdTestDto("111","222");

String toJSONString = JSONObject.toJSONString(dto);

System.out.println(toJSONString);
```

确实是"Sex"字段在前

```json
{"Sex":"222","identityCard":"111"}
```



那我们改一下dto的顺序

```java
    @NotBlank
    @JSONField(name = "identityCard",ordinal = 1)
    private String identityCard;

    @NotBlank
    @JSONField(name = "Sex",ordinal = 2)
    private String Sex;
```

输出顺序

```json
{"identityCard":"111","Sex":"222"}
```



### 6.1.3 format属性

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class GetIdentityIdTestDto implements Serializable {
    private static final long serialVersionUID = 3293035228265414449L;

    @NotBlank
    @JSONField(name = "identityCard",ordinal = 1)
    private String identityCard;

    @NotBlank
    @JSONField(name = "Sex",ordinal = 2)
    private String Sex;

    @JSONField(format="yyyy-MM-dd HH:mm:ss")
    private Date date;

}
```

输出一下

```java
GetIdentityIdTestDto dto = new GetIdentityIdTestDto("111","222",new Date());
System.out.println(new Date());
String toJSONString = JSONObject.toJSONString(dto);

System.out.println(toJSONString);

System.out.println(dto.getDate());
```

format属性只是在转JSON的时候进行format，我们如果获取此字段对应的属性的话，还是原来的值

![image-20230831083401980](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230831083401980.png)



> **@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")与@JSONField(format="yyyy-MM-dd HH:mm:ss")的区别**
>
> ![image-20230831084949131](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230831084949131.png)