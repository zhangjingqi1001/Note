# IOC AOP



# 一、 分层解耦



* 内聚： 软件中各个功能模块内部的功能联系
* 耦合： 衡量软件中各个层/模块之间的依赖、关联的程度
* 软件设计原则：高内聚、低耦合



​     **控制反转**：Inversion Of Control,简称IOC。对象的创建控制权由程序自身转移到外部（容器），这种思想成为控制反转

​     **依赖注入**：Dependency Injection，简称DI。容器为应用程序提供运行时，所依赖的资源，称为依赖注入。

​     **Bean对象**： IOC容器中创建、管理的对象，称为bean

 



## 1.1 IOC - 控制反转 详细

把某个对象交给IOC容器管理，需要添加如下注解之一：

|    注解     |        说明        |                      位置                       |
| :---------: | :----------------: | :---------------------------------------------: |
| @Component  | 生命bean的基础注解 |           不属于以下三类时，用此注解            |
| @Controller | @Component衍生注解 |                  标注在控制器                   |
|  @Service   | @Component衍生注解 |                 标注在业务类上                  |
| @Repository | @Component衍生注解 | 标注在数据访问类上（由于与Mybatis整合，用的少） |



* 声名bean的时候，可以通过value属性指定bean的名字，如果没有指定，默认是类名首字母小写

  

*  使用以上四个注解都可以生命bean，但是在Springboot集成web开发中，声名控制器bean只能用@Controller 



* bean的四大注解想要生效，**需要被组件扫描注解@ComponentScan扫描**

  

*  @ComponentScan注解虽然没有显示配置，但是实际上已经包含在了启动类生命注解@SpringBootApplication中，默认扫描的范围是启动类所在包及其子包

    如下包名是从“java”包后开始的，但是下面这种不推荐，我们希望的是按照Spring的规范，将包设置在启动类所在包及其子包

```java
@ComponentScan({"dao","com.zhangjingqi"})
```





## 1.2 DI - 依赖注入 详解

 

**@Autowired 注解**，**默认是按照类型进行**的，如果存在多个相同的bean，会报错。



 EmpServiceA 实现 EmpService类，EmpServiceB 实现 EmpService类，我们在某个地方注入EmpService对象时便会出现注入错误。



**解决方案**

* **@Primary  设置bean的优先级**

​        如果我们想要哪个bean填入容器，可以在类名之上添加@Primary



*  **@Qualifier**  指定bean的名字

```java
   @Qualifier("empServiceA")
   @Autowired
   private EmpService empService;
```



* **@Resource** 按照名称注入

   **@Autowired 注解默认按照类型注入，@Resource默认按照类名进行注入**

```java
   @Resource(name = "empServiceB")
   private EmpService empService;
```

 



# 二、AOP

## 2.1 了解

Spring的第二大核心，第一大核心是IOC



**AOP**：面向切面编程、面向方面编程，其实就是面向特定方法编程



**实现**：

* **动态代理是面向切面编程最主流的实现。**而SpringAOP是Spring框架的高级技术，目的是在管理bean对象的过程中，主要通过底层的动态代理机制，对特定的方法进行编程





* **为什么要面向方法编程？**

​      **场景**：案例部分功能运行较慢，定位执行耗时较长的业务方法，此时需要统计每一个业务方法的执行耗时，找到耗时较长的业务进行优化

​    按照之前的方式，就是在方法开始前和开时候分别获取一个时间，两个时间相减就是执行耗时，但是这种方式是非常繁琐的

![image-20230517160748642](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230517160748642.png)



**如果我们基于AOP，面向方法编程，我们可以做到在不改动原始方法的基础上，来针对原始的方法进行编程，可以是对原始方法功能的增强，也可以改变原始方法的功能**



比如我们现在要统计方法的耗时，我们只需要**定义一个模板方法**，将公共的代码定义在模板方法中

原始业务方法在这里指的是需要统计执行耗时的业务方法。而这样面向一个或者多个方法进行编程，就称为**面向切面编程**

比如我们调用list()方法，此时并不会直接执行原始的list方法，而是自动的去执行模板方法。

**模板中所定义的代码逻辑其实是创建出来的代理对象方法中的逻辑**

![image-20230517161356224](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230517161356224.png)









## 2.2  快速入门 - AOP 开发步骤

**需求**：统计各个业务层方法执行耗时



### 2.2.1 Maven依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
```



### 2.2.2 代码实现

 **针对于特定方法根据业务需要进行编程**



```java
@Slf4j
@Component //交给容器IOC进行管理
@Aspect //加上这个注解表示不是一个普通的类，而是一个AOP类，在此类中定义模板方法
public class TimeAspect {

//  参数是一个表达式，表示针对哪些特定方法进行编程
//  com.zhangjingqi.service 包名
//  第一个*代表任意返回值 第二个*代表类名或者接口名  第三个*代表方法名
    @Around("execution(* com.zhangjingqi.service.*.*(..))") //切入点表达式
    public Object recordTime(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        long begin = System.currentTimeMillis();

//      result 原始方法执行返回值
        Object result = proceedingJoinPoint.proceed();//调用原始方式运行

        long end = System.currentTimeMillis();

//      proceedingJoinPoint.getSignature() 获取方法的签名，我们就知道是哪个方法了
//      如： List com.zhangjingqi.service.impl.DeptServiceImpl.list()执行耗时：239ms
        log.info(proceedingJoinPoint.getSignature() + "执行耗时：{}ms", end - begin);

//      原始方法的返回值我们需要返回回去
        return result;
    }
}
```



### 2.2.3 AOP 应用场景及优势

**应用场景**

* **记录操作日志**
*  **权限控制**
*  **事务管理**

![image-20230517164446034](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230517164446034.png)





**优势**

* **代码无侵入**
* **减少重复代码**
* **提高开发效率**
* **维护方便**





## 2.3 核心概念



### 2.3.1 连接点 - JoinPoint

**连接点**：JoinPoint，可以被AOP控制的方法（暗含方法执行时的相关信息）



**通知**：Advice，指那些重读的逻辑，也就是共性功能（最终体现为一个方法）



**切入点**：PointCut，匹配连接点的条件，通知仅会在切入点方法执行时被应用（就是实际被AOP控制的方法）

   我们通常会使用下面的切入点表达式来描述切入点

```java
@Around("execution(* com.zhangjingqi.service.*.*(..))") 
```



**切面**：Aspect，描述通知与切入点的对应关系（通知+切入点），被@Aspect注解修饰的类我们一般称为切面类



**目标对象**：Target，通知所应用的对象。



![image-20230517175551925](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230517175551925.png)





### 2.3.2 AOP执行流程

**通知如何与目标对象结合在一起对目标对象中的方法进行功能增强的？**



​    ①**SpringAOP是基于动态代理技术来实现的。程序运行的时候会自动的基于动态代理技术为目标对象生成一个对应的代理对象。**



​    ② **在代理对象中就会对目标对象中的原始方法进行功能的增强。**

​           **如何来增强的？增强的逻辑是什么样子的？**

​               其实就是我们的通知



​    ③**最终在Spring容器中注入的是代理对象，调用的方法也是代理对象中的对应方法**

![image-20230517180323565](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230517180323565.png)











## 2.4 通知

### 2.4.1 通知类型

* **@Around：环绕通知**，此注解标注的通知方法在目标方法前、后都被执行
*  **@Before：前置通知**，此注解标注的通知方法在目标方法前被执行
*  **@After：后置通知**，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执行
*  **@AfterReturning：返回后通知**，此注解标注的通知方法在目标方法后被执行，有异常不会执行
* **@AfterThrowing：异常后通知**，此注解标注的通知方法在发生异常后执行







### 2.4.2 通知顺序





## 2.5 切入点表达式



## 2.6 连接点



## 2.7 记录操作日志







