[TOC]



# 一、多用户通信系统

## 1.1 介绍

**需要技术**：

* **Java面向对象编程**
* **网络编程**
* **多线程**
* **IO流**
* **数据集合**

**需求分析**

* **用户登录**
* **拉取在线用户列表**
* **无异常退出**
* **私聊**
* **群聊**
* **发文件**
* **服务器推送新闻**



当客户端A和服务端建立连接后，两边都会建立一个Socket（也就是一边一个Socket）

当客户端B和服务端建立连接后，两边也都会建立一个Socket，此时服务端有两个socket（一个服务端A的，另一个是服务端B的）

**我们在通讯的时候，怎么保证客户端的两个Socket一直被持有(占有)呢**？

我们启动一个socket，就启动了一个线程，通讯的其实是线程中的Socket

![image-20231205170703638](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20231205170703638.png)

假如客户端B写了一个数据到Socket里面希望群发一个消息，也就是希望获取到服务端中所有线程里的Socket，为此我们可以将服务端的Socket通过一个集合来管理（将来服务端的线程很多）

![image-20231205171116026](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20231205171116026.png)

除此之外，我们的客户端A可能与服务端有多个连接，比如一条连接是发送文本信息的，一条连接是发送文件的，一条信息是视频聊天的.....此时服务端与客户端便是多个通道连接，一条通道连接很难把功能一次性实现，此时客户端A也需要一个管理线程的集合

![image-20231205171653779](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20231205171653779.png)



**服务端的工作逻辑**

* 当有客户端连接到服务端后，会得到一个Socket
* 启动一个线程，该线程会持有Socket对象（该Socket是线程的一个属性）
* 为了将来更好的管理多个线程（以后会涉及到将消息推送给多个客户端），需要使用一个集合来管理



**客户端的工作逻辑**

* 和服务端通信时，使用对象方式，可以使用对象流来读写
* 当客户端连接到服务端后，也会得到socket，我们也会启动一个线程，并且该线程会持有此socket
* 为了将来更好管理线程，需要使用一个集合来管理线程



## 1.2 公共类

### 1.2.1 封装消息类

```java
/**
 * 封装消息
 * 表示客户端和服务端通信时的消息对象
 * 发送消息流程：客户端A -》 服务端 -》 客户端B ，假如服务器瘫痪，聊天便不可以使用
 * （如果客户端A与客户端B在同一个局域网 客户端A -》客户端B）
 */
@Data
public class Message implements Serializable {
    private static final long serialVersionUID = -3567747187962510012L;

    /**
     * 消息类型:发送文件、纯文本、视频聊天....
     */
    private String mesType;

    /*
     *发送者
     */
    private String sender;

    /**
     *接收者
     */
    private String getter;

    /**
     * 消息内容
     */
    private String content;

    /**
     * 发送时间
     */
    private String sendTime;

}
```



### 1.2.2 用户类

```java
/**
 * 客户信息
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User implements Serializable {

    private static final long serialVersionUID = 4300366482842276408L;
    private String userId; //用户id
    private String passwd; //用户密码
}
```



### 1.2.3 消息类型类

```java
/**
 * 消息类型
 * 不同行亮的值表示不同的消息类型
 */
@Getter
public enum MessageType {
    /**
     * 登录成功
     */
    MESSAGE_LOGIN_SUCCEED("1"),
    /**
     * 登录失败
     */
    MESSAGE_LOGIN_FAIL("2");

    private final String code;


    MessageType(String code) {
        this.code = code;
    }



    public static String find(Integer code) {
        for (MessageType value : MessageType.values()) {
            if (code.toString().equals(value.getCode())) {
                return value.getCode();
            }
        }
        return null;
    }
}
```



### 1.2.4 控制台读取内容

```java
public class Utility {

    private static Scanner scanner;

    static {
        scanner = new Scanner(System.in);
    }

    public Utility() {

    }

    public static char readMenuSelection() {
        while (true) {
            String str = readKeyBoard(1, false);
            char c = str.charAt(0);
            if (c == '1' || c == '2' || c == '3' || c == '4' || c == '5') {
                return c;
            }

            System.out.print("选择错误，请重新输入：");
        }
    }

    public static char readChar() {
        String str = readKeyBoard(1, false);
        return str.charAt(0);
    }

    public static char readChar(char defaultValue) {
        String str = readKeyBoard(1, true);
        return str.length() == 0 ? defaultValue : str.charAt(0);
    }

    public static int readInt() {
        while (true) {
            String str = readKeyBoard(2, false);
            try {
                int n = Integer.parseInt(str);
                return n;
            } catch (NumberFormatException var3) {
                System.out.println("数字输入错误，请重新输入：");
            }
        }
    }

    public static int readInt(int defaultValue) {
        while (true) {
            String str = readKeyBoard(2, true);
            if (str.equals("")) {
                return defaultValue;
            }

            try {
                int n = Integer.parseInt(str);
                return n;
            } catch (NumberFormatException var4) {
                System.out.print("数字输入错误，请重新输入：");
            }
        }
    }

    private static String readKeyBoard(int limit, boolean blankReturn) {
        String line = "";

        while (scanner.hasNextLine()) {
            line = scanner.nextLine();
            if (line.length() == 0) {
                if (blankReturn) {
                    return line;
                }
            } else {
                if (line.length() >= 1 && line.length() <= limit) {
                    break;
                }
                System.out.println("输入长度（不大于" + limit + "）错误，请重新输入：");
            }
        }
        return line;
    }
    public static String readString(int limit) {
        return readKeyBoard(limit, false);
    }



    public static char readConfirmSelection(){
        while (true){
            String str=readKeyBoard(1,false).toUpperCase();
            char c=str.charAt(0);
            if(c=='Y'||c=='N'){
                return c;
            }
            System.out.print("选择错误，请重新输入：");
        }
    }

}
```

# 二、用户登录

**功能说明**

暂时不使用数据库（后面使用HashMap模拟数据库，支持多个用户的登录）

人为规定用户名/id=100，密码123456便可以登录，其他用户不能登陆

信息的传递我们都以对象的形式来完成，将客户端和服务端交流的信息封装成对象，这便需要使用对象流



**客户端向服务端发送一个User对象，服务器端拿到User对象信息以后进行验证User对象是否合法，然后服务端给客户端回复一个message对象**

**客户端拿到message对象之后我们可以判断登录成功了还是失败了**

## 2.1 客户端

### 2.1.1 菜单界面 QQView

```java
/**
 * 菜单界面
 */
public class QQView {

    /**
     * 控制是否显示菜单
     */
    private boolean loop = true;
    /**
     * 接收用户的键盘输入
     */
    private String key = "";

    /**
     * 完成用户登录验证和用户注册等功能
     */
    public UserClientService userClientService = new UserClientService();


    public static void main(String[] args) {
        QQView qqView = new QQView();
        qqView.mainMenu();
        System.out.println("退出客户端系统");
    }

    /**
     * 显示主菜单
     */
    private void mainMenu() {
        while (loop) {
            System.out.println("***********欢迎登录网络通信系统*************");
            System.out.println("\t\t 1 登录系统");
            System.out.println("\t\t 9 退出系统");
            System.out.print("请输入你的选择:");
            key = Utility.readString(1);

            //根据用户的输入来处理不同的逻辑
            switch (key) {
                case "1":
                    System.out.print("请输入用户号");
                    String userId = Utility.readString(50);
                    System.out.print("请输入密  码");
                    String password = Utility.readString(50);

                    //TODO 到服务端验证用户是否合法
                    if (userClientService.checkUser(userId,password)) {
                        //进入二级菜单
                        System.out.println(String.format("网络通信系统二级菜单(用户%s)", userId));
                        while (loop) {
                            System.out.println(String.format("\n========网络通信系统二级菜单(用户%s)===========", userId));
                            System.out.println("\t\t 1.显示在线用户列表");
                            System.out.println("\t\t 2.群发消息");
                            System.out.println("\t\t 3.私聊消息");
                            System.out.println("\t\t 4.发送文件");
                            System.out.println("\t\t 9.退出系统");

                            System.out.print("请输入你的选择:");
                            key = Utility.readString(1);
                            switch (key) {
                                case "1":
                                    break;
                                case "2":
                                    break;
                                case "3":
                                    break;
                                case "4":
                                    break;
                                case "9":
                                    loop = false;
                                    System.out.println("退出系统");
                                    break;
                            }
                        }
                    }else {
                        System.out.println("登录服务器失败，用户名或密码存在问题");
                    }
                    break;
                case "9":
                    loop = false;
                    System.out.println("退出系统");
            }
        }
    }
}
```

### 2.1.2 验证用户UserClientService

```java
/**
 * 完成用户登录验证和用户注册等功能
 */
@Data
public class UserClientService {

    //其他地方也会使用user信息，所以将其作为一个属性
    private User user = new User();

    private Socket socket = null;

    //根据userId和pwd到服务器验证该用户是否合法
    public boolean checkUser(String userId, String pwd) {
        //临时变量b，用户是否合法的标志
        boolean b = false;

        //TODO 创建User对象
        user.setUserId(userId);
        user.setPasswd(pwd);

        try {
            //TODO 连接到服务端，发送User对象
            socket = new Socket(InetAddress.getByName("127.0.0.1"), 9999);
            //得到ObjectOutputStream对象流(序列化流，也是字节流中一种)
            ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
            oos.writeObject(user);
            oos.flush();

            //TODO 读取从服务器回复的Message对象
            ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
            Message msg = (Message) ois.readObject();

            if (MessageType.find(1).equals(msg.getMesType())) {

                //登录成功
                //一旦登录成功，我们需要启动一个线程维护或者持有此socket，保持此线程可以跟我们服务器端一直进行通信
                //不启动线程的话此Socket不好维护。如果我们有数据发送或者接收，我们可以从这个线程里面进行拉取
                //为什么将Socket放入一个线程中管理？
                // 1.如果不创建这个线程的话，一个客户端会有多个socket，socket管理起来就比较麻烦
                // 2.需要socket不断的从数据通道中读写数据，所以也必须做成一个线程
                ClientConnectServerThread ccst = new ClientConnectServerThread(socket);
                //启动客户端的线程
                ccst.start();
                //为了后面客户端的扩展，我们将线程放入到集合中管理
                ManagerClientConnectServerThread.addClientConnectServerThread(userId, ccst);

                b = true;
            } else {
                //登录失败
                //我们是有Socket的，但是没有线程，即登录失败，不能启动和服务器通信的线程
                //关闭socket
                socket.close();
            }

        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }

        return b;
    }
}
```

### 2.1.3 线程类 ClientConnectServerThread

```java
@EqualsAndHashCode(callSuper = true)
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ClientConnectServerThread extends Thread {
    //该线程需要持有Socket属性
    private Socket socket;


    /**
     *因为Thread需要在后台跟我们的服务器进行通信(保持一个联系)，因此我们使用while循环来控制
     */
    @Override
    public void run() {
        while(true){
            //一直读取从服务器端回收的消息
            System.out.println("客户端线程，等待读取从服务端发送的消息....");

            try {
                ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
                //如果服务器端没有发送消息过来，这个地方会堵塞，此线程会一直等待
                //这就是一个堵塞式网络编程，效率是相对比较低的
                Message message = (Message)ois.readObject();

            } catch (IOException | ClassNotFoundException e) {
                e.printStackTrace();
            }
        }
    }
}
```

### 2.1.4 线程集合类

```java
/**
 * 管理客户端连接到服务端线程的一个类
 */
public class ManagerClientConnectServerThread {
    //把多个线程放入一个HashMap中进行管理，key是用户id，value是客户端与服务端通信的线程
    private static HashMap<String, ClientConnectServerThread> hm = new HashMap<>();

    //将某个线程加入到集合中
    public static void addClientConnectServerThread(String userId, ClientConnectServerThread clientConnectServerThread) {
        hm.put(userId, clientConnectServerThread);
    }

    public static ClientConnectServerThread getClientConnectServerThread(String userId) {
        return hm.get(userId);
    }
}
```

## 2.2 服务端



### 2.2.1 服务端构造器

```java
/**
 * 此类创建一个QQServer对象，启动后台的服务
 */
public class QQFrame {
    public static void main(String[] args) {
        //创建QQServer对象，会启动QQServer构造器
        QQServer qqServer = new QQServer();

    }
}
```



### 2.2.2 服务端

```java
/**
 * 这是服务器，在监听9999，等待客户端的连接，并保持通信
 */
@Data
public class QQServer {

    //创建一个集合存放多个用户，如果是此用户登录，便认为是合法的
    //也可以使用ConcurrentHashMap，可以在并发的环境下处理（没有线程安全问题）
    //HashMap是没有处理线程安全的，因此在多线程情况下是不安全的
    private static HashMap<String,User> validUser = new HashMap<>();

    private ServerSocket serverSocket = null;

    /**
     * 进行类加载的时候会执行下面这个代码
     */
    static {
        validUser.put("100",new User("100","123456"));
        validUser.put("200",new User("200","123456"));
        validUser.put("300",new User("300","123456"));
        validUser.put("至尊宝",new User("至尊宝","123456"));
        validUser.put("紫霞仙子",new User("紫霞仙子","123456"));
        validUser.put("菩提老祖",new User("菩提老祖","123456"));
    }

    /**
     * 这是一个循环监听的过程
     * 并不是客户端A发送完信息服务器接收到后此服务器就关闭，而是一直监听，因为还有可能其他客户端发送过来信息
     */
    public QQServer() {
        System.out.println("服务端在9999端口监听....");
        ObjectInputStream ois = null;
        ObjectOutputStream oos = null;
        try {
            this.serverSocket = new ServerSocket(9999);

            //监听是一直进行，当和某个客户端连接后，会继续监听，因此使用while循环
            while (true) {
                //没有客户端连接9999端口时，程序会堵塞，等待连接
                Socket socket = serverSocket.accept();

                ois = new ObjectInputStream(socket.getInputStream());
                //如果服务器端没有发送消息过来，这个地方会堵塞，此线程会一直等待
                //读取客户端发送的User对象
                User user = (User) ois.readObject();

                //创建Message对象，准备恢复客户端
                Message message = new Message();
                oos = new ObjectOutputStream(socket.getOutputStream());
                //验证用户是否合法
                User userValid = validUser.get(user.getUserId());
                if (userValid!=null && userValid.getUserId().equals(user.getUserId()) && userValid.getPasswd().equals(user.getPasswd())) {
                    //合法用户
                    message.setMesType(MessageType.find(1));
                    //给客户端进行回复
//                    ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
                    oos.writeObject(message);
                    oos.flush();

                    //创建一个线程，和客户端保持通信。
                    //该线程需要持有Socket对象
                    ServerConnectClientThread serverConnectClientThread = new ServerConnectClientThread(user.getUserId(), socket);
                    serverConnectClientThread.start();

                    //把该线程对象放入到一个集合中
                    ManagerServerConnectServerThread.addClientThread(user.getUserId(), serverConnectClientThread);

                } else {
                    //登录失败
                    message.setMesType(MessageType.find(2));
                    oos.writeObject(message);
                    oos.flush();

                    socket.close();
                }
            }


        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        } finally {
//          如果服务端退出了while循环，说明服务器端不再监听了，因此需要关闭资源
            if (serverSocket != null) {
                try {
                    serverSocket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (ois !=null){
                try {
                    ois.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

            if (oos !=null){
                try {
                    oos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

        }
    }
}
```

### 2.2.3 线程类 ServerConnectClientThread

```java
/**
 * 该类对应的对象和某个客户端保持通信
 */
@EqualsAndHashCode(callSuper = true)
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ServerConnectClientThread extends Thread{

    /**
     * 可以区分此socket是和哪个用户进行关联的
     */
    private String userId;//连接到服务端的这个用户id

    private Socket socket;

    /**
     * 线程处于run状态，可以发送或者接收客户端的消息
     */
    @Override
    public void run() {
        //不断的从socket中读数据和写数据
        while(true){
            System.out.println("服务端和客户端保持通信，读取数据.... userId:"+userId);
            ObjectInputStream ois = null;
            try {
                ois = new ObjectInputStream(socket.getInputStream());
                //读取数据
                Message message = (Message) ois.readObject();

                //后面会使用Message

            } catch (IOException | ClassNotFoundException e) {
                e.printStackTrace();
            }
            //如果服务器端没有发送消息过来，这个地方会堵塞，此线程会一直等待
            //读取客户端发送的User对象

        }
    }
}
```

### 2.2.4 线程集合

```java
/**
 * 该类用于管理和客户端通信的线程
 */
@Data
public class ManagerServerConnectServerThread {
    private static HashMap<String,ServerConnectClientThread> hm = new HashMap<>();

    /**
     *添加线程对象到hm集合
     */
    public static void addClientThread(String userId, ServerConnectClientThread clientConnectServerThread) {
        hm.put(userId, clientConnectServerThread);
    }

    /**
     *从集合中获取对应线程对象
     */
    public static ServerConnectClientThread getClientThread(String userId) {
        return hm.get(userId);
    }
}
```



# 三、拉取在线用户

