[TOC]



# 一、私聊

## 1.1 分析

**客户端A和客户端B私聊的时候，其实服务端在中间做了一个转发**

**流程**： 

* 客户端A —> 服务端 —> 客户端B

* 客户端B —> 服务端 —> 客户端A

服务端可以读取到客户端A发送给客户端B的消息，服务端再从管理线程的集合中获取接收者客户端B的线程，也就能获取到其socket，此线程在服务端就会将消息发送给客户端B，也就是服务器只需要做个转发即可

![image-20231208224106294](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20231208224106294.png)





## 1.2 客户端

### 1.2.1 MessageClientService 私聊类

```java
/**
 * 该类提供和消息相关的服务方法
 */
public class MessageClientService {
    /**
     * @param content  内容
     * @param senderId 发送用户id
     * @param getterId 接收用户id
     */
    public void sendMessageToOne(String content, String senderId, String getterId) {
        //封装消息
        Message message = new Message();
        message.setContent(content);
        message.setSender(senderId);
        message.setGetter(getterId);
        message.setSendTime(new Date().toString());
        message.setMesType(MessageType.MESSAGE_COMM_MES.getCode());//普通消息
        System.out.println("用户"+senderId+"和用户"+getterId+"说:"+content);
        //获取senderId对应的socket
        ClientConnectServerThread clientConnectServerThread = ManagerClientConnectServerThread.getClientConnectServerThread(senderId);
        Socket socket = clientConnectServerThread.getSocket();

        //输出消息
        try {
            ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
            oos.writeObject(message);
            oos.flush();

        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
```



### 1.2.2 ClientConnectServerThread 线程类

```java
@EqualsAndHashCode(callSuper = true)
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ClientConnectServerThread extends Thread {
    //该线程需要持有Socket属性
    private Socket socket;


    /**
     *因为Thread需要在后台跟我们的服务器进行通信(保持一个联系)，因此我们使用while循环来控制
     */
    @Override
    public void run() {
        while(true){
            //一直读取从服务器端回收的消息
            System.out.println("客户端线程，等待读取从服务端发送的消息....");

            try {
                ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
                //如果服务器端没有发送消息过来，这个地方会堵塞，此线程会一直等待
                //这就是一个堵塞式网络编程，效率是相对比较低的
                Message message = (Message)ois.readObject();

                //判断message的类型，然后做响应的业务处理
                if (message.getMesType().equals(MessageType.MESSAGE_RETTURN_ONLINE_FRIEND.getCode())){
                    //获取在线用户，取出在线列表信息并显示
                    String[] onlineUsers = message.getContent().split(" ");
                    System.out.println("当前在线用户列表如下");
                    for (int i=0;i<onlineUsers.length;i++){
                        System.out.println("用户："+onlineUsers[i]);
                    }
                }else if (MessageType.MESSAGE_COMM_MES.getCode().equals(message.getMesType())) {
                    //转发给指定客户端，假如说客户不在线的话，可以保存到数据库，这样就可以实现离线留言
                    System.out.println("用户"+message.getGetter()+"收到来自用户"+message.getSender()+"的消息:"+message.getContent());
                }else{
                    System.out.println("其他类型的message，暂时不处理");
                }
            } catch (IOException | ClassNotFoundException e) {
                e.printStackTrace();
            }
        }
    }
}
```



## 1.3 服务端

### 1.3.1 ServerConnectClientThread 线程类

```java
/**
 * 该类对应的对象和某个客户端保持通信
 */
@EqualsAndHashCode(callSuper = true)
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ServerConnectClientThread extends Thread {

    /**
     * 可以区分此socket是和哪个用户进行关联的
     */
    private String userId;//连接到服务端的这个用户id

    private Socket socket;

    /**
     * 线程处于run状态，可以发送或者接收客户端的消息
     */
    @Override
    public void run() {
        //不断的从socket中读数据和写数据
        while (true) {
            System.out.println("服务端和客户端保持通信，读取数据.... userId:" + userId);
            ObjectInputStream ois = null;
            try {
                ois = new ObjectInputStream(socket.getInputStream());
                //读取数据
                Message message = (Message) ois.readObject();

                //根据Message的类型，判断客户端想要执行什么操作
                if (MessageType.MESSAGE_GET_ONLINE_FRIEND.getCode().equals(message.getMesType())) {
                    System.out.println("用户" + userId + "获取在线用户");
                    //拉取在线用户（客户端要拉取在线用户列表）
                    Socket socket = ManagerServerConnectServerThread.getClientThread(userId).getSocket();

                    ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
                    //构建Message发送给服务端
                    Message returnMessage = new Message();
                    returnMessage.setMesType(MessageType.MESSAGE_RETTURN_ONLINE_FRIEND.getCode());
                    returnMessage.setContent(ManagerServerConnectServerThread.getOnlineUser());
                    //说明要发送给谁
                    returnMessage.setGetter(message.getSender());
                    //返回给客户端
                    oos.writeObject(returnMessage);
                    oos.flush();
                } else if (MessageType.MESSAGE_CLIENT_EXIT.getCode().equals(message.getMesType())) {
                    //说明客户端想要退出，服务端要将socket关闭并退出线程就可以了
                    //将客户端对应的线程从集合中删除
                    ManagerServerConnectServerThread.remove(userId);
                    //关闭socket
                    socket.close();
                    System.out.println("用户" + userId + "退出系统");
                    //退出循环
                    return;
                } else if (MessageType.MESSAGE_COMM_MES.getCode().equals(message.getMesType())) {
                    //转发给指定客户端，假如说客户不在线的话，可以保存到数据库，这样就可以实现离线留言
                    Socket socket = ManagerServerConnectServerThread.getClientThread(message.getGetter()).getSocket();
                    ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());

                    oos.writeObject(message);
                    oos.flush();

                } else {
                    System.out.println("其他类型暂时不处理");
                }

            } catch (IOException | ClassNotFoundException e) {
                e.printStackTrace();
            }
            //如果服务器端没有发送消息过来，这个地方会堵塞，此线程会一直等待
            //读取客户端发送的User对象

        }
    }
}
```











## 1.4功能演示

**客户端A**

![image-20231208233050369](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20231208233050369.png)





**客户端B**

![image-20231208233107188](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20231208233107188.png)



**服务端**

![image-20231208233117506](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20231208233117506.png)

# 二、群发消息

将消息发送给所有的在线用户

## 2.1 分析

客户端A群发消息后，服务端会遍历线程集合，将消息发送给除了客户端A以外的所有客户端，完成群发功能

## 2.2 客户端

### 2.2.1 MessageClientService类

```java
/**
 * 群发消息
 * @param userId 发送消息的用户id
 * @param content 需要发送的内容
 */
public void sendMessageToOnlineUser(String userId, String content) {
    Message message = new Message();
    message.setContent(content);
    message.setSender(userId);
    message.setSendTime(new Date().toString());
    message.setMesType(MessageType.MESSAGE_TO_ALL_EXIT.getCode());//普通消息
    System.out.println("用户"+userId+"群发消息说:"+content);

    ClientConnectServerThread clientConnectServerThread = ManagerClientConnectServerThread.getClientConnectServerThread(userId);
    Socket socket = clientConnectServerThread.getSocket();

    //输出消息
    try {
        ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
        oos.writeObject(message);
        oos.flush();

    } catch (IOException e) {
        e.printStackTrace();
    }
}
```



### 2.2.2 ClientConnectServerThread 线程类

```java
else if (MessageType.MESSAGE_TO_ALL_EXIT.getCode().equals(message.getMesType())) {
    //群发消息
    System.out.println("\n用户"+message.getGetter()+"收到来自用户"+message.getSender()+"的群发消息:"+message.getContent());

}
```



## 2.3 服务端



### 2.3.1 ServerConnectClientThread 线程类

```java
else if (MessageType.MESSAGE_TO_ALL_EXIT.getCode().equals(message.getMesType())) {
    //群发消息
    //遍历线程集合取出所有线程对应的socket发送消息即可
    HashMap<String, ServerConnectClientThread> hm = ManagerServerConnectServerThread.getHm();
    Iterator<String> iterator = hm.keySet().iterator();
    while (iterator.hasNext()) {
        //取出在线人的id
        String onlineId = iterator.next();
        if (!onlineId.equals(message.getSender())) {
            ObjectOutputStream oos = new ObjectOutputStream(
                    hm.get(onlineId).getSocket().getOutputStream()
            );
            oos.writeObject(message);
            oos.flush();
        }

    }

}
```



## 2.4 测试

**客户端A**

![](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20231209001443640.png)

**客户端B**

![image-20231209001512979](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20231209001512979.png)



**服务端**

![image-20231209001526468](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20231209001526468.png)



# 三、发送文件

## 3.1 分析

![image-20231209003348777](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20231209003348777.png)



## 3.2 客户端



## 3.3 服务端

