[TOC]



# Springboot日志操作

日志的操作还是挺重要的。

特别是将项目部署到服务器之后，我们只能通过日志的提示信息查看功能是否有问题

# 一、日志基础

**日志（log）作用**：

* **编程期调试代码**
* **运营期记录信息**
  * 记录日常运营重要信息（峰值流量、平均响应时长.....）
  * 记录应用报错信息（错误堆栈）
  * 记录运维过程数据（扩容、宕机、报警....）

> 简单的说，日志就是将错误记录下来，方便程序员修改bug和调试程序

**Springboot有内置的日志logback**（Spring官方推荐）



## 1.1 创建记录日志对象

```java
@RestController
@RequestMapping("/books")
public class BookController {
    //  org.slf4j.Logger;
    //  创建记录日志对象
    private static final Logger log = LoggerFactory.getLogger(BookController.class);

    @GetMapping
    public String getById(){
        System.out.println("springboot is running .... 2");

        log.debug("debug ...");//  专门给程序员调试使用的
        log.info("info ...");
        log.warn("warn ...");
        log.error("error ...");
//      还有一个日志级别是fatal，但是在这里没有提供对应的api，原因是和error合在一块了
//      在日志系统中，对于fatal的定义是“灾难性的后果”，fatal级别是系统处于崩溃状态，但是系统崩溃了，fatal还活着，这是不可能的，所以在这里API合在一块了
        return "springboot is running ...2";
    }
}
```

我们写了4条日志，但是控制台中只有3条，原因是默认日志级别是info类型的，info级别之下的不会打印

![image-20230909164453977](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230909164453977.png)

> **日志级别ALL < TRACE < DEBUG < INFO < WARN < ERROR < FATAL < OFF**
>
> 通常使用4种：debug、info、warn、error
>
> 程序员经常使用的是debug和error
>
> 运维人员希望我们用的是info和error





## 1.2 修改日志级别

**第一种方式**

![image-20230909164833772](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230909164833772.png)

**第二种方式**

在application.yaml文件中

```yml
debug: true
```



**第三种方式**

可以这么设置但是不要这么做，这种方式只会打印和springboot相关的

```yaml
logging:
	level: debug
```

尽量下面这个样子，设置一下当前项目根路径下root所有的级别为debug

```yaml
logging:
	level: 
	root: debug
```

root表示根节点，即整体应用日志级别（所用的包里面的调试信息全部都会打印出来）

## 1.3  日志级别的力度控制

**调试程序的时候使用debug级别，但是老报框架里面的debug日志，但是我不想看这部分日志，怎么做**？

**设置日志级别的力度控制**，有各种各样的设置规则

* **设置某个包的日志级别**

  如下所示：整体info级别，但是com.zhangjingqi.controller包下是debug级别

  但是这种不推荐，包很多的话，根本设置不过来

```yaml
logging:
	level: 
	  root: info
	  com.zhangjingqi.controller: debug
```

* **设置分组，对某个分组设置日志级别**

  把若干个包打成一个组，对这个组设置日志级别

1. **第一步：设置分组**

```yaml
logging:
	level: 
	  root: info
	  com.zhangjingqi.controller: debug
	# 设置分组
	group: 
		ebank: com.zhangjingqi.controller,com.zhangjingqi.dao
		iservice: com.zhangjingqi.service
```

2. **第二步： 对组设置级别**

```yaml
logging:
	# 设置分组
	group: 
		ebank: com.zhangjingqi.controller,com.zhangjingqi.dao
		iservice: com.zhangjingqi.service
		
	level: 
	  root: info
	  # 对某个组设置日志级别
	  ebank: warn

```





## 1.4 快速创建日志对象

### 1.4.1 继承

我们不能在每个类中都采用下面这种形式创建日志对象，特别麻烦

```java
    private static final Logger log = LoggerFactory.getLogger(类名.class);
```

**我们可以采用继承一个类，这个类中有此方法，或者采用AOP的方式**

```java
public class BaseClass {

    private  Class clazz;

    public static  Logger log;

    public BaseClass() {
//      初始化当前类对象
        clazz = this.getClass();
//      初始化log对象
        log = LoggerFactory.getLogger(BookController.class);
    }

}
```



此时我们的controller层

```java
@RestController
@RequestMapping("/books")
public class BookController extends BaseClass{

    @GetMapping
    public String getById(){
        System.out.println("springboot is running .... 2");

        log.debug("debug ...");//  专门给程序员调试使用的
        log.info("info ...");
        log.warn("warn ...");
        log.error("error ...");
//      还有一个日志级别是fatal，但是在这里没有提供对应的api，原因是和error合在一块了
//      在日志系统中，对于fatal的定义是“灾难性的后果”，fatal级别是系统处于崩溃状态，但是系统崩溃了，fatal还活着，这是不可能的，所以在这里API合在一块了
        return "springboot is running ...2";
    }
}
```



### 1.4.2 Lombok 注解

```java
@Slf4j
@RestController
@RequestMapping("/books")
public class BookController {

    @GetMapping
    public String getById(){
        System.out.println("springboot is running .... 2");

        log.debug("debug ...");//  专门给程序员调试使用的
        log.info("info ...");
        log.warn("warn ...");
        log.error("error ...");
//      还有一个日志级别是fatal，但是在这里没有提供对应的api，原因是和error合在一块了
//      在日志系统中，对于fatal的定义是“灾难性的后果”，fatal级别是系统处于崩溃状态，但是系统崩溃了，fatal还活着，这是不可能的，所以在这里API合在一块了
        return "springboot is running ...2";
    }
}
```



```xml
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
</dependency>
```



# 二、日志输出格式控制

![image-20230909174437015](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230909174437015.png)

**如果我们的日志不想记录成上面那样，也是能够设置的**

* **设置日志输出格式**

  日志模板

```yaml
logging:
	pattern:
		console: "%d - %m%n"
```

* **%d**：日期

* **%m**：消息

* **%n**：换行，如果是%5n，表示占5位
* **%p**：level，日志级别

![image-20230909175045831](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230909175045831.png)

* **%clr()**：添加颜色，比如 %clr(%5n)，指定颜色 %clr(%5n){cyan}，指定为青色
* **%t**：线程名
* **%c**： 类名，这样默认是右对齐，如果是%-40c表示长度40位的左对齐；40位长，如果超过40位就做删除处理%-40.40c ,第二个40是对内容的截取



# 三、日志文件

，目前现在日志都是输出在控制台上，但是我们上线之后是看不到控制台的，这怎么办？

此时便需要将我们的日志记录到文件里面

```yaml
logging:
  level:
    root: info
  file:
    path: server.log
```

日志记录到磁盘不是实时刷新的，只有到达一定的缓冲量后才写入到磁盘

那生成的文件在哪里呢？

![image-20230910120909095](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230910120909095.png)

![image-20230910121029519](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230910121029519.png)

> **logging.file.path仅仅用于指定日志输出的目录，且不能指定输出的文件名，且默认名为spring.log  若指定的是相对目录，则会生成在当前总项目的目录下**

如果是下面这么配置

```yaml
logging:
  level:
    root: info
  file:
    name: server.log
```



文件中就会存在控制台的信息

![image-20230910121111898](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230910121111898.png)

随着项目的进行，日志信息越来越多，一个日志文件是不足以支撑的，我们可以**一天一个日志文件**

```yaml
logging:
  level:
    root: info
  file:
    name: "server.log"
    path: "E:/logging/"
  logback:
    rollingpolicy:
#     设置文件最大大小4KB
      max-file-size: 4KB
#     以后生成的文件格式就是 server.2020-01-01.0.log 最后那个0代表这天的第一个文件
      file-name-pattern: server.%d{yyyy-MM-dd}.%i.log
```





## 3.1 日志技术介绍

**日志框架**：第三方人员已经做好的实现代码，后来者可以直接拿去使用

**日志接口**：设置日志框架的一套标准，日志框架需要实现这些接口

> 因为对Commons Logging接口不满意，有人写了Slf4j
>
> 对Log4j性能不满意，有人搞了Logback
>
> Logback是基于Slf4j的日志规范实现的框架

![image-20230910142156363](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230910142156363.png)



> Logback官方网站：[Logback Home (qos.ch)](https://logback.qos.ch/index.html)
>



![image-20230910143257259](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230910143257259.png)

想使用Logback日志框架，**至少**需要在项目中整合如下**三个模块**：

* **slf4j-api**：日志接口
* **logback-core**： 基础模块(一定要有这个模块)
* **logback-classic**：可以同化为显著改进了Log4j 1.x的版本；此外logback-classic原生实现了**SLF4J API**，以便随时可以在logback和其他日志记录框架之间来回切换（**核心功能模块**）

**有了上述三个模块，就可以使用其记录日志了**



## 3.2 Logback的快速入门

**需求**：使用Logback日志框架，记录系统的运行信息

**实现步骤**

**① 导入Logback框架到项目中**

**②生成记录器**

### 3.2.1 Maven坐标

> slf4j-api日志接口、logback-core核心基础模块、logback-classic核心功能模块。
>
> 必须把这三个模块导入到项目中去

```xml
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>1.7.26</version>
</dependency>

<dependency>
    <groupId>ch.qos.logback</groupId>
    <artifactId>logback-core</artifactId>
    <version>1.2.3</version>
</dependency>

<dependency>
    <groupId>ch.qos.logback</groupId>
    <artifactId>logback-classic</artifactId>
    <version>1.2.3</version>
</dependency>
```

但是我们在maven使用时，只加入logback-classic,因为引入他后，其他两个也跟着引入了

```xml
<dependency>
    <groupId>ch.qos.logback</groupId>
    <artifactId>logback-classic</artifactId>
    <version>1.2.3</version>
</dependency>
```

![image-20230910144722085](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230910144722085.png)

### 3.2.2 生成记录器

**生成记录器**

```java
    private static final Logger log = LoggerFactory.getLogger(BookController.class);
```

或者使用下面这种方式

```java
    private static final Logger log = LoggerFactory.getLogger("com.atguigu.paymentdemo.controller.BookController");
```

#### 3.2.2.1 记录器的结构

在Logback中，所有的计数器都是缓存在Map中，所有记录器之间的关系按照下面树状结构去组织

![image-20230910145453406](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230910145453406.png)

比如下面，log2就是log的父记录器。根记录器是默认生成的，是不需要创建的

```java
    private static final Logger log2 = LoggerFactory.getLogger("com.atguigu.paymentdemo.controller");
```

下面log3记录器继承于根记录器，

```java
private static final Logger log3 = LoggerFactory.getLogger("com");
```

每个记录器是有属性的，子记录器会继承父记录器的属性

所以这就导致了某些日志会重复打印，这就是记录器的叠加性或者说累加性

当我们执行下面这条语句的时候，一般会把父记录器也创建出来

```java
private static final Logger log3 = LoggerFactory.getLogger("com.example.App");
```

如果一个记录器也没有的话，下面这一条命令会创建3个记录器（根记录器已经有了）

![image-20230910150620352](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230910150620352.png)

假如此时我再创建一个App2的记录器,此时只需要创建一个App2的记录器即可

```java
private static final Logger log3 = LoggerFactory.getLogger("com.example.App2");
```

获取根记录器

```java
private static final Logger log3 = LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);
```





#### 3.2.2.2 记录器的属性

* **name**：记录器的名称，也是记录器的唯一标识

  下面的代码中传入的参数便是记录器的名称。

  记录器缓存在系统的Map中，name相当于Map中的Key

```java
private static final Logger log3 = LoggerFactory.getLogger("com.example.App2");
```



* **level（可选）属性**：记录器的级别，允许的级别从低到高，TRACE< DEBUG <INFO< WARN< ERROR

  设置记录器的级别可以使用配置文件，也可以使用代码，如下就是代码的形式

```java
logger,setLevel(); //指定级别
logger.getLevel(); //查看当前级别
logger.getEffectiveLevel() //查看实际起作用（实际有效）的级别
```



* **additivity（可选）属性**：是否允许叠加打印日志，true 或 false



> **说明**：
>
> 1. 如果记录器未设置level属性，则该记录器的级别从上级记录器继承
>
> 2. 如果想查看记录器的级别，应该通过logger.getEfectiveLevel()方法，同时要将Logger转为
>
>    ch.qos.logback.classic.Logger类型，如下 
>
>    ```java
>    ch.gos.logback.classic.Logger logger =(ch.qos.logback.classic.Logger) LoggerFactory.getLogger(App.class)
>    ```













# 四、Logback



![image-20230928111612390](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20230928111612390.png)

